schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "chat"
"""
type chat {
  chat_info(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  chat_participants(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """An aggregate relationship"""
  chat_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!
  id: Int!
  messages(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "chat"
"""
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

"""
aggregate fields of "chat"
"""
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int!
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input chat_append_input {
  chat_info: jsonb
  messages: jsonb
}

"""aggregate avg on columns"""
type chat_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
"""
input chat_bool_exp {
  _and: [chat_bool_exp!]
  _not: chat_bool_exp
  _or: [chat_bool_exp!]
  chat_info: jsonb_comparison_exp
  chat_participants: chat_participant_bool_exp
  id: Int_comparison_exp
  messages: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "chat"
"""
enum chat_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input chat_delete_at_path_input {
  chat_info: [String!]
  messages: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input chat_delete_elem_input {
  chat_info: Int
  messages: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input chat_delete_key_input {
  chat_info: String
  messages: String
}

"""
input type for incrementing numeric columns in table "chat"
"""
input chat_inc_input {
  id: Int
}

"""
input type for inserting data into table "chat"
"""
input chat_insert_input {
  chat_info: jsonb
  chat_participants: chat_participant_arr_rel_insert_input
  id: Int
  messages: jsonb
}

"""aggregate max on columns"""
type chat_max_fields {
  id: Int
}

"""aggregate min on columns"""
type chat_min_fields {
  id: Int
}

"""
response of any mutation on the table "chat"
"""
type chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat!]!
}

"""
input type for inserting object relation for remote table "chat"
"""
input chat_obj_rel_insert_input {
  data: chat_insert_input!

  """upsert condition"""
  on_conflict: chat_on_conflict
}

"""
on_conflict condition type for table "chat"
"""
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]! = []
  where: chat_bool_exp
}

"""Ordering options when selecting data from "chat"."""
input chat_order_by {
  chat_info: order_by
  chat_participants_aggregate: chat_participant_aggregate_order_by
  id: order_by
  messages: order_by
}

"""
columns and relationships of "chat_participant"
"""
type chat_participant {
  app_type_id: String!

  """An object relationship"""
  chat: chat!
  chat_id: Int!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  participant_id: Int!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "chat_participant"
"""
type chat_participant_aggregate {
  aggregate: chat_participant_aggregate_fields
  nodes: [chat_participant!]!
}

"""
aggregate fields of "chat_participant"
"""
type chat_participant_aggregate_fields {
  avg: chat_participant_avg_fields
  count(columns: [chat_participant_select_column!], distinct: Boolean): Int!
  max: chat_participant_max_fields
  min: chat_participant_min_fields
  stddev: chat_participant_stddev_fields
  stddev_pop: chat_participant_stddev_pop_fields
  stddev_samp: chat_participant_stddev_samp_fields
  sum: chat_participant_sum_fields
  var_pop: chat_participant_var_pop_fields
  var_samp: chat_participant_var_samp_fields
  variance: chat_participant_variance_fields
}

"""
order by aggregate values of table "chat_participant"
"""
input chat_participant_aggregate_order_by {
  avg: chat_participant_avg_order_by
  count: order_by
  max: chat_participant_max_order_by
  min: chat_participant_min_order_by
  stddev: chat_participant_stddev_order_by
  stddev_pop: chat_participant_stddev_pop_order_by
  stddev_samp: chat_participant_stddev_samp_order_by
  sum: chat_participant_sum_order_by
  var_pop: chat_participant_var_pop_order_by
  var_samp: chat_participant_var_samp_order_by
  variance: chat_participant_variance_order_by
}

"""
input type for inserting array relation for remote table "chat_participant"
"""
input chat_participant_arr_rel_insert_input {
  data: [chat_participant_insert_input!]!

  """upsert condition"""
  on_conflict: chat_participant_on_conflict
}

"""aggregate avg on columns"""
type chat_participant_avg_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by avg() on columns of table "chat_participant"
"""
input chat_participant_avg_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""
Boolean expression to filter rows from the table "chat_participant". All fields are combined with a logical 'AND'.
"""
input chat_participant_bool_exp {
  _and: [chat_participant_bool_exp!]
  _not: chat_participant_bool_exp
  _or: [chat_participant_bool_exp!]
  app_type_id: String_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  participant_id: Int_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "chat_participant"
"""
enum chat_participant_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_participants_pkey
}

"""
input type for incrementing numeric columns in table "chat_participant"
"""
input chat_participant_inc_input {
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""
input type for inserting data into table "chat_participant"
"""
input chat_participant_insert_input {
  app_type_id: String
  chat: chat_obj_rel_insert_input
  chat_id: Int
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  participant_id: Int
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type chat_participant_max_fields {
  app_type_id: String
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""
order by max() on columns of table "chat_participant"
"""
input chat_participant_max_order_by {
  app_type_id: order_by
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""aggregate min on columns"""
type chat_participant_min_fields {
  app_type_id: String
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""
order by min() on columns of table "chat_participant"
"""
input chat_participant_min_order_by {
  app_type_id: order_by
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""
response of any mutation on the table "chat_participant"
"""
type chat_participant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat_participant!]!
}

"""
on_conflict condition type for table "chat_participant"
"""
input chat_participant_on_conflict {
  constraint: chat_participant_constraint!
  update_columns: [chat_participant_update_column!]! = []
  where: chat_participant_bool_exp
}

"""Ordering options when selecting data from "chat_participant"."""
input chat_participant_order_by {
  app_type_id: order_by
  chat: chat_order_by
  chat_id: order_by
  id: order_by
  notification_info: notification_info_order_by
  participant_id: order_by
  user: user_order_by
}

"""primary key columns input for table: chat_participant"""
input chat_participant_pk_columns_input {
  id: Int!
}

"""
select columns of table "chat_participant"
"""
enum chat_participant_select_column {
  """column name"""
  app_type_id
<<<<<<< HEAD

  """column name"""
  chat_id
=======

  """column name"""
  chat_id

  """column name"""
  id
>>>>>>> hasura_ts

  """column name"""
  participant_id
}

"""
input type for updating data in table "chat_participant"
"""
input chat_participant_set_input {
  app_type_id: String
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""aggregate stddev on columns"""
type chat_participant_stddev_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by stddev() on columns of table "chat_participant"
"""
input chat_participant_stddev_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""aggregate stddev_pop on columns"""
type chat_participant_stddev_pop_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by stddev_pop() on columns of table "chat_participant"
"""
input chat_participant_stddev_pop_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""aggregate stddev_samp on columns"""
type chat_participant_stddev_samp_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by stddev_samp() on columns of table "chat_participant"
"""
input chat_participant_stddev_samp_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""
Streaming cursor of the table "chat_participant"
"""
input chat_participant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_participant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_participant_stream_cursor_value_input {
  app_type_id: String
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""aggregate sum on columns"""
type chat_participant_sum_fields {
  chat_id: Int
<<<<<<< HEAD
=======
  id: Int
>>>>>>> hasura_ts
  participant_id: Int
}

"""
order by sum() on columns of table "chat_participant"
"""
input chat_participant_sum_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""
update columns of table "chat_participant"
"""
enum chat_participant_update_column {
  """column name"""
  app_type_id
<<<<<<< HEAD

  """column name"""
  chat_id
=======

  """column name"""
  chat_id

  """column name"""
  id
>>>>>>> hasura_ts

  """column name"""
  participant_id
}

input chat_participant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_participant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_participant_set_input
  where: chat_participant_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_participant_var_pop_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by var_pop() on columns of table "chat_participant"
"""
input chat_participant_var_pop_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""aggregate var_samp on columns"""
type chat_participant_var_samp_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by var_samp() on columns of table "chat_participant"
"""
input chat_participant_var_samp_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""aggregate variance on columns"""
type chat_participant_variance_fields {
  chat_id: Float
<<<<<<< HEAD
=======
  id: Float
>>>>>>> hasura_ts
  participant_id: Float
}

"""
order by variance() on columns of table "chat_participant"
"""
input chat_participant_variance_order_by {
  chat_id: order_by
<<<<<<< HEAD
=======
  id: order_by
>>>>>>> hasura_ts
  participant_id: order_by
}

"""primary key columns input for table: chat"""
input chat_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input chat_prepend_input {
  chat_info: jsonb
  messages: jsonb
}

"""
select columns of table "chat"
"""
enum chat_select_column {
  """column name"""
  chat_info

  """column name"""
  id

  """column name"""
  messages
}

"""
input type for updating data in table "chat"
"""
input chat_set_input {
  chat_info: jsonb
  id: Int
  messages: jsonb
}

"""aggregate stddev on columns"""
type chat_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type chat_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type chat_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "chat"
"""
input chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_stream_cursor_value_input {
  chat_info: jsonb
  id: Int
  messages: jsonb
}

"""aggregate sum on columns"""
type chat_sum_fields {
  id: Int
}

"""
update columns of table "chat"
"""
enum chat_update_column {
  """column name"""
  chat_info

  """column name"""
  id

  """column name"""
  messages
}

input chat_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: chat_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: chat_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: chat_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: chat_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: chat_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_set_input
  where: chat_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type chat_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type chat_variance_fields {
  id: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "customer"
"""
type customer {
  app_version: String!

  """An object relationship"""
  cart: restaurant_cart

  """An array relationship"""
  deliveries(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): [delivery!]!

  """An aggregate relationship"""
  deliveries_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): delivery_aggregate!
  notification_info_id: Int

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "customer"
"""
type customer_aggregate {
  aggregate: customer_aggregate_fields
  nodes: [customer!]!
}

"""
aggregate fields of "customer"
"""
type customer_aggregate_fields {
  avg: customer_avg_fields
  count(columns: [customer_select_column!], distinct: Boolean): Int!
  max: customer_max_fields
  min: customer_min_fields
  stddev: customer_stddev_fields
  stddev_pop: customer_stddev_pop_fields
  stddev_samp: customer_stddev_samp_fields
  sum: customer_sum_fields
  var_pop: customer_var_pop_fields
  var_samp: customer_var_samp_fields
  variance: customer_variance_fields
}

"""aggregate avg on columns"""
type customer_avg_fields {
  notification_info_id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "customer". All fields are combined with a logical 'AND'.
"""
input customer_bool_exp {
  _and: [customer_bool_exp!]
  _not: customer_bool_exp
  _or: [customer_bool_exp!]
  app_version: String_comparison_exp
  cart: restaurant_cart_bool_exp
  deliveries: delivery_bool_exp
  notification_info_id: Int_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "customer"
"""
enum customer_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  customer_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  customer_user_id_key
}

"""
input type for incrementing numeric columns in table "customer"
"""
input customer_inc_input {
  notification_info_id: Int
  user_id: Int
}

"""
input type for inserting data into table "customer"
"""
input customer_insert_input {
  app_version: String
  cart: restaurant_cart_obj_rel_insert_input
  deliveries: delivery_arr_rel_insert_input
  notification_info_id: Int
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type customer_max_fields {
  app_version: String
  notification_info_id: Int
  user_id: Int
}

"""aggregate min on columns"""
type customer_min_fields {
  app_version: String
  notification_info_id: Int
  user_id: Int
}

"""
response of any mutation on the table "customer"
"""
type customer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer!]!
}

"""
input type for inserting object relation for remote table "customer"
"""
input customer_obj_rel_insert_input {
  data: customer_insert_input!

  """upsert condition"""
  on_conflict: customer_on_conflict
}

"""
on_conflict condition type for table "customer"
"""
input customer_on_conflict {
  constraint: customer_constraint!
  update_columns: [customer_update_column!]! = []
  where: customer_bool_exp
}

"""Ordering options when selecting data from "customer"."""
input customer_order_by {
  app_version: order_by
  cart: restaurant_cart_order_by
  deliveries_aggregate: delivery_aggregate_order_by
  notification_info_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: customer"""
input customer_pk_columns_input {
  user_id: Int!
}

"""
select columns of table "customer"
"""
enum customer_select_column {
  """column name"""
  app_version

  """column name"""
  notification_info_id

  """column name"""
  user_id
}

"""
input type for updating data in table "customer"
"""
input customer_set_input {
  app_version: String
  notification_info_id: Int
  user_id: Int
}

"""aggregate stddev on columns"""
type customer_stddev_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type customer_stddev_pop_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type customer_stddev_samp_fields {
  notification_info_id: Float
  user_id: Float
}

"""
Streaming cursor of the table "customer"
"""
input customer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_stream_cursor_value_input {
  app_version: String
  notification_info_id: Int
  user_id: Int
}

"""aggregate sum on columns"""
type customer_sum_fields {
  notification_info_id: Int
  user_id: Int
}

"""
update columns of table "customer"
"""
enum customer_update_column {
  """column name"""
  app_version

  """column name"""
  notification_info_id

  """column name"""
  user_id
}

input customer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: customer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: customer_set_input
  where: customer_bool_exp!
}

"""aggregate var_pop on columns"""
type customer_var_pop_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type customer_var_samp_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type customer_variance_fields {
  notification_info_id: Float
  user_id: Float
}

"""
columns and relationships of "deliverer"
"""
type deliverer {
  app_version: String
  current_location: geography
  delivery_company_id: Int!
  delivery_company_type: String!
  id: Int!

  """awaiting_approval, authorized, banned"""
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "deliverer"
"""
type deliverer_aggregate {
  aggregate: deliverer_aggregate_fields
  nodes: [deliverer!]!
}

"""
aggregate fields of "deliverer"
"""
type deliverer_aggregate_fields {
  avg: deliverer_avg_fields
  count(columns: [deliverer_select_column!], distinct: Boolean): Int!
  max: deliverer_max_fields
  min: deliverer_min_fields
  stddev: deliverer_stddev_fields
  stddev_pop: deliverer_stddev_pop_fields
  stddev_samp: deliverer_stddev_samp_fields
  sum: deliverer_sum_fields
  var_pop: deliverer_var_pop_fields
  var_samp: deliverer_var_samp_fields
  variance: deliverer_variance_fields
}

"""aggregate avg on columns"""
type deliverer_avg_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "deliverer". All fields are combined with a logical 'AND'.
"""
input deliverer_bool_exp {
  _and: [deliverer_bool_exp!]
  _not: deliverer_bool_exp
  _or: [deliverer_bool_exp!]
  app_version: String_comparison_exp
  current_location: geography_comparison_exp
  delivery_company_id: Int_comparison_exp
  delivery_company_type: String_comparison_exp
  id: Int_comparison_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "deliverer"
"""
enum deliverer_constraint {
  """
  unique or primary key constraint on columns "delivery_company_type", "delivery_company_id"
  """
  delivery_company_index

  """
  unique or primary key constraint on columns "id"
  """
  driver_pkey
}

"""
input type for incrementing numeric columns in table "deliverer"
"""
input deliverer_inc_input {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "deliverer"
"""
input deliverer_insert_input {
  app_version: String
  current_location: geography
  delivery_company_id: Int
  delivery_company_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type deliverer_max_fields {
  app_version: String
  delivery_company_id: Int
  delivery_company_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate min on columns"""
type deliverer_min_fields {
  app_version: String
  delivery_company_id: Int
  delivery_company_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""
response of any mutation on the table "deliverer"
"""
type deliverer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [deliverer!]!
}

"""
input type for inserting object relation for remote table "deliverer"
"""
input deliverer_obj_rel_insert_input {
  data: deliverer_insert_input!

  """upsert condition"""
  on_conflict: deliverer_on_conflict
}

"""
on_conflict condition type for table "deliverer"
"""
input deliverer_on_conflict {
  constraint: deliverer_constraint!
  update_columns: [deliverer_update_column!]! = []
  where: deliverer_bool_exp
}

"""Ordering options when selecting data from "deliverer"."""
input deliverer_order_by {
  app_version: order_by
  current_location: order_by
  delivery_company_id: order_by
  delivery_company_type: order_by
  id: order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: deliverer"""
input deliverer_pk_columns_input {
  id: Int!
}

"""
select columns of table "deliverer"
"""
enum deliverer_select_column {
  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  id

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "deliverer"
"""
input deliverer_set_input {
  app_version: String
  current_location: geography
  delivery_company_id: Int
  delivery_company_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type deliverer_stddev_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type deliverer_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type deliverer_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
Streaming cursor of the table "deliverer"
"""
input deliverer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: deliverer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input deliverer_stream_cursor_value_input {
  app_version: String
  current_location: geography
  delivery_company_id: Int
  delivery_company_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type deliverer_sum_fields {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
update columns of table "deliverer"
"""
enum deliverer_update_column {
  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  id

  """column name"""
  status

  """column name"""
  user_id
}

input deliverer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: deliverer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: deliverer_set_input
  where: deliverer_bool_exp!
}

"""aggregate var_pop on columns"""
type deliverer_var_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type deliverer_var_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type deliverer_variance_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
columns and relationships of "delivery"
"""
type delivery {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz

  """An object relationship"""
  chat_with_customer: chat!
  chat_with_customer_id: Int!

  """An object relationship"""
  chat_with_service_provider: chat
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int!

  """An object relationship"""
  customer_review_by_driver: review
  customer_review_by_driver_id: Int

  """An object relationship"""
  deliverer: deliverer
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money!

  """An object relationship"""
  driver_review_by_customer: review
  driver_review_by_customer_id: Int

  """An object relationship"""
  driver_review_by_service_provider: review
  driver_review_by_service_provider_id: Int
  dropoff_address: String!
  dropoff_gps: geography!
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int!
  order_time: timestamptz!
  package_cost: money!
  payment_type: String!
  pickup_address: String!
  pickup_gps: geography!
  service_provider_id: Int

  """An object relationship"""
  service_provider_review_by_driver: review
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String!
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
aggregated selection of "delivery"
"""
type delivery_aggregate {
  aggregate: delivery_aggregate_fields
  nodes: [delivery!]!
}

"""
aggregate fields of "delivery"
"""
type delivery_aggregate_fields {
  avg: delivery_avg_fields
  count(columns: [delivery_select_column!], distinct: Boolean): Int!
  max: delivery_max_fields
  min: delivery_min_fields
  stddev: delivery_stddev_fields
  stddev_pop: delivery_stddev_pop_fields
  stddev_samp: delivery_stddev_samp_fields
  sum: delivery_sum_fields
  var_pop: delivery_var_pop_fields
  var_samp: delivery_var_samp_fields
  variance: delivery_variance_fields
}

"""
order by aggregate values of table "delivery"
"""
input delivery_aggregate_order_by {
  avg: delivery_avg_order_by
  count: order_by
  max: delivery_max_order_by
  min: delivery_min_order_by
  stddev: delivery_stddev_order_by
  stddev_pop: delivery_stddev_pop_order_by
  stddev_samp: delivery_stddev_samp_order_by
  sum: delivery_sum_order_by
  var_pop: delivery_var_pop_order_by
  var_samp: delivery_var_samp_order_by
  variance: delivery_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery"
"""
input delivery_arr_rel_insert_input {
  data: [delivery_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_on_conflict
}

"""aggregate avg on columns"""
type delivery_avg_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by avg() on columns of table "delivery"
"""
input delivery_avg_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Boolean expression to filter rows from the table "delivery". All fields are combined with a logical 'AND'.
"""
input delivery_bool_exp {
  _and: [delivery_bool_exp!]
  _not: delivery_bool_exp
  _or: [delivery_bool_exp!]
  actual_arrival_at_dropoff_time: timestamptz_comparison_exp
  actual_arrival_at_pickup_time: timestamptz_comparison_exp
  actual_delivered_time: timestamptz_comparison_exp
  actual_package_ready_time: timestamptz_comparison_exp
  chat_with_customer: chat_bool_exp
  chat_with_customer_id: Int_comparison_exp
  chat_with_service_provider: chat_bool_exp
  chat_with_service_provider_id: Int_comparison_exp
  current_gps: geography_comparison_exp
  customer_id: Int_comparison_exp
  customer_review_by_driver: review_bool_exp
  customer_review_by_driver_id: Int_comparison_exp
  deliverer: deliverer_bool_exp
  deliverer_app_type_id: String_comparison_exp
  deliverer_id: Int_comparison_exp
  delivery_cost: money_comparison_exp
  driver_review_by_customer: review_bool_exp
  driver_review_by_customer_id: Int_comparison_exp
  driver_review_by_service_provider: review_bool_exp
  driver_review_by_service_provider_id: Int_comparison_exp
  dropoff_address: String_comparison_exp
  dropoff_gps: geography_comparison_exp
  estimated_arrival_at_dropoff_time: timestamptz_comparison_exp
  estimated_arrival_at_pickup_time: timestamptz_comparison_exp
  estimated_package_ready_time: timestamptz_comparison_exp
  id: Int_comparison_exp
  order_time: timestamptz_comparison_exp
  package_cost: money_comparison_exp
  payment_type: String_comparison_exp
  pickup_address: String_comparison_exp
  pickup_gps: geography_comparison_exp
  service_provider_id: Int_comparison_exp
  service_provider_review_by_driver: review_bool_exp
  service_provider_review_by_driver_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  status: String_comparison_exp
  stripe_payment_id: Int_comparison_exp
  trip_distance: Int_comparison_exp
  trip_duration: Int_comparison_exp
  trip_polyline: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery"
"""
enum delivery_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_pkey
}

"""
input type for incrementing numeric columns in table "delivery"
"""
input delivery_inc_input {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
input type for inserting data into table "delivery"
"""
input delivery_insert_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  chat_with_customer: chat_obj_rel_insert_input
  chat_with_customer_id: Int
  chat_with_service_provider: chat_obj_rel_insert_input
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver: review_obj_rel_insert_input
  customer_review_by_driver_id: Int
  deliverer: deliverer_obj_rel_insert_input
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer: review_obj_rel_insert_input
  driver_review_by_customer_id: Int
  driver_review_by_service_provider: review_obj_rel_insert_input
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  service_provider_id: Int
  service_provider_review_by_driver: review_obj_rel_insert_input
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate max on columns"""
type delivery_max_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  package_cost: money
  payment_type: String
  pickup_address: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by max() on columns of table "delivery"
"""
input delivery_max_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_app_type_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by

  """orderReceived"""
  status: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""aggregate min on columns"""
type delivery_min_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  package_cost: money
  payment_type: String
  pickup_address: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by min() on columns of table "delivery"
"""
input delivery_min_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_app_type_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by

  """orderReceived"""
  status: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""
response of any mutation on the table "delivery"
"""
type delivery_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery!]!
}

"""
input type for inserting object relation for remote table "delivery"
"""
input delivery_obj_rel_insert_input {
  data: delivery_insert_input!

  """upsert condition"""
  on_conflict: delivery_on_conflict
}

"""
on_conflict condition type for table "delivery"
"""
input delivery_on_conflict {
  constraint: delivery_constraint!
  update_columns: [delivery_update_column!]! = []
  where: delivery_bool_exp
}

"""Ordering options when selecting data from "delivery"."""
input delivery_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  chat_with_customer: chat_order_by
  chat_with_customer_id: order_by
  chat_with_service_provider: chat_order_by
  chat_with_service_provider_id: order_by
  current_gps: order_by
  customer_id: order_by
  customer_review_by_driver: review_order_by
  customer_review_by_driver_id: order_by
  deliverer: deliverer_order_by
  deliverer_app_type_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer: review_order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider: review_order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  dropoff_gps: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  pickup_gps: order_by
  service_provider_id: order_by
  service_provider_review_by_driver: review_order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by
  status: order_by
  stripe_payment_id: order_by
  trip_distance: order_by
  trip_duration: order_by
  trip_polyline: order_by
}

"""primary key columns input for table: delivery"""
input delivery_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery"
"""
enum delivery_select_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  deliverer_app_type_id

  """column name"""
  deliverer_id

  """column name"""
  delivery_cost

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  package_cost

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

"""
input type for updating data in table "delivery"
"""
input delivery_set_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate stddev on columns"""
type delivery_stddev_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev() on columns of table "delivery"
"""
input delivery_stddev_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_stddev_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_pop() on columns of table "delivery"
"""
input delivery_stddev_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_stddev_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_samp() on columns of table "delivery"
"""
input delivery_stddev_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Streaming cursor of the table "delivery"
"""
input delivery_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_stream_cursor_value_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_app_type_id: String
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String

  """orderReceived"""
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate sum on columns"""
type delivery_sum_fields {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  deliverer_id: Int
  delivery_cost: money
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
order by sum() on columns of table "delivery"
"""
input delivery_sum_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
update columns of table "delivery"
"""
enum delivery_update_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  deliverer_app_type_id

  """column name"""
  deliverer_id

  """column name"""
  delivery_cost

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  package_cost

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

input delivery_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_set_input
  where: delivery_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_var_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_pop() on columns of table "delivery"
"""
input delivery_var_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate var_samp on columns"""
type delivery_var_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_samp() on columns of table "delivery"
"""
input delivery_var_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate variance on columns"""
type delivery_variance_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  deliverer_id: Float
  delivery_cost: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by variance() on columns of table "delivery"
"""
input delivery_variance_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  deliverer_id: order_by
  delivery_cost: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "mez_admin"
"""
type mez_admin {
  """An object relationship"""
  notification_info: notification_info
  notification_info_id: Int
  user_id: Int!
  version: String
}

"""
aggregated selection of "mez_admin"
"""
type mez_admin_aggregate {
  aggregate: mez_admin_aggregate_fields
  nodes: [mez_admin!]!
}

"""
aggregate fields of "mez_admin"
"""
type mez_admin_aggregate_fields {
  avg: mez_admin_avg_fields
  count(columns: [mez_admin_select_column!], distinct: Boolean): Int!
  max: mez_admin_max_fields
  min: mez_admin_min_fields
  stddev: mez_admin_stddev_fields
  stddev_pop: mez_admin_stddev_pop_fields
  stddev_samp: mez_admin_stddev_samp_fields
  sum: mez_admin_sum_fields
  var_pop: mez_admin_var_pop_fields
  var_samp: mez_admin_var_samp_fields
  variance: mez_admin_variance_fields
}

"""aggregate avg on columns"""
type mez_admin_avg_fields {
  notification_info_id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "mez_admin". All fields are combined with a logical 'AND'.
"""
input mez_admin_bool_exp {
  _and: [mez_admin_bool_exp!]
  _not: mez_admin_bool_exp
  _or: [mez_admin_bool_exp!]
  notification_info: notification_info_bool_exp
  notification_info_id: Int_comparison_exp
  user_id: Int_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "mez_admin"
"""
enum mez_admin_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  mez_admin_pkey
}

"""
input type for incrementing numeric columns in table "mez_admin"
"""
input mez_admin_inc_input {
  notification_info_id: Int
  user_id: Int
}

"""
input type for inserting data into table "mez_admin"
"""
input mez_admin_insert_input {
  notification_info: notification_info_obj_rel_insert_input
  notification_info_id: Int
  user_id: Int
  version: String
}

"""aggregate max on columns"""
type mez_admin_max_fields {
  notification_info_id: Int
  user_id: Int
  version: String
}

"""aggregate min on columns"""
type mez_admin_min_fields {
  notification_info_id: Int
  user_id: Int
  version: String
}

"""
response of any mutation on the table "mez_admin"
"""
type mez_admin_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mez_admin!]!
}

"""
on_conflict condition type for table "mez_admin"
"""
input mez_admin_on_conflict {
  constraint: mez_admin_constraint!
  update_columns: [mez_admin_update_column!]! = []
  where: mez_admin_bool_exp
}

"""Ordering options when selecting data from "mez_admin"."""
input mez_admin_order_by {
  notification_info: notification_info_order_by
  notification_info_id: order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: mez_admin"""
input mez_admin_pk_columns_input {
  user_id: Int!
}

"""
select columns of table "mez_admin"
"""
enum mez_admin_select_column {
  """column name"""
  notification_info_id

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "mez_admin"
"""
input mez_admin_set_input {
  notification_info_id: Int
  user_id: Int
  version: String
}

"""aggregate stddev on columns"""
type mez_admin_stddev_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type mez_admin_stddev_pop_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type mez_admin_stddev_samp_fields {
  notification_info_id: Float
  user_id: Float
}

"""
Streaming cursor of the table "mez_admin"
"""
input mez_admin_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mez_admin_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mez_admin_stream_cursor_value_input {
  notification_info_id: Int
  user_id: Int
  version: String
}

"""aggregate sum on columns"""
type mez_admin_sum_fields {
  notification_info_id: Int
  user_id: Int
}

"""
update columns of table "mez_admin"
"""
enum mez_admin_update_column {
  """column name"""
  notification_info_id

  """column name"""
  user_id

  """column name"""
  version
}

input mez_admin_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mez_admin_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mez_admin_set_input
  where: mez_admin_bool_exp!
}

"""aggregate var_pop on columns"""
type mez_admin_var_pop_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type mez_admin_var_samp_fields {
  notification_info_id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type mez_admin_variance_fields {
  notification_info_id: Float
  user_id: Float
}

scalar money

"""
Boolean expression to compare columns of type "money". All fields are combined with logical 'AND'.
"""
input money_comparison_exp {
  _eq: money
  _gt: money
  _gte: money
  _in: [money!]
  _is_null: Boolean
  _lt: money
  _lte: money
  _neq: money
  _nin: [money!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "chat"
  """
  delete_chat(
    """filter the rows which have to be deleted"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  delete single row from the table: "chat"
  """
  delete_chat_by_pk(id: Int!): chat

  """
  delete data from the table: "chat_participant"
  """
  delete_chat_participant(
    """filter the rows which have to be deleted"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  delete single row from the table: "chat_participant"
  """
  delete_chat_participant_by_pk(id: Int!): chat_participant

  """
  delete data from the table: "customer"
  """
  delete_customer(
    """filter the rows which have to be deleted"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  delete single row from the table: "customer"
  """
  delete_customer_by_pk(user_id: Int!): customer

  """
  delete data from the table: "deliverer"
  """
  delete_deliverer(
    """filter the rows which have to be deleted"""
    where: deliverer_bool_exp!
  ): deliverer_mutation_response

  """
  delete single row from the table: "deliverer"
  """
  delete_deliverer_by_pk(id: Int!): deliverer

  """
  delete data from the table: "delivery"
  """
  delete_delivery(
    """filter the rows which have to be deleted"""
    where: delivery_bool_exp!
  ): delivery_mutation_response

  """
  delete single row from the table: "delivery"
  """
  delete_delivery_by_pk(id: Int!): delivery

  """
  delete data from the table: "mez_admin"
  """
  delete_mez_admin(
    """filter the rows which have to be deleted"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  delete single row from the table: "mez_admin"
  """
  delete_mez_admin_by_pk(user_id: Int!): mez_admin

  """
  delete data from the table: "notification_info"
  """
  delete_notification_info(
    """filter the rows which have to be deleted"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  delete single row from the table: "notification_info"
  """
  delete_notification_info_by_pk(id: Int!): notification_info

  """
  delete data from the table: "restaurant"
  """
  delete_restaurant(
    """filter the rows which have to be deleted"""
    where: restaurant_bool_exp!
  ): restaurant_mutation_response

  """
  delete single row from the table: "restaurant"
  """
  delete_restaurant_by_pk(id: Int!): restaurant

  """
  delete data from the table: "restaurant_cart"
  """
  delete_restaurant_cart(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  delete single row from the table: "restaurant_cart"
  """
  delete_restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  delete data from the table: "restaurant_cart_item"
  """
  delete_restaurant_cart_item(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  delete single row from the table: "restaurant_cart_item"
  """
  delete_restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  delete data from the table: "restaurant_category"
  """
  delete_restaurant_category(
    """filter the rows which have to be deleted"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  delete single row from the table: "restaurant_category"
  """
  delete_restaurant_category_by_pk(id: Int!): restaurant_category

  """
  delete data from the table: "restaurant_choice"
  """
  delete_restaurant_choice(
    """filter the rows which have to be deleted"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  delete single row from the table: "restaurant_choice"
  """
  delete_restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  delete data from the table: "restaurant_item"
  """
  delete_restaurant_item(
    """filter the rows which have to be deleted"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  delete single row from the table: "restaurant_item"
  """
  delete_restaurant_item_by_pk(id: Int!): restaurant_item

  """
  delete data from the table: "restaurant_item_option_map"
  """
  delete_restaurant_item_option_map(
    """filter the rows which have to be deleted"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  delete single row from the table: "restaurant_item_option_map"
  """
  delete_restaurant_item_option_map_by_pk(item_id: Int!, option_id: Int!): restaurant_item_option_map

  """
  delete data from the table: "restaurant_operator"
  """
  delete_restaurant_operator(
    """filter the rows which have to be deleted"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  delete single row from the table: "restaurant_operator"
  """
  delete_restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  delete data from the table: "restaurant_option"
  """
  delete_restaurant_option(
    """filter the rows which have to be deleted"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  delete single row from the table: "restaurant_option"
  """
  delete_restaurant_option_by_pk(id: Int!): restaurant_option

  """
  delete data from the table: "restaurant_option_choice_map"
  """
  delete_restaurant_option_choice_map(
    """filter the rows which have to be deleted"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  delete single row from the table: "restaurant_option_choice_map"
  """
  delete_restaurant_option_choice_map_by_pk(choice_id: Int!, option_id: Int!): restaurant_option_choice_map

  """
  delete data from the table: "restaurant_order"
  """
  delete_restaurant_order(
    """filter the rows which have to be deleted"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  delete single row from the table: "restaurant_order"
  """
  delete_restaurant_order_by_pk(id: Int!): restaurant_order

  """
  delete data from the table: "restaurant_order_item"
  """
  delete_restaurant_order_item(
    """filter the rows which have to be deleted"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  delete single row from the table: "restaurant_order_item"
  """
  delete_restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  delete data from the table: "review"
  """
  delete_review(
    """filter the rows which have to be deleted"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  delete single row from the table: "review"
  """
  delete_review_by_pk(id: Int!): review

  """
  delete data from the table: "service_provider_payment_info"
  """
  delete_service_provider_payment_info(
    """filter the rows which have to be deleted"""
    where: service_provider_payment_info_bool_exp!
  ): service_provider_payment_info_mutation_response

  """
  delete single row from the table: "service_provider_payment_info"
  """
  delete_service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  delete data from the table: "stripe_info"
  """
  delete_stripe_info(
    """filter the rows which have to be deleted"""
    where: stripe_info_bool_exp!
  ): stripe_info_mutation_response

  """
  delete single row from the table: "stripe_info"
  """
  delete_stripe_info_by_pk(id: Int!): stripe_info

  """
  delete data from the table: "topology.app_type"
  """
  delete_topology_app_type(
    """filter the rows which have to be deleted"""
    where: topology_app_type_bool_exp!
  ): topology_app_type_mutation_response

  """
  delete single row from the table: "topology.app_type"
  """
  delete_topology_app_type_by_pk(id: String!): topology_app_type

  """
  delete data from the table: "topology.language"
  """
  delete_topology_language(
    """filter the rows which have to be deleted"""
    where: topology_language_bool_exp!
  ): topology_language_mutation_response

  """
  delete single row from the table: "topology.language"
  """
  delete_topology_language_by_pk(id: String!): topology_language

  """
  delete data from the table: "translation"
  """
  delete_translation(
    """filter the rows which have to be deleted"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  delete single row from the table: "translation"
  """
  delete_translation_by_pk(id: Int!): translation

  """
  delete data from the table: "translation_value"
  """
  delete_translation_value(
    """filter the rows which have to be deleted"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  delete single row from the table: "translation_value"
  """
  delete_translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: Int!): user

  """
  insert data into the table: "chat"
  """
  insert_chat(
    """the rows to be inserted"""
    objects: [chat_insert_input!]!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  """
  insert a single row into the table: "chat"
  """
  insert_chat_one(
    """the row to be inserted"""
    object: chat_insert_input!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat

  """
  insert data into the table: "chat_participant"
  """
  insert_chat_participant(
    """the rows to be inserted"""
    objects: [chat_participant_insert_input!]!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant_mutation_response

  """
  insert a single row into the table: "chat_participant"
  """
  insert_chat_participant_one(
    """the row to be inserted"""
    object: chat_participant_insert_input!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant

  """
  insert data into the table: "customer"
  """
  insert_customer(
    """the rows to be inserted"""
    objects: [customer_insert_input!]!

    """upsert condition"""
    on_conflict: customer_on_conflict
  ): customer_mutation_response

  """
  insert a single row into the table: "customer"
  """
  insert_customer_one(
    """the row to be inserted"""
    object: customer_insert_input!

    """upsert condition"""
    on_conflict: customer_on_conflict
  ): customer

  """
  insert data into the table: "deliverer"
  """
  insert_deliverer(
    """the rows to be inserted"""
    objects: [deliverer_insert_input!]!

    """upsert condition"""
    on_conflict: deliverer_on_conflict
  ): deliverer_mutation_response

  """
  insert a single row into the table: "deliverer"
  """
  insert_deliverer_one(
    """the row to be inserted"""
    object: deliverer_insert_input!

    """upsert condition"""
    on_conflict: deliverer_on_conflict
  ): deliverer

  """
  insert data into the table: "delivery"
  """
  insert_delivery(
    """the rows to be inserted"""
    objects: [delivery_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_on_conflict
  ): delivery_mutation_response

  """
  insert a single row into the table: "delivery"
  """
  insert_delivery_one(
    """the row to be inserted"""
    object: delivery_insert_input!

    """upsert condition"""
    on_conflict: delivery_on_conflict
  ): delivery

  """
  insert data into the table: "mez_admin"
  """
  insert_mez_admin(
    """the rows to be inserted"""
    objects: [mez_admin_insert_input!]!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin_mutation_response

  """
  insert a single row into the table: "mez_admin"
  """
  insert_mez_admin_one(
    """the row to be inserted"""
    object: mez_admin_insert_input!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin

  """
  insert data into the table: "notification_info"
  """
  insert_notification_info(
    """the rows to be inserted"""
    objects: [notification_info_insert_input!]!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info_mutation_response

  """
  insert a single row into the table: "notification_info"
  """
  insert_notification_info_one(
    """the row to be inserted"""
    object: notification_info_insert_input!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info

  """
  insert data into the table: "restaurant"
  """
  insert_restaurant(
    """the rows to be inserted"""
    objects: [restaurant_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_on_conflict
  ): restaurant_mutation_response

  """
  insert data into the table: "restaurant_cart"
  """
  insert_restaurant_cart(
    """the rows to be inserted"""
    objects: [restaurant_cart_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart_mutation_response

  """
  insert data into the table: "restaurant_cart_item"
  """
  insert_restaurant_cart_item(
    """the rows to be inserted"""
    objects: [restaurant_cart_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item_mutation_response

  """
  insert a single row into the table: "restaurant_cart_item"
  """
  insert_restaurant_cart_item_one(
    """the row to be inserted"""
    object: restaurant_cart_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item

  """
  insert a single row into the table: "restaurant_cart"
  """
  insert_restaurant_cart_one(
    """the row to be inserted"""
    object: restaurant_cart_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart

  """
  insert data into the table: "restaurant_category"
  """
  insert_restaurant_category(
    """the rows to be inserted"""
    objects: [restaurant_category_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category_mutation_response

  """
  insert a single row into the table: "restaurant_category"
  """
  insert_restaurant_category_one(
    """the row to be inserted"""
    object: restaurant_category_insert_input!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category

  """
  insert data into the table: "restaurant_choice"
  """
  insert_restaurant_choice(
    """the rows to be inserted"""
    objects: [restaurant_choice_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice_mutation_response

  """
  insert a single row into the table: "restaurant_choice"
  """
  insert_restaurant_choice_one(
    """the row to be inserted"""
    object: restaurant_choice_insert_input!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice

  """
  insert data into the table: "restaurant_item"
  """
  insert_restaurant_item(
    """the rows to be inserted"""
    objects: [restaurant_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item_mutation_response

  """
  insert a single row into the table: "restaurant_item"
  """
  insert_restaurant_item_one(
    """the row to be inserted"""
    object: restaurant_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item

  """
  insert data into the table: "restaurant_item_option_map"
  """
  insert_restaurant_item_option_map(
    """the rows to be inserted"""
    objects: [restaurant_item_option_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map_mutation_response

  """
  insert a single row into the table: "restaurant_item_option_map"
  """
  insert_restaurant_item_option_map_one(
    """the row to be inserted"""
    object: restaurant_item_option_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map

  """
  insert a single row into the table: "restaurant"
  """
  insert_restaurant_one(
    """the row to be inserted"""
    object: restaurant_insert_input!

    """upsert condition"""
    on_conflict: restaurant_on_conflict
  ): restaurant

  """
  insert data into the table: "restaurant_operator"
  """
  insert_restaurant_operator(
    """the rows to be inserted"""
    objects: [restaurant_operator_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator_mutation_response

  """
  insert a single row into the table: "restaurant_operator"
  """
  insert_restaurant_operator_one(
    """the row to be inserted"""
    object: restaurant_operator_insert_input!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator

  """
  insert data into the table: "restaurant_option"
  """
  insert_restaurant_option(
    """the rows to be inserted"""
    objects: [restaurant_option_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option_mutation_response

  """
  insert data into the table: "restaurant_option_choice_map"
  """
  insert_restaurant_option_choice_map(
    """the rows to be inserted"""
    objects: [restaurant_option_choice_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map_mutation_response

  """
  insert a single row into the table: "restaurant_option_choice_map"
  """
  insert_restaurant_option_choice_map_one(
    """the row to be inserted"""
    object: restaurant_option_choice_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map

  """
  insert a single row into the table: "restaurant_option"
  """
  insert_restaurant_option_one(
    """the row to be inserted"""
    object: restaurant_option_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option

  """
  insert data into the table: "restaurant_order"
  """
  insert_restaurant_order(
    """the rows to be inserted"""
    objects: [restaurant_order_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order_mutation_response

  """
  insert data into the table: "restaurant_order_item"
  """
  insert_restaurant_order_item(
    """the rows to be inserted"""
    objects: [restaurant_order_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item_mutation_response

  """
  insert a single row into the table: "restaurant_order_item"
  """
  insert_restaurant_order_item_one(
    """the row to be inserted"""
    object: restaurant_order_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item

  """
  insert a single row into the table: "restaurant_order"
  """
  insert_restaurant_order_one(
    """the row to be inserted"""
    object: restaurant_order_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order

  """
  insert data into the table: "review"
  """
  insert_review(
    """the rows to be inserted"""
    objects: [review_insert_input!]!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review_mutation_response

  """
  insert a single row into the table: "review"
  """
  insert_review_one(
    """the row to be inserted"""
    object: review_insert_input!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review

  """
  insert data into the table: "service_provider_payment_info"
  """
  insert_service_provider_payment_info(
    """the rows to be inserted"""
    objects: [service_provider_payment_info_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_payment_info_on_conflict
  ): service_provider_payment_info_mutation_response

  """
  insert a single row into the table: "service_provider_payment_info"
  """
  insert_service_provider_payment_info_one(
    """the row to be inserted"""
    object: service_provider_payment_info_insert_input!

    """upsert condition"""
    on_conflict: service_provider_payment_info_on_conflict
  ): service_provider_payment_info

  """
  insert data into the table: "stripe_info"
  """
  insert_stripe_info(
    """the rows to be inserted"""
    objects: [stripe_info_insert_input!]!

    """upsert condition"""
    on_conflict: stripe_info_on_conflict
  ): stripe_info_mutation_response

  """
  insert a single row into the table: "stripe_info"
  """
  insert_stripe_info_one(
    """the row to be inserted"""
    object: stripe_info_insert_input!

    """upsert condition"""
    on_conflict: stripe_info_on_conflict
  ): stripe_info

  """
  insert data into the table: "topology.app_type"
  """
  insert_topology_app_type(
    """the rows to be inserted"""
    objects: [topology_app_type_insert_input!]!

    """upsert condition"""
    on_conflict: topology_app_type_on_conflict
  ): topology_app_type_mutation_response

  """
  insert a single row into the table: "topology.app_type"
  """
  insert_topology_app_type_one(
    """the row to be inserted"""
    object: topology_app_type_insert_input!

    """upsert condition"""
    on_conflict: topology_app_type_on_conflict
  ): topology_app_type

  """
  insert data into the table: "topology.language"
  """
  insert_topology_language(
    """the rows to be inserted"""
    objects: [topology_language_insert_input!]!

    """upsert condition"""
    on_conflict: topology_language_on_conflict
  ): topology_language_mutation_response

  """
  insert a single row into the table: "topology.language"
  """
  insert_topology_language_one(
    """the row to be inserted"""
    object: topology_language_insert_input!

    """upsert condition"""
    on_conflict: topology_language_on_conflict
  ): topology_language

  """
  insert data into the table: "translation"
  """
  insert_translation(
    """the rows to be inserted"""
    objects: [translation_insert_input!]!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation_mutation_response

  """
  insert a single row into the table: "translation"
  """
  insert_translation_one(
    """the row to be inserted"""
    object: translation_insert_input!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation

  """
  insert data into the table: "translation_value"
  """
  insert_translation_value(
    """the rows to be inserted"""
    objects: [translation_value_insert_input!]!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value_mutation_response

  """
  insert a single row into the table: "translation_value"
  """
  insert_translation_value_one(
    """the row to be inserted"""
    object: translation_value_insert_input!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "chat"
  """
  update_chat(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input

    """filter the rows which have to be updated"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  update single row of the table: "chat"
  """
  update_chat_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input
    pk_columns: chat_pk_columns_input!
  ): chat

  """
  update multiples rows of table: "chat"
  """
  update_chat_many(
    """updates to execute, in order"""
    updates: [chat_updates!]!
  ): [chat_mutation_response]

  """
  update data of the table: "chat_participant"
  """
  update_chat_participant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input

    """filter the rows which have to be updated"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  update single row of the table: "chat_participant"
  """
  update_chat_participant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input
    pk_columns: chat_participant_pk_columns_input!
  ): chat_participant

  """
  update multiples rows of table: "chat_participant"
  """
  update_chat_participant_many(
    """updates to execute, in order"""
    updates: [chat_participant_updates!]!
  ): [chat_participant_mutation_response]

  """
  update data of the table: "customer"
  """
  update_customer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input

    """filter the rows which have to be updated"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  update single row of the table: "customer"
  """
  update_customer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input
    pk_columns: customer_pk_columns_input!
  ): customer

  """
  update multiples rows of table: "customer"
  """
  update_customer_many(
    """updates to execute, in order"""
    updates: [customer_updates!]!
  ): [customer_mutation_response]

  """
  update data of the table: "deliverer"
  """
  update_deliverer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: deliverer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: deliverer_set_input

    """filter the rows which have to be updated"""
    where: deliverer_bool_exp!
  ): deliverer_mutation_response

  """
  update single row of the table: "deliverer"
  """
  update_deliverer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: deliverer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: deliverer_set_input
    pk_columns: deliverer_pk_columns_input!
  ): deliverer

  """
  update multiples rows of table: "deliverer"
  """
  update_deliverer_many(
    """updates to execute, in order"""
    updates: [deliverer_updates!]!
  ): [deliverer_mutation_response]

  """
  update data of the table: "delivery"
  """
  update_delivery(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_set_input

    """filter the rows which have to be updated"""
    where: delivery_bool_exp!
  ): delivery_mutation_response

  """
  update single row of the table: "delivery"
  """
  update_delivery_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_set_input
    pk_columns: delivery_pk_columns_input!
  ): delivery

  """
  update multiples rows of table: "delivery"
  """
  update_delivery_many(
    """updates to execute, in order"""
    updates: [delivery_updates!]!
  ): [delivery_mutation_response]

  """
  update data of the table: "mez_admin"
  """
  update_mez_admin(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input

    """filter the rows which have to be updated"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  update single row of the table: "mez_admin"
  """
  update_mez_admin_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input
    pk_columns: mez_admin_pk_columns_input!
  ): mez_admin

  """
  update multiples rows of table: "mez_admin"
  """
  update_mez_admin_many(
    """updates to execute, in order"""
    updates: [mez_admin_updates!]!
  ): [mez_admin_mutation_response]

  """
  update data of the table: "notification_info"
  """
  update_notification_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input

    """filter the rows which have to be updated"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  update single row of the table: "notification_info"
  """
  update_notification_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input
    pk_columns: notification_info_pk_columns_input!
  ): notification_info

  """
  update multiples rows of table: "notification_info"
  """
  update_notification_info_many(
    """updates to execute, in order"""
    updates: [notification_info_updates!]!
  ): [notification_info_mutation_response]

  """
  update data of the table: "restaurant"
  """
  update_restaurant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_set_input

    """filter the rows which have to be updated"""
    where: restaurant_bool_exp!
  ): restaurant_mutation_response

  """
  update single row of the table: "restaurant"
  """
  update_restaurant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_set_input
    pk_columns: restaurant_pk_columns_input!
  ): restaurant

  """
  update data of the table: "restaurant_cart"
  """
  update_restaurant_cart(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  update single row of the table: "restaurant_cart"
  """
  update_restaurant_cart_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input
    pk_columns: restaurant_cart_pk_columns_input!
  ): restaurant_cart

  """
  update data of the table: "restaurant_cart_item"
  """
  update_restaurant_cart_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  update single row of the table: "restaurant_cart_item"
  """
  update_restaurant_cart_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input
    pk_columns: restaurant_cart_item_pk_columns_input!
  ): restaurant_cart_item

  """
  update multiples rows of table: "restaurant_cart_item"
  """
  update_restaurant_cart_item_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_item_updates!]!
  ): [restaurant_cart_item_mutation_response]

  """
  update multiples rows of table: "restaurant_cart"
  """
  update_restaurant_cart_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_updates!]!
  ): [restaurant_cart_mutation_response]

  """
  update data of the table: "restaurant_category"
  """
  update_restaurant_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input

    """filter the rows which have to be updated"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  update single row of the table: "restaurant_category"
  """
  update_restaurant_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input
    pk_columns: restaurant_category_pk_columns_input!
  ): restaurant_category

  """
  update multiples rows of table: "restaurant_category"
  """
  update_restaurant_category_many(
    """updates to execute, in order"""
    updates: [restaurant_category_updates!]!
  ): [restaurant_category_mutation_response]

  """
  update data of the table: "restaurant_choice"
  """
  update_restaurant_choice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input

    """filter the rows which have to be updated"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  update single row of the table: "restaurant_choice"
  """
  update_restaurant_choice_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input
    pk_columns: restaurant_choice_pk_columns_input!
  ): restaurant_choice

  """
  update multiples rows of table: "restaurant_choice"
  """
  update_restaurant_choice_many(
    """updates to execute, in order"""
    updates: [restaurant_choice_updates!]!
  ): [restaurant_choice_mutation_response]

  """
  update data of the table: "restaurant_item"
  """
  update_restaurant_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  update single row of the table: "restaurant_item"
  """
  update_restaurant_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input
    pk_columns: restaurant_item_pk_columns_input!
  ): restaurant_item

  """
  update multiples rows of table: "restaurant_item"
  """
  update_restaurant_item_many(
    """updates to execute, in order"""
    updates: [restaurant_item_updates!]!
  ): [restaurant_item_mutation_response]

  """
  update data of the table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  update single row of the table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input
    pk_columns: restaurant_item_option_map_pk_columns_input!
  ): restaurant_item_option_map

  """
  update multiples rows of table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map_many(
    """updates to execute, in order"""
    updates: [restaurant_item_option_map_updates!]!
  ): [restaurant_item_option_map_mutation_response]

  """
  update multiples rows of table: "restaurant"
  """
  update_restaurant_many(
    """updates to execute, in order"""
    updates: [restaurant_updates!]!
  ): [restaurant_mutation_response]

  """
  update data of the table: "restaurant_operator"
  """
  update_restaurant_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input

    """filter the rows which have to be updated"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  update single row of the table: "restaurant_operator"
  """
  update_restaurant_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input
    pk_columns: restaurant_operator_pk_columns_input!
  ): restaurant_operator

  """
  update multiples rows of table: "restaurant_operator"
  """
  update_restaurant_operator_many(
    """updates to execute, in order"""
    updates: [restaurant_operator_updates!]!
  ): [restaurant_operator_mutation_response]

  """
  update data of the table: "restaurant_option"
  """
  update_restaurant_option(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  update single row of the table: "restaurant_option"
  """
  update_restaurant_option_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input
    pk_columns: restaurant_option_pk_columns_input!
  ): restaurant_option

  """
  update data of the table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  update single row of the table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input
    pk_columns: restaurant_option_choice_map_pk_columns_input!
  ): restaurant_option_choice_map

  """
  update multiples rows of table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map_many(
    """updates to execute, in order"""
    updates: [restaurant_option_choice_map_updates!]!
  ): [restaurant_option_choice_map_mutation_response]

  """
  update multiples rows of table: "restaurant_option"
  """
  update_restaurant_option_many(
    """updates to execute, in order"""
    updates: [restaurant_option_updates!]!
  ): [restaurant_option_mutation_response]

  """
  update data of the table: "restaurant_order"
  """
  update_restaurant_order(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  update single row of the table: "restaurant_order"
  """
  update_restaurant_order_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input
    pk_columns: restaurant_order_pk_columns_input!
  ): restaurant_order

  """
  update data of the table: "restaurant_order_item"
  """
  update_restaurant_order_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  update single row of the table: "restaurant_order_item"
  """
  update_restaurant_order_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input
    pk_columns: restaurant_order_item_pk_columns_input!
  ): restaurant_order_item

  """
  update multiples rows of table: "restaurant_order_item"
  """
  update_restaurant_order_item_many(
    """updates to execute, in order"""
    updates: [restaurant_order_item_updates!]!
  ): [restaurant_order_item_mutation_response]

  """
  update multiples rows of table: "restaurant_order"
  """
  update_restaurant_order_many(
    """updates to execute, in order"""
    updates: [restaurant_order_updates!]!
  ): [restaurant_order_mutation_response]

  """
  update data of the table: "review"
  """
  update_review(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input

    """filter the rows which have to be updated"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  update single row of the table: "review"
  """
  update_review_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  """
  update multiples rows of table: "review"
  """
  update_review_many(
    """updates to execute, in order"""
    updates: [review_updates!]!
  ): [review_mutation_response]

  """
  update data of the table: "service_provider_payment_info"
  """
  update_service_provider_payment_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_payment_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_payment_info_set_input

    """filter the rows which have to be updated"""
    where: service_provider_payment_info_bool_exp!
  ): service_provider_payment_info_mutation_response

  """
  update single row of the table: "service_provider_payment_info"
  """
  update_service_provider_payment_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_payment_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_payment_info_set_input
    pk_columns: service_provider_payment_info_pk_columns_input!
  ): service_provider_payment_info

  """
  update multiples rows of table: "service_provider_payment_info"
  """
  update_service_provider_payment_info_many(
    """updates to execute, in order"""
    updates: [service_provider_payment_info_updates!]!
  ): [service_provider_payment_info_mutation_response]

  """
  update data of the table: "stripe_info"
  """
  update_stripe_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: stripe_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stripe_info_set_input

    """filter the rows which have to be updated"""
    where: stripe_info_bool_exp!
  ): stripe_info_mutation_response

  """
  update single row of the table: "stripe_info"
  """
  update_stripe_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: stripe_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stripe_info_set_input
    pk_columns: stripe_info_pk_columns_input!
  ): stripe_info

  """
  update multiples rows of table: "stripe_info"
  """
  update_stripe_info_many(
    """updates to execute, in order"""
    updates: [stripe_info_updates!]!
  ): [stripe_info_mutation_response]

  """
  update data of the table: "topology.app_type"
  """
  update_topology_app_type(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_app_type_set_input

    """filter the rows which have to be updated"""
    where: topology_app_type_bool_exp!
  ): topology_app_type_mutation_response

  """
  update single row of the table: "topology.app_type"
  """
  update_topology_app_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_app_type_set_input
    pk_columns: topology_app_type_pk_columns_input!
  ): topology_app_type

  """
  update multiples rows of table: "topology.app_type"
  """
  update_topology_app_type_many(
    """updates to execute, in order"""
    updates: [topology_app_type_updates!]!
  ): [topology_app_type_mutation_response]

  """
  update data of the table: "topology.language"
  """
  update_topology_language(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_language_set_input

    """filter the rows which have to be updated"""
    where: topology_language_bool_exp!
  ): topology_language_mutation_response

  """
  update single row of the table: "topology.language"
  """
  update_topology_language_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_language_set_input
    pk_columns: topology_language_pk_columns_input!
  ): topology_language

  """
  update multiples rows of table: "topology.language"
  """
  update_topology_language_many(
    """updates to execute, in order"""
    updates: [topology_language_updates!]!
  ): [topology_language_mutation_response]

  """
  update data of the table: "translation"
  """
  update_translation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input

    """filter the rows which have to be updated"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  update single row of the table: "translation"
  """
  update_translation_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input
    pk_columns: translation_pk_columns_input!
  ): translation

  """
  update multiples rows of table: "translation"
  """
  update_translation_many(
    """updates to execute, in order"""
    updates: [translation_updates!]!
  ): [translation_mutation_response]

  """
  update data of the table: "translation_value"
  """
  update_translation_value(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input

    """filter the rows which have to be updated"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  update single row of the table: "translation_value"
  """
  update_translation_value_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input
    pk_columns: translation_value_pk_columns_input!
  ): translation_value

  """
  update multiples rows of table: "translation_value"
  """
  update_translation_value_many(
    """updates to execute, in order"""
    updates: [translation_value_updates!]!
  ): [translation_value_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

"""
columns and relationships of "notification_info"
"""
type notification_info {
  app_type_id: String!
  id: Int!
  token: String!
  user_id: Int!
}

"""
aggregated selection of "notification_info"
"""
type notification_info_aggregate {
  aggregate: notification_info_aggregate_fields
  nodes: [notification_info!]!
}

"""
aggregate fields of "notification_info"
"""
type notification_info_aggregate_fields {
  avg: notification_info_avg_fields
  count(columns: [notification_info_select_column!], distinct: Boolean): Int!
  max: notification_info_max_fields
  min: notification_info_min_fields
  stddev: notification_info_stddev_fields
  stddev_pop: notification_info_stddev_pop_fields
  stddev_samp: notification_info_stddev_samp_fields
  sum: notification_info_sum_fields
  var_pop: notification_info_var_pop_fields
  var_samp: notification_info_var_samp_fields
  variance: notification_info_variance_fields
}

"""aggregate avg on columns"""
type notification_info_avg_fields {
  id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "notification_info". All fields are combined with a logical 'AND'.
"""
input notification_info_bool_exp {
  _and: [notification_info_bool_exp!]
  _not: notification_info_bool_exp
  _or: [notification_info_bool_exp!]
  app_type_id: String_comparison_exp
  id: Int_comparison_exp
  token: String_comparison_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "notification_info"
"""
enum notification_info_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_info_pkey
}

"""
input type for incrementing numeric columns in table "notification_info"
"""
input notification_info_inc_input {
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "notification_info"
"""
input notification_info_insert_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate max on columns"""
type notification_info_max_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate min on columns"""
type notification_info_min_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""
response of any mutation on the table "notification_info"
"""
type notification_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification_info!]!
}

"""
input type for inserting object relation for remote table "notification_info"
"""
input notification_info_obj_rel_insert_input {
  data: notification_info_insert_input!

  """upsert condition"""
  on_conflict: notification_info_on_conflict
}

"""
on_conflict condition type for table "notification_info"
"""
input notification_info_on_conflict {
  constraint: notification_info_constraint!
  update_columns: [notification_info_update_column!]! = []
  where: notification_info_bool_exp
}

"""Ordering options when selecting data from "notification_info"."""
input notification_info_order_by {
  app_type_id: order_by
  id: order_by
  token: order_by
  user_id: order_by
}

"""primary key columns input for table: notification_info"""
input notification_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "notification_info"
"""
enum notification_info_select_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  user_id
}

"""
input type for updating data in table "notification_info"
"""
input notification_info_set_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate stddev on columns"""
type notification_info_stddev_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type notification_info_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type notification_info_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
Streaming cursor of the table "notification_info"
"""
input notification_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_info_stream_cursor_value_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate sum on columns"""
type notification_info_sum_fields {
  id: Int
  user_id: Int
}

"""
update columns of table "notification_info"
"""
enum notification_info_update_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  user_id
}

input notification_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: notification_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: notification_info_set_input
  where: notification_info_bool_exp!
}

"""aggregate var_pop on columns"""
type notification_info_var_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type notification_info_var_samp_fields {
  id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type notification_info_variance_fields {
  id: Float
  user_id: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(user_id: Int!): customer

  """
  fetch data from the table: "deliverer"
  """
  deliverer(
    """distinct select on columns"""
    distinct_on: [deliverer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deliverer_order_by!]

    """filter the rows returned"""
    where: deliverer_bool_exp
  ): [deliverer!]!

  """
  fetch aggregated fields from the table: "deliverer"
  """
  deliverer_aggregate(
    """distinct select on columns"""
    distinct_on: [deliverer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deliverer_order_by!]

    """filter the rows returned"""
    where: deliverer_bool_exp
  ): deliverer_aggregate!

  """fetch data from the table: "deliverer" using primary key columns"""
  deliverer_by_pk(id: Int!): deliverer

  """
  fetch data from the table: "delivery"
  """
  delivery(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): [delivery!]!

  """
  fetch aggregated fields from the table: "delivery"
  """
  delivery_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): delivery_aggregate!

  """fetch data from the table: "delivery" using primary key columns"""
  delivery_by_pk(id: Int!): delivery

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table: "restaurant"
  """
  restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant"
  """
  restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): restaurant_aggregate!

  """fetch data from the table: "restaurant" using primary key columns"""
  restaurant_by_pk(id: Int!): restaurant

  """
  fetch data from the table: "restaurant_cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant_cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant_cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant_cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant_cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant_cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table: "restaurant_category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant_category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant_category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table: "restaurant_choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant_choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant_choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  fetch data from the table: "restaurant_item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant_item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant_item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant_item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(item_id: Int!, option_id: Int!): restaurant_item_option_map

  """
  fetch data from the table: "restaurant_operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant_operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant_operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table: "restaurant_option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant_option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant_option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant_option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(choice_id: Int!, option_id: Int!): restaurant_option_choice_map

  """
  fetch data from the table: "restaurant_order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant_order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant_order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant_order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant_order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant_order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table: "service_provider_payment_info"
  """
  service_provider_payment_info(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch aggregated fields from the table: "service_provider_payment_info"
  """
  service_provider_payment_info_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): service_provider_payment_info_aggregate!

  """
  fetch data from the table: "service_provider_payment_info" using primary key columns
  """
  service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  fetch data from the table: "stripe_info"
  """
  stripe_info(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch aggregated fields from the table: "stripe_info"
  """
  stripe_info_aggregate(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): stripe_info_aggregate!

  """fetch data from the table: "stripe_info" using primary key columns"""
  stripe_info_by_pk(id: Int!): stripe_info

  """
  fetch data from the table: "topology.app_type"
  """
  topology_app_type(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch aggregated fields from the table: "topology.app_type"
  """
  topology_app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): topology_app_type_aggregate!

  """
  fetch data from the table: "topology.app_type" using primary key columns
  """
  topology_app_type_by_pk(id: String!): topology_app_type

  """
  fetch data from the table: "topology.language"
  """
  topology_language(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch aggregated fields from the table: "topology.language"
  """
  topology_language_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): topology_language_aggregate!

  """
  fetch data from the table: "topology.language" using primary key columns
  """
  topology_language_by_pk(id: String!): topology_language

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user
}

"""
columns and relationships of "restaurant"
"""
type restaurant {
  approved: Boolean!

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """An object relationship"""
  description: translation
  description_id: Int
  firebase_id: String
  id: Int!
  image: String!
  language_id: String!
  location_gps: geography!
  location_text: String!
  name: String!

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String!

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """An aggregate relationship"""
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """An object relationship"""
  payment_info: service_provider_payment_info
  payment_info_id: Int

  """An array relationship"""
  restaurant_operators(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """An aggregate relationship"""
  restaurant_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!
  schedule_id: Int!
}

"""
aggregated selection of "restaurant"
"""
type restaurant_aggregate {
  aggregate: restaurant_aggregate_fields
  nodes: [restaurant!]!
}

"""
aggregate fields of "restaurant"
"""
type restaurant_aggregate_fields {
  avg: restaurant_avg_fields
  count(columns: [restaurant_select_column!], distinct: Boolean): Int!
  max: restaurant_max_fields
  min: restaurant_min_fields
  stddev: restaurant_stddev_fields
  stddev_pop: restaurant_stddev_pop_fields
  stddev_samp: restaurant_stddev_samp_fields
  sum: restaurant_sum_fields
  var_pop: restaurant_var_pop_fields
  var_samp: restaurant_var_samp_fields
  variance: restaurant_variance_fields
}

"""aggregate avg on columns"""
type restaurant_avg_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant". All fields are combined with a logical 'AND'.
"""
input restaurant_bool_exp {
  _and: [restaurant_bool_exp!]
  _not: restaurant_bool_exp
  _or: [restaurant_bool_exp!]
  approved: Boolean_comparison_exp
  categories: restaurant_category_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  location_gps: geography_comparison_exp
  location_text: String_comparison_exp
  name: String_comparison_exp
  open_status: String_comparison_exp
  orders: restaurant_order_bool_exp
  payment_info: service_provider_payment_info_bool_exp
  payment_info_id: Int_comparison_exp
  restaurant_operators: restaurant_operator_bool_exp
  schedule_id: Int_comparison_exp
}

"""
columns and relationships of "restaurant_cart"
"""
type restaurant_cart {
  """
  A computed field, executes function "cost"
  """
  cost: money

  """An object relationship"""
  customer: customer!
  customer_id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """An object relationship"""
  restaurant: restaurant
  restaurant_id: Int
}

"""
aggregated selection of "restaurant_cart"
"""
type restaurant_cart_aggregate {
  aggregate: restaurant_cart_aggregate_fields
  nodes: [restaurant_cart!]!
}

"""
aggregate fields of "restaurant_cart"
"""
type restaurant_cart_aggregate_fields {
  avg: restaurant_cart_avg_fields
  count(columns: [restaurant_cart_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_max_fields
  min: restaurant_cart_min_fields
  stddev: restaurant_cart_stddev_fields
  stddev_pop: restaurant_cart_stddev_pop_fields
  stddev_samp: restaurant_cart_stddev_samp_fields
  sum: restaurant_cart_sum_fields
  var_pop: restaurant_cart_var_pop_fields
  var_samp: restaurant_cart_var_samp_fields
  variance: restaurant_cart_variance_fields
}

"""aggregate avg on columns"""
type restaurant_cart_avg_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant_cart". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_bool_exp {
  _and: [restaurant_cart_bool_exp!]
  _not: restaurant_cart_bool_exp
  _or: [restaurant_cart_bool_exp!]
  cost: money_comparison_exp
  customer: customer_bool_exp
  customer_id: Int_comparison_exp
  items: restaurant_cart_item_bool_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_cart"
"""
enum restaurant_cart_constraint {
  """
  unique or primary key constraint on columns "customer_id"
  """
  restaurant_cart_pkey1
}

"""
input type for incrementing numeric columns in table "restaurant_cart"
"""
input restaurant_cart_inc_input {
  customer_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_cart"
"""
input restaurant_cart_insert_input {
  customer: customer_obj_rel_insert_input
  customer_id: Int
  items: restaurant_cart_item_arr_rel_insert_input
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""
columns and relationships of "restaurant_cart_item"
"""
type restaurant_cart_item {
  cost_per_one: money!
  customer_id: Int!
  id: Int!
  note: String
  quantity: Int!

  """An object relationship"""
  restaurant_cart: restaurant_cart!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!
  selected_options(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "restaurant_cart_item"
"""
type restaurant_cart_item_aggregate {
  aggregate: restaurant_cart_item_aggregate_fields
  nodes: [restaurant_cart_item!]!
}

"""
aggregate fields of "restaurant_cart_item"
"""
type restaurant_cart_item_aggregate_fields {
  avg: restaurant_cart_item_avg_fields
  count(columns: [restaurant_cart_item_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_item_max_fields
  min: restaurant_cart_item_min_fields
  stddev: restaurant_cart_item_stddev_fields
  stddev_pop: restaurant_cart_item_stddev_pop_fields
  stddev_samp: restaurant_cart_item_stddev_samp_fields
  sum: restaurant_cart_item_sum_fields
  var_pop: restaurant_cart_item_var_pop_fields
  var_samp: restaurant_cart_item_var_samp_fields
  variance: restaurant_cart_item_variance_fields
}

"""
order by aggregate values of table "restaurant_cart_item"
"""
input restaurant_cart_item_aggregate_order_by {
  avg: restaurant_cart_item_avg_order_by
  count: order_by
  max: restaurant_cart_item_max_order_by
  min: restaurant_cart_item_min_order_by
  stddev: restaurant_cart_item_stddev_order_by
  stddev_pop: restaurant_cart_item_stddev_pop_order_by
  stddev_samp: restaurant_cart_item_stddev_samp_order_by
  sum: restaurant_cart_item_sum_order_by
  var_pop: restaurant_cart_item_var_pop_order_by
  var_samp: restaurant_cart_item_var_samp_order_by
  variance: restaurant_cart_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_cart_item"
"""
input restaurant_cart_item_arr_rel_insert_input {
  data: [restaurant_cart_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_cart_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_cart_item_avg_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by avg() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_avg_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_cart_item". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_item_bool_exp {
  _and: [restaurant_cart_item_bool_exp!]
  _not: restaurant_cart_item_bool_exp
  _or: [restaurant_cart_item_bool_exp!]
  cost_per_one: money_comparison_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  quantity: Int_comparison_exp
  restaurant_cart: restaurant_cart_bool_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  selected_options: json_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_cart_item"
"""
enum restaurant_cart_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_cart_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_cart_item"
"""
input restaurant_cart_item_inc_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
input type for inserting data into table "restaurant_cart_item"
"""
input restaurant_cart_item_insert_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_cart: restaurant_cart_obj_rel_insert_input
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int
  selected_options: json
}

"""aggregate max on columns"""
type restaurant_cart_item_max_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by max() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_max_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate min on columns"""
type restaurant_cart_item_min_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by min() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_min_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
response of any mutation on the table "restaurant_cart_item"
"""
type restaurant_cart_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart_item!]!
}

"""
on_conflict condition type for table "restaurant_cart_item"
"""
input restaurant_cart_item_on_conflict {
  constraint: restaurant_cart_item_constraint!
  update_columns: [restaurant_cart_item_update_column!]! = []
  where: restaurant_cart_item_bool_exp
}

"""Ordering options when selecting data from "restaurant_cart_item"."""
input restaurant_cart_item_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_cart: restaurant_cart_order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  selected_options: order_by
}

"""primary key columns input for table: restaurant_cart_item"""
input restaurant_cart_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_cart_item"
"""
enum restaurant_cart_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

"""
input type for updating data in table "restaurant_cart_item"
"""
input restaurant_cart_item_set_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
  selected_options: json
}

"""aggregate stddev on columns"""
type restaurant_cart_item_stddev_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_item_stddev_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_item_stddev_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Streaming cursor of the table "restaurant_cart_item"
"""
input restaurant_cart_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_item_stream_cursor_value_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
  selected_options: json
}

"""aggregate sum on columns"""
type restaurant_cart_item_sum_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
order by sum() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_sum_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
update columns of table "restaurant_cart_item"
"""
enum restaurant_cart_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

input restaurant_cart_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_item_set_input
  where: restaurant_cart_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_item_var_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_pop() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_var_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_cart_item_var_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_samp() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_var_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate variance on columns"""
type restaurant_cart_item_variance_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by variance() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_variance_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate max on columns"""
type restaurant_cart_max_fields {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate min on columns"""
type restaurant_cart_min_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
response of any mutation on the table "restaurant_cart"
"""
type restaurant_cart_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart!]!
}

"""
input type for inserting object relation for remote table "restaurant_cart"
"""
input restaurant_cart_obj_rel_insert_input {
  data: restaurant_cart_insert_input!

  """upsert condition"""
  on_conflict: restaurant_cart_on_conflict
}

"""
on_conflict condition type for table "restaurant_cart"
"""
input restaurant_cart_on_conflict {
  constraint: restaurant_cart_constraint!
  update_columns: [restaurant_cart_update_column!]! = []
  where: restaurant_cart_bool_exp
}

"""Ordering options when selecting data from "restaurant_cart"."""
input restaurant_cart_order_by {
  cost: order_by
  customer: customer_order_by
  customer_id: order_by
  items_aggregate: restaurant_cart_item_aggregate_order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_cart"""
input restaurant_cart_pk_columns_input {
  customer_id: Int!
}

"""
select columns of table "restaurant_cart"
"""
enum restaurant_cart_select_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant_cart"
"""
input restaurant_cart_set_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_cart_stddev_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_stddev_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_stddev_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Streaming cursor of the table "restaurant_cart"
"""
input restaurant_cart_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_stream_cursor_value_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_cart_sum_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
update columns of table "restaurant_cart"
"""
enum restaurant_cart_update_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

input restaurant_cart_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_set_input
  where: restaurant_cart_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_var_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_cart_var_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate variance on columns"""
type restaurant_cart_variance_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
columns and relationships of "restaurant_category"
"""
type restaurant_category {
  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """An object relationship"""
  name: translation!
  name_id: Int!
  position: Int!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!
  schedule_id: Int
}

"""
aggregated selection of "restaurant_category"
"""
type restaurant_category_aggregate {
  aggregate: restaurant_category_aggregate_fields
  nodes: [restaurant_category!]!
}

"""
aggregate fields of "restaurant_category"
"""
type restaurant_category_aggregate_fields {
  avg: restaurant_category_avg_fields
  count(columns: [restaurant_category_select_column!], distinct: Boolean): Int!
  max: restaurant_category_max_fields
  min: restaurant_category_min_fields
  stddev: restaurant_category_stddev_fields
  stddev_pop: restaurant_category_stddev_pop_fields
  stddev_samp: restaurant_category_stddev_samp_fields
  sum: restaurant_category_sum_fields
  var_pop: restaurant_category_var_pop_fields
  var_samp: restaurant_category_var_samp_fields
  variance: restaurant_category_variance_fields
}

"""
order by aggregate values of table "restaurant_category"
"""
input restaurant_category_aggregate_order_by {
  avg: restaurant_category_avg_order_by
  count: order_by
  max: restaurant_category_max_order_by
  min: restaurant_category_min_order_by
  stddev: restaurant_category_stddev_order_by
  stddev_pop: restaurant_category_stddev_pop_order_by
  stddev_samp: restaurant_category_stddev_samp_order_by
  sum: restaurant_category_sum_order_by
  var_pop: restaurant_category_var_pop_order_by
  var_samp: restaurant_category_var_samp_order_by
  variance: restaurant_category_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_category"
"""
input restaurant_category_arr_rel_insert_input {
  data: [restaurant_category_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""aggregate avg on columns"""
type restaurant_category_avg_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by avg() on columns of table "restaurant_category"
"""
input restaurant_category_avg_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_category". All fields are combined with a logical 'AND'.
"""
input restaurant_category_bool_exp {
  _and: [restaurant_category_bool_exp!]
  _not: restaurant_category_bool_exp
  _or: [restaurant_category_bool_exp!]
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_bool_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  position: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  schedule_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_category"
"""
enum restaurant_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_category_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_category"
"""
input restaurant_category_inc_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
input type for inserting data into table "restaurant_category"
"""
input restaurant_category_insert_input {
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  items: restaurant_item_arr_rel_insert_input
  name: translation_obj_rel_insert_input
  name_id: Int
  position: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate max on columns"""
type restaurant_category_max_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by max() on columns of table "restaurant_category"
"""
input restaurant_category_max_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate min on columns"""
type restaurant_category_min_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by min() on columns of table "restaurant_category"
"""
input restaurant_category_min_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
response of any mutation on the table "restaurant_category"
"""
type restaurant_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_category!]!
}

"""
input type for inserting object relation for remote table "restaurant_category"
"""
input restaurant_category_obj_rel_insert_input {
  data: restaurant_category_insert_input!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""
on_conflict condition type for table "restaurant_category"
"""
input restaurant_category_on_conflict {
  constraint: restaurant_category_constraint!
  update_columns: [restaurant_category_update_column!]! = []
  where: restaurant_category_bool_exp
}

"""Ordering options when selecting data from "restaurant_category"."""
input restaurant_category_order_by {
  description: translation_order_by
  description_id: order_by
  id: order_by
  items_aggregate: restaurant_item_aggregate_order_by
  name: translation_order_by
  name_id: order_by
  position: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""primary key columns input for table: restaurant_category"""
input restaurant_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_category"
"""
enum restaurant_category_select_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

"""
input type for updating data in table "restaurant_category"
"""
input restaurant_category_set_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate stddev on columns"""
type restaurant_category_stddev_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_category_stddev_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_category_stddev_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Streaming cursor of the table "restaurant_category"
"""
input restaurant_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_category_stream_cursor_value_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate sum on columns"""
type restaurant_category_sum_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by sum() on columns of table "restaurant_category"
"""
input restaurant_category_sum_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
update columns of table "restaurant_category"
"""
enum restaurant_category_update_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

input restaurant_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_category_set_input
  where: restaurant_category_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_category_var_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_pop() on columns of table "restaurant_category"
"""
input restaurant_category_var_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_category_var_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_samp() on columns of table "restaurant_category"
"""
input restaurant_category_var_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate variance on columns"""
type restaurant_category_variance_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by variance() on columns of table "restaurant_category"
"""
input restaurant_category_variance_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
columns and relationships of "restaurant_choice"
"""
type restaurant_choice {
  available: Boolean!
  cost: money!
  id: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!
}

"""
aggregated selection of "restaurant_choice"
"""
type restaurant_choice_aggregate {
  aggregate: restaurant_choice_aggregate_fields
  nodes: [restaurant_choice!]!
}

"""
aggregate fields of "restaurant_choice"
"""
type restaurant_choice_aggregate_fields {
  avg: restaurant_choice_avg_fields
  count(columns: [restaurant_choice_select_column!], distinct: Boolean): Int!
  max: restaurant_choice_max_fields
  min: restaurant_choice_min_fields
  stddev: restaurant_choice_stddev_fields
  stddev_pop: restaurant_choice_stddev_pop_fields
  stddev_samp: restaurant_choice_stddev_samp_fields
  sum: restaurant_choice_sum_fields
  var_pop: restaurant_choice_var_pop_fields
  var_samp: restaurant_choice_var_samp_fields
  variance: restaurant_choice_variance_fields
}

"""
order by aggregate values of table "restaurant_choice"
"""
input restaurant_choice_aggregate_order_by {
  avg: restaurant_choice_avg_order_by
  count: order_by
  max: restaurant_choice_max_order_by
  min: restaurant_choice_min_order_by
  stddev: restaurant_choice_stddev_order_by
  stddev_pop: restaurant_choice_stddev_pop_order_by
  stddev_samp: restaurant_choice_stddev_samp_order_by
  sum: restaurant_choice_sum_order_by
  var_pop: restaurant_choice_var_pop_order_by
  var_samp: restaurant_choice_var_samp_order_by
  variance: restaurant_choice_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_choice"
"""
input restaurant_choice_arr_rel_insert_input {
  data: [restaurant_choice_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_choice_on_conflict
}

"""aggregate avg on columns"""
type restaurant_choice_avg_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by avg() on columns of table "restaurant_choice"
"""
input restaurant_choice_avg_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_choice". All fields are combined with a logical 'AND'.
"""
input restaurant_choice_bool_exp {
  _and: [restaurant_choice_bool_exp!]
  _not: restaurant_choice_bool_exp
  _or: [restaurant_choice_bool_exp!]
  available: Boolean_comparison_exp
  cost: money_comparison_exp
  id: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_option_choice_map_bool_exp
}

"""
unique or primary key constraints on table "restaurant_choice"
"""
enum restaurant_choice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_choice_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_choice"
"""
input restaurant_choice_inc_input {
  cost: money
  id: Int
  name_id: Int
}

"""
input type for inserting data into table "restaurant_choice"
"""
input restaurant_choice_insert_input {
  available: Boolean
  cost: money
  id: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_option_choice_map_arr_rel_insert_input
}

"""aggregate max on columns"""
type restaurant_choice_max_fields {
  cost: money
  id: Int
  name_id: Int
}

"""
order by max() on columns of table "restaurant_choice"
"""
input restaurant_choice_max_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""aggregate min on columns"""
type restaurant_choice_min_fields {
  cost: money
  id: Int
  name_id: Int
}

"""
order by min() on columns of table "restaurant_choice"
"""
input restaurant_choice_min_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""
response of any mutation on the table "restaurant_choice"
"""
type restaurant_choice_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_choice!]!
}

"""
on_conflict condition type for table "restaurant_choice"
"""
input restaurant_choice_on_conflict {
  constraint: restaurant_choice_constraint!
  update_columns: [restaurant_choice_update_column!]! = []
  where: restaurant_choice_bool_exp
}

"""Ordering options when selecting data from "restaurant_choice"."""
input restaurant_choice_order_by {
  available: order_by
  cost: order_by
  id: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_option_choice_map_aggregate_order_by
}

"""primary key columns input for table: restaurant_choice"""
input restaurant_choice_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_choice"
"""
enum restaurant_choice_select_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id
}

"""
input type for updating data in table "restaurant_choice"
"""
input restaurant_choice_set_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
}

"""aggregate stddev on columns"""
type restaurant_choice_stddev_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by stddev() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_choice_stddev_pop_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_choice_stddev_samp_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""
Streaming cursor of the table "restaurant_choice"
"""
input restaurant_choice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_choice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_choice_stream_cursor_value_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
}

"""aggregate sum on columns"""
type restaurant_choice_sum_fields {
  cost: money
  id: Int
  name_id: Int
}

"""
order by sum() on columns of table "restaurant_choice"
"""
input restaurant_choice_sum_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""
update columns of table "restaurant_choice"
"""
enum restaurant_choice_update_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id
}

input restaurant_choice_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_choice_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_choice_set_input
  where: restaurant_choice_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_choice_var_pop_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by var_pop() on columns of table "restaurant_choice"
"""
input restaurant_choice_var_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_choice_var_samp_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by var_samp() on columns of table "restaurant_choice"
"""
input restaurant_choice_var_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""aggregate variance on columns"""
type restaurant_choice_variance_fields {
  cost: Float
  id: Float
  name_id: Float
}

"""
order by variance() on columns of table "restaurant_choice"
"""
input restaurant_choice_variance_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
}

"""
unique or primary key constraints on table "restaurant"
"""
enum restaurant_constraint {
  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_firebase_id_key

  """
  unique or primary key constraint on columns "payment_info_id"
  """
  restaurant_payment_info_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_pkey
}

"""
input type for incrementing numeric columns in table "restaurant"
"""
input restaurant_inc_input {
  description_id: Int
  id: Int
  payment_info_id: Int
  schedule_id: Int
}

"""
input type for inserting data into table "restaurant"
"""
input restaurant_insert_input {
  approved: Boolean
  categories: restaurant_category_arr_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  orders: restaurant_order_arr_rel_insert_input
  payment_info: service_provider_payment_info_obj_rel_insert_input
  payment_info_id: Int
  restaurant_operators: restaurant_operator_arr_rel_insert_input
  schedule_id: Int
}

"""
columns and relationships of "restaurant_item"
"""
type restaurant_item {
  archived: Boolean!
  available: Boolean!

  """An object relationship"""
  category: restaurant_category
  category_id: Int
  cost: money!

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!

  """daily, special"""
  item_type: String!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  position: Int!
  restaurant_id: Int!
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
aggregated selection of "restaurant_item"
"""
type restaurant_item_aggregate {
  aggregate: restaurant_item_aggregate_fields
  nodes: [restaurant_item!]!
}

"""
aggregate fields of "restaurant_item"
"""
type restaurant_item_aggregate_fields {
  avg: restaurant_item_avg_fields
  count(columns: [restaurant_item_select_column!], distinct: Boolean): Int!
  max: restaurant_item_max_fields
  min: restaurant_item_min_fields
  stddev: restaurant_item_stddev_fields
  stddev_pop: restaurant_item_stddev_pop_fields
  stddev_samp: restaurant_item_stddev_samp_fields
  sum: restaurant_item_sum_fields
  var_pop: restaurant_item_var_pop_fields
  var_samp: restaurant_item_var_samp_fields
  variance: restaurant_item_variance_fields
}

"""
order by aggregate values of table "restaurant_item"
"""
input restaurant_item_aggregate_order_by {
  avg: restaurant_item_avg_order_by
  count: order_by
  max: restaurant_item_max_order_by
  min: restaurant_item_min_order_by
  stddev: restaurant_item_stddev_order_by
  stddev_pop: restaurant_item_stddev_pop_order_by
  stddev_samp: restaurant_item_stddev_samp_order_by
  sum: restaurant_item_sum_order_by
  var_pop: restaurant_item_var_pop_order_by
  var_samp: restaurant_item_var_samp_order_by
  variance: restaurant_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_item"
"""
input restaurant_item_arr_rel_insert_input {
  data: [restaurant_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_avg_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_item"
"""
input restaurant_item_avg_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_item". All fields are combined with a logical 'AND'.
"""
input restaurant_item_bool_exp {
  _and: [restaurant_item_bool_exp!]
  _not: restaurant_item_bool_exp
  _or: [restaurant_item_bool_exp!]
  archived: Boolean_comparison_exp
  available: Boolean_comparison_exp
  category: restaurant_category_bool_exp
  category_id: Int_comparison_exp
  cost: money_comparison_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  item_type: String_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_item_option_map_bool_exp
  position: Int_comparison_exp
  restaurant_id: Int_comparison_exp
  special_period_end: timestamptz_comparison_exp
  special_period_start: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_item"
"""
enum restaurant_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_item"
"""
input restaurant_item_inc_input {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_item"
"""
input restaurant_item_insert_input {
  archived: Boolean
  available: Boolean
  category: restaurant_category_obj_rel_insert_input
  category_id: Int
  cost: money
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int

  """daily, special"""
  item_type: String
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_item_option_map_arr_rel_insert_input
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate max on columns"""
type restaurant_item_max_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by max() on columns of table "restaurant_item"
"""
input restaurant_item_max_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""aggregate min on columns"""
type restaurant_item_min_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by min() on columns of table "restaurant_item"
"""
input restaurant_item_min_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""
response of any mutation on the table "restaurant_item"
"""
type restaurant_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item!]!
}

"""
input type for inserting object relation for remote table "restaurant_item"
"""
input restaurant_item_obj_rel_insert_input {
  data: restaurant_item_insert_input!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""
on_conflict condition type for table "restaurant_item"
"""
input restaurant_item_on_conflict {
  constraint: restaurant_item_constraint!
  update_columns: [restaurant_item_update_column!]! = []
  where: restaurant_item_bool_exp
}

"""
columns and relationships of "restaurant_item_option_map"
"""
type restaurant_item_option_map {
  item_id: Int!

  """An array relationship"""
  item_options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """An aggregate relationship"""
  item_options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!
  option_id: Int!
}

"""
aggregated selection of "restaurant_item_option_map"
"""
type restaurant_item_option_map_aggregate {
  aggregate: restaurant_item_option_map_aggregate_fields
  nodes: [restaurant_item_option_map!]!
}

"""
aggregate fields of "restaurant_item_option_map"
"""
type restaurant_item_option_map_aggregate_fields {
  avg: restaurant_item_option_map_avg_fields
  count(columns: [restaurant_item_option_map_select_column!], distinct: Boolean): Int!
  max: restaurant_item_option_map_max_fields
  min: restaurant_item_option_map_min_fields
  stddev: restaurant_item_option_map_stddev_fields
  stddev_pop: restaurant_item_option_map_stddev_pop_fields
  stddev_samp: restaurant_item_option_map_stddev_samp_fields
  sum: restaurant_item_option_map_sum_fields
  var_pop: restaurant_item_option_map_var_pop_fields
  var_samp: restaurant_item_option_map_var_samp_fields
  variance: restaurant_item_option_map_variance_fields
}

"""
order by aggregate values of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_aggregate_order_by {
  avg: restaurant_item_option_map_avg_order_by
  count: order_by
  max: restaurant_item_option_map_max_order_by
  min: restaurant_item_option_map_min_order_by
  stddev: restaurant_item_option_map_stddev_order_by
  stddev_pop: restaurant_item_option_map_stddev_pop_order_by
  stddev_samp: restaurant_item_option_map_stddev_samp_order_by
  sum: restaurant_item_option_map_sum_order_by
  var_pop: restaurant_item_option_map_var_pop_order_by
  var_samp: restaurant_item_option_map_var_samp_order_by
  variance: restaurant_item_option_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_item_option_map"
"""
input restaurant_item_option_map_arr_rel_insert_input {
  data: [restaurant_item_option_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_option_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_option_map_avg_fields {
  item_id: Float
  option_id: Float
}

"""
order by avg() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_avg_order_by {
  item_id: order_by
  option_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_item_option_map". All fields are combined with a logical 'AND'.
"""
input restaurant_item_option_map_bool_exp {
  _and: [restaurant_item_option_map_bool_exp!]
  _not: restaurant_item_option_map_bool_exp
  _or: [restaurant_item_option_map_bool_exp!]
  item_id: Int_comparison_exp
  item_options: restaurant_option_bool_exp
  option_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "item_id"
  """
  restaurant_item_option_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_item_option_map"
"""
input restaurant_item_option_map_inc_input {
  item_id: Int
  option_id: Int
}

"""
input type for inserting data into table "restaurant_item_option_map"
"""
input restaurant_item_option_map_insert_input {
  item_id: Int
  item_options: restaurant_option_arr_rel_insert_input
  option_id: Int
}

"""aggregate max on columns"""
type restaurant_item_option_map_max_fields {
  item_id: Int
  option_id: Int
}

"""
order by max() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_max_order_by {
  item_id: order_by
  option_id: order_by
}

"""aggregate min on columns"""
type restaurant_item_option_map_min_fields {
  item_id: Int
  option_id: Int
}

"""
order by min() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_min_order_by {
  item_id: order_by
  option_id: order_by
}

"""
response of any mutation on the table "restaurant_item_option_map"
"""
type restaurant_item_option_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item_option_map!]!
}

"""
on_conflict condition type for table "restaurant_item_option_map"
"""
input restaurant_item_option_map_on_conflict {
  constraint: restaurant_item_option_map_constraint!
  update_columns: [restaurant_item_option_map_update_column!]! = []
  where: restaurant_item_option_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant_item_option_map".
"""
input restaurant_item_option_map_order_by {
  item_id: order_by
  item_options_aggregate: restaurant_option_aggregate_order_by
  option_id: order_by
}

"""primary key columns input for table: restaurant_item_option_map"""
input restaurant_item_option_map_pk_columns_input {
  item_id: Int!
  option_id: Int!
}

"""
select columns of table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_select_column {
  """column name"""
  item_id

  """column name"""
  option_id
}

"""
input type for updating data in table "restaurant_item_option_map"
"""
input restaurant_item_option_map_set_input {
  item_id: Int
  option_id: Int
}

"""aggregate stddev on columns"""
type restaurant_item_option_map_stddev_fields {
  item_id: Float
  option_id: Float
}

"""
order by stddev() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_order_by {
  item_id: order_by
  option_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_option_map_stddev_pop_fields {
  item_id: Float
  option_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_pop_order_by {
  item_id: order_by
  option_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_option_map_stddev_samp_fields {
  item_id: Float
  option_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_samp_order_by {
  item_id: order_by
  option_id: order_by
}

"""
Streaming cursor of the table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_option_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_option_map_stream_cursor_value_input {
  item_id: Int
  option_id: Int
}

"""aggregate sum on columns"""
type restaurant_item_option_map_sum_fields {
  item_id: Int
  option_id: Int
}

"""
order by sum() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_sum_order_by {
  item_id: order_by
  option_id: order_by
}

"""
update columns of table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_update_column {
  """column name"""
  item_id

  """column name"""
  option_id
}

input restaurant_item_option_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_option_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_option_map_set_input
  where: restaurant_item_option_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_option_map_var_pop_fields {
  item_id: Float
  option_id: Float
}

"""
order by var_pop() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_var_pop_order_by {
  item_id: order_by
  option_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_option_map_var_samp_fields {
  item_id: Float
  option_id: Float
}

"""
order by var_samp() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_var_samp_order_by {
  item_id: order_by
  option_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_option_map_variance_fields {
  item_id: Float
  option_id: Float
}

"""
order by variance() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_variance_order_by {
  item_id: order_by
  option_id: order_by
}

"""Ordering options when selecting data from "restaurant_item"."""
input restaurant_item_order_by {
  archived: order_by
  available: order_by
  category: restaurant_category_order_by
  category_id: order_by
  cost: order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  item_type: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_item_option_map_aggregate_order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""primary key columns input for table: restaurant_item"""
input restaurant_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_item"
"""
enum restaurant_item_select_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

"""
input type for updating data in table "restaurant_item"
"""
input restaurant_item_set_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate stddev on columns"""
type restaurant_item_stddev_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_stddev_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_stddev_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_item"
"""
input restaurant_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_stream_cursor_value_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate sum on columns"""
type restaurant_item_sum_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_item"
"""
input restaurant_item_sum_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_item"
"""
enum restaurant_item_update_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

input restaurant_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_set_input
  where: restaurant_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_var_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_item"
"""
input restaurant_item_var_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_var_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_item"
"""
input restaurant_item_var_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_variance_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_item"
"""
input restaurant_item_variance_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate max on columns"""
type restaurant_max_fields {
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule_id: Int
}

"""aggregate min on columns"""
type restaurant_min_fields {
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule_id: Int
}

"""
response of any mutation on the table "restaurant"
"""
type restaurant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant!]!
}

"""
input type for inserting object relation for remote table "restaurant"
"""
input restaurant_obj_rel_insert_input {
  data: restaurant_insert_input!

  """upsert condition"""
  on_conflict: restaurant_on_conflict
}

"""
on_conflict condition type for table "restaurant"
"""
input restaurant_on_conflict {
  constraint: restaurant_constraint!
  update_columns: [restaurant_update_column!]! = []
  where: restaurant_bool_exp
}

"""
columns and relationships of "restaurant_operator"
"""
type restaurant_operator {
  app_version: String
  current_gps: geography
  id: Int!

  """An object relationship"""
  notification_info: notification_info!
  notification_info_id: Int!
  owner: Boolean!
  restaurant_id: Int!

  """awaiting_approval,authorized,banned"""
  status: String!
  user_id: Int!
}

"""
aggregated selection of "restaurant_operator"
"""
type restaurant_operator_aggregate {
  aggregate: restaurant_operator_aggregate_fields
  nodes: [restaurant_operator!]!
}

"""
aggregate fields of "restaurant_operator"
"""
type restaurant_operator_aggregate_fields {
  avg: restaurant_operator_avg_fields
  count(columns: [restaurant_operator_select_column!], distinct: Boolean): Int!
  max: restaurant_operator_max_fields
  min: restaurant_operator_min_fields
  stddev: restaurant_operator_stddev_fields
  stddev_pop: restaurant_operator_stddev_pop_fields
  stddev_samp: restaurant_operator_stddev_samp_fields
  sum: restaurant_operator_sum_fields
  var_pop: restaurant_operator_var_pop_fields
  var_samp: restaurant_operator_var_samp_fields
  variance: restaurant_operator_variance_fields
}

"""
order by aggregate values of table "restaurant_operator"
"""
input restaurant_operator_aggregate_order_by {
  avg: restaurant_operator_avg_order_by
  count: order_by
  max: restaurant_operator_max_order_by
  min: restaurant_operator_min_order_by
  stddev: restaurant_operator_stddev_order_by
  stddev_pop: restaurant_operator_stddev_pop_order_by
  stddev_samp: restaurant_operator_stddev_samp_order_by
  sum: restaurant_operator_sum_order_by
  var_pop: restaurant_operator_var_pop_order_by
  var_samp: restaurant_operator_var_samp_order_by
  variance: restaurant_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_operator"
"""
input restaurant_operator_arr_rel_insert_input {
  data: [restaurant_operator_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_operator_on_conflict
}

"""aggregate avg on columns"""
type restaurant_operator_avg_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "restaurant_operator"
"""
input restaurant_operator_avg_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_operator". All fields are combined with a logical 'AND'.
"""
input restaurant_operator_bool_exp {
  _and: [restaurant_operator_bool_exp!]
  _not: restaurant_operator_bool_exp
  _or: [restaurant_operator_bool_exp!]
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  notification_info_id: Int_comparison_exp
  owner: Boolean_comparison_exp
  restaurant_id: Int_comparison_exp
  status: String_comparison_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_operator"
"""
enum restaurant_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_operator_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_operator"
"""
input restaurant_operator_inc_input {
  id: Int
  notification_info_id: Int
  restaurant_id: Int
  user_id: Int
}

"""
input type for inserting data into table "restaurant_operator"
"""
input restaurant_operator_insert_input {
  app_version: String
  current_gps: geography
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  notification_info_id: Int
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate max on columns"""
type restaurant_operator_max_fields {
  app_version: String
  id: Int
  notification_info_id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by max() on columns of table "restaurant_operator"
"""
input restaurant_operator_max_order_by {
  app_version: order_by
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type restaurant_operator_min_fields {
  app_version: String
  id: Int
  notification_info_id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by min() on columns of table "restaurant_operator"
"""
input restaurant_operator_min_order_by {
  app_version: order_by
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "restaurant_operator"
"""
type restaurant_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_operator!]!
}

"""
on_conflict condition type for table "restaurant_operator"
"""
input restaurant_operator_on_conflict {
  constraint: restaurant_operator_constraint!
  update_columns: [restaurant_operator_update_column!]! = []
  where: restaurant_operator_bool_exp
}

"""Ordering options when selecting data from "restaurant_operator"."""
input restaurant_operator_order_by {
  app_version: order_by
  current_gps: order_by
  id: order_by
  notification_info: notification_info_order_by
  notification_info_id: order_by
  owner: order_by
  restaurant_id: order_by
  status: order_by
  user_id: order_by
}

"""primary key columns input for table: restaurant_operator"""
input restaurant_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_operator"
"""
enum restaurant_operator_select_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  id

  """column name"""
  notification_info_id

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "restaurant_operator"
"""
input restaurant_operator_set_input {
  app_version: String
  current_gps: geography
  id: Int
  notification_info_id: Int
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type restaurant_operator_stddev_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_operator_stddev_pop_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_pop_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_operator_stddev_samp_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_samp_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "restaurant_operator"
"""
input restaurant_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_operator_stream_cursor_value_input {
  app_version: String
  current_gps: geography
  id: Int
  notification_info_id: Int
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type restaurant_operator_sum_fields {
  id: Int
  notification_info_id: Int
  restaurant_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "restaurant_operator"
"""
input restaurant_operator_sum_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
update columns of table "restaurant_operator"
"""
enum restaurant_operator_update_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  id

  """column name"""
  notification_info_id

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

input restaurant_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_operator_set_input
  where: restaurant_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_operator_var_pop_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "restaurant_operator"
"""
input restaurant_operator_var_pop_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_operator_var_samp_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "restaurant_operator"
"""
input restaurant_operator_var_samp_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type restaurant_operator_variance_fields {
  id: Float
  notification_info_id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "restaurant_operator"
"""
input restaurant_operator_variance_order_by {
  id: order_by
  notification_info_id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
columns and relationships of "restaurant_option"
"""
type restaurant_option {
  """An array relationship"""
  choices(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!
  cost_per_extra: money!
  free_choice: Int!
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  maximum_choice: Int!
  minimum_choice: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!
  option_type: String!
  position: Int!
}

"""
aggregated selection of "restaurant_option"
"""
type restaurant_option_aggregate {
  aggregate: restaurant_option_aggregate_fields
  nodes: [restaurant_option!]!
}

"""
aggregate fields of "restaurant_option"
"""
type restaurant_option_aggregate_fields {
  avg: restaurant_option_avg_fields
  count(columns: [restaurant_option_select_column!], distinct: Boolean): Int!
  max: restaurant_option_max_fields
  min: restaurant_option_min_fields
  stddev: restaurant_option_stddev_fields
  stddev_pop: restaurant_option_stddev_pop_fields
  stddev_samp: restaurant_option_stddev_samp_fields
  sum: restaurant_option_sum_fields
  var_pop: restaurant_option_var_pop_fields
  var_samp: restaurant_option_var_samp_fields
  variance: restaurant_option_variance_fields
}

"""
order by aggregate values of table "restaurant_option"
"""
input restaurant_option_aggregate_order_by {
  avg: restaurant_option_avg_order_by
  count: order_by
  max: restaurant_option_max_order_by
  min: restaurant_option_min_order_by
  stddev: restaurant_option_stddev_order_by
  stddev_pop: restaurant_option_stddev_pop_order_by
  stddev_samp: restaurant_option_stddev_samp_order_by
  sum: restaurant_option_sum_order_by
  var_pop: restaurant_option_var_pop_order_by
  var_samp: restaurant_option_var_samp_order_by
  variance: restaurant_option_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_option"
"""
input restaurant_option_arr_rel_insert_input {
  data: [restaurant_option_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_avg_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by avg() on columns of table "restaurant_option"
"""
input restaurant_option_avg_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_option". All fields are combined with a logical 'AND'.
"""
input restaurant_option_bool_exp {
  _and: [restaurant_option_bool_exp!]
  _not: restaurant_option_bool_exp
  _or: [restaurant_option_bool_exp!]
  choices: restaurant_option_choice_map_bool_exp
  cost_per_extra: money_comparison_exp
  free_choice: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_option_map_bool_exp
  maximum_choice: Int_comparison_exp
  minimum_choice: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  option_type: String_comparison_exp
  position: Int_comparison_exp
}

"""
columns and relationships of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map {
  choice_id: Int!

  """An array relationship"""
  option_choices(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """An aggregate relationship"""
  option_choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!
  option_id: Int!
}

"""
aggregated selection of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_aggregate {
  aggregate: restaurant_option_choice_map_aggregate_fields
  nodes: [restaurant_option_choice_map!]!
}

"""
aggregate fields of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_aggregate_fields {
  avg: restaurant_option_choice_map_avg_fields
  count(columns: [restaurant_option_choice_map_select_column!], distinct: Boolean): Int!
  max: restaurant_option_choice_map_max_fields
  min: restaurant_option_choice_map_min_fields
  stddev: restaurant_option_choice_map_stddev_fields
  stddev_pop: restaurant_option_choice_map_stddev_pop_fields
  stddev_samp: restaurant_option_choice_map_stddev_samp_fields
  sum: restaurant_option_choice_map_sum_fields
  var_pop: restaurant_option_choice_map_var_pop_fields
  var_samp: restaurant_option_choice_map_var_samp_fields
  variance: restaurant_option_choice_map_variance_fields
}

"""
order by aggregate values of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_aggregate_order_by {
  avg: restaurant_option_choice_map_avg_order_by
  count: order_by
  max: restaurant_option_choice_map_max_order_by
  min: restaurant_option_choice_map_min_order_by
  stddev: restaurant_option_choice_map_stddev_order_by
  stddev_pop: restaurant_option_choice_map_stddev_pop_order_by
  stddev_samp: restaurant_option_choice_map_stddev_samp_order_by
  sum: restaurant_option_choice_map_sum_order_by
  var_pop: restaurant_option_choice_map_var_pop_order_by
  var_samp: restaurant_option_choice_map_var_samp_order_by
  variance: restaurant_option_choice_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_arr_rel_insert_input {
  data: [restaurant_option_choice_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_choice_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_choice_map_avg_fields {
  choice_id: Float
  option_id: Float
}

"""
order by avg() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_avg_order_by {
  choice_id: order_by
  option_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_option_choice_map".
All fields are combined with a logical 'AND'.
"""
input restaurant_option_choice_map_bool_exp {
  _and: [restaurant_option_choice_map_bool_exp!]
  _not: restaurant_option_choice_map_bool_exp
  _or: [restaurant_option_choice_map_bool_exp!]
  choice_id: Int_comparison_exp
  option_choices: restaurant_choice_bool_exp
  option_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "choice_id"
  """
  restaurant_option_choice_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_inc_input {
  choice_id: Int
  option_id: Int
}

"""
input type for inserting data into table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_insert_input {
  choice_id: Int
  option_choices: restaurant_choice_arr_rel_insert_input
  option_id: Int
}

"""aggregate max on columns"""
type restaurant_option_choice_map_max_fields {
  choice_id: Int
  option_id: Int
}

"""
order by max() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_max_order_by {
  choice_id: order_by
  option_id: order_by
}

"""aggregate min on columns"""
type restaurant_option_choice_map_min_fields {
  choice_id: Int
  option_id: Int
}

"""
order by min() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_min_order_by {
  choice_id: order_by
  option_id: order_by
}

"""
response of any mutation on the table "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option_choice_map!]!
}

"""
on_conflict condition type for table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_on_conflict {
  constraint: restaurant_option_choice_map_constraint!
  update_columns: [restaurant_option_choice_map_update_column!]! = []
  where: restaurant_option_choice_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant_option_choice_map".
"""
input restaurant_option_choice_map_order_by {
  choice_id: order_by
  option_choices_aggregate: restaurant_choice_aggregate_order_by
  option_id: order_by
}

"""primary key columns input for table: restaurant_option_choice_map"""
input restaurant_option_choice_map_pk_columns_input {
  choice_id: Int!
  option_id: Int!
}

"""
select columns of table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_select_column {
  """column name"""
  choice_id

  """column name"""
  option_id
}

"""
input type for updating data in table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_set_input {
  choice_id: Int
  option_id: Int
}

"""aggregate stddev on columns"""
type restaurant_option_choice_map_stddev_fields {
  choice_id: Float
  option_id: Float
}

"""
order by stddev() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_order_by {
  choice_id: order_by
  option_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_choice_map_stddev_pop_fields {
  choice_id: Float
  option_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_pop_order_by {
  choice_id: order_by
  option_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_choice_map_stddev_samp_fields {
  choice_id: Float
  option_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_samp_order_by {
  choice_id: order_by
  option_id: order_by
}

"""
Streaming cursor of the table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_choice_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_choice_map_stream_cursor_value_input {
  choice_id: Int
  option_id: Int
}

"""aggregate sum on columns"""
type restaurant_option_choice_map_sum_fields {
  choice_id: Int
  option_id: Int
}

"""
order by sum() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_sum_order_by {
  choice_id: order_by
  option_id: order_by
}

"""
update columns of table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_update_column {
  """column name"""
  choice_id

  """column name"""
  option_id
}

input restaurant_option_choice_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_choice_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_choice_map_set_input
  where: restaurant_option_choice_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_choice_map_var_pop_fields {
  choice_id: Float
  option_id: Float
}

"""
order by var_pop() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_var_pop_order_by {
  choice_id: order_by
  option_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_choice_map_var_samp_fields {
  choice_id: Float
  option_id: Float
}

"""
order by var_samp() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_var_samp_order_by {
  choice_id: order_by
  option_id: order_by
}

"""aggregate variance on columns"""
type restaurant_option_choice_map_variance_fields {
  choice_id: Float
  option_id: Float
}

"""
order by variance() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_variance_order_by {
  choice_id: order_by
  option_id: order_by
}

"""
unique or primary key constraints on table "restaurant_option"
"""
enum restaurant_option_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_option_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_option"
"""
input restaurant_option_inc_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
}

"""
input type for inserting data into table "restaurant_option"
"""
input restaurant_option_insert_input {
  choices: restaurant_option_choice_map_arr_rel_insert_input
  cost_per_extra: money
  free_choice: Int
  id: Int
  items: restaurant_item_option_map_arr_rel_insert_input
  maximum_choice: Int
  minimum_choice: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  option_type: String
  position: Int
}

"""aggregate max on columns"""
type restaurant_option_max_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
}

"""
order by max() on columns of table "restaurant_option"
"""
input restaurant_option_max_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
}

"""aggregate min on columns"""
type restaurant_option_min_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
}

"""
order by min() on columns of table "restaurant_option"
"""
input restaurant_option_min_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
}

"""
response of any mutation on the table "restaurant_option"
"""
type restaurant_option_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option!]!
}

"""
on_conflict condition type for table "restaurant_option"
"""
input restaurant_option_on_conflict {
  constraint: restaurant_option_constraint!
  update_columns: [restaurant_option_update_column!]! = []
  where: restaurant_option_bool_exp
}

"""Ordering options when selecting data from "restaurant_option"."""
input restaurant_option_order_by {
  choices_aggregate: restaurant_option_choice_map_aggregate_order_by
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  items_aggregate: restaurant_item_option_map_aggregate_order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name: translation_order_by
  name_id: order_by
  option_type: order_by
  position: order_by
}

"""primary key columns input for table: restaurant_option"""
input restaurant_option_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_option"
"""
enum restaurant_option_select_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position
}

"""
input type for updating data in table "restaurant_option"
"""
input restaurant_option_set_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
}

"""aggregate stddev on columns"""
type restaurant_option_stddev_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by stddev() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_stddev_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by stddev_pop() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_stddev_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by stddev_samp() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""
Streaming cursor of the table "restaurant_option"
"""
input restaurant_option_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_stream_cursor_value_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
}

"""aggregate sum on columns"""
type restaurant_option_sum_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
}

"""
order by sum() on columns of table "restaurant_option"
"""
input restaurant_option_sum_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""
update columns of table "restaurant_option"
"""
enum restaurant_option_update_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position
}

input restaurant_option_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_set_input
  where: restaurant_option_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_var_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by var_pop() on columns of table "restaurant_option"
"""
input restaurant_option_var_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_var_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by var_samp() on columns of table "restaurant_option"
"""
input restaurant_option_var_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""aggregate variance on columns"""
type restaurant_option_variance_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
}

"""
order by variance() on columns of table "restaurant_option"
"""
input restaurant_option_variance_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
}

"""
columns and relationships of "restaurant_order"
"""
type restaurant_order {
  actual_food_ready_time: timestamptz

  """An object relationship"""
  chat: chat!
  chat_id: Int!

  """An object relationship"""
  customer: customer!
  customer_app_type: String!
  customer_id: Int!

  """An object relationship"""
  delivery: delivery
  delivery_cost: money!
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  A computed field, executes function "itemscost"
  """
  items_cost: money
  notes: String
  order_time: timestamptz!
  order_type: String!
  payment_type: String!
  refund_amount: Int!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!

  """An object relationship"""
  review: review
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String!
  stripe_payment_id: Int
  tax: float8!
  to_location_address: String
  to_location_gps: geography

  """
  A computed field, executes function "totalcost"
  """
  total_cost: money
}

"""
aggregated selection of "restaurant_order"
"""
type restaurant_order_aggregate {
  aggregate: restaurant_order_aggregate_fields
  nodes: [restaurant_order!]!
}

"""
aggregate fields of "restaurant_order"
"""
type restaurant_order_aggregate_fields {
  avg: restaurant_order_avg_fields
  count(columns: [restaurant_order_select_column!], distinct: Boolean): Int!
  max: restaurant_order_max_fields
  min: restaurant_order_min_fields
  stddev: restaurant_order_stddev_fields
  stddev_pop: restaurant_order_stddev_pop_fields
  stddev_samp: restaurant_order_stddev_samp_fields
  sum: restaurant_order_sum_fields
  var_pop: restaurant_order_var_pop_fields
  var_samp: restaurant_order_var_samp_fields
  variance: restaurant_order_variance_fields
}

"""
order by aggregate values of table "restaurant_order"
"""
input restaurant_order_aggregate_order_by {
  avg: restaurant_order_avg_order_by
  count: order_by
  max: restaurant_order_max_order_by
  min: restaurant_order_min_order_by
  stddev: restaurant_order_stddev_order_by
  stddev_pop: restaurant_order_stddev_pop_order_by
  stddev_samp: restaurant_order_stddev_samp_order_by
  sum: restaurant_order_sum_order_by
  var_pop: restaurant_order_var_pop_order_by
  var_samp: restaurant_order_var_samp_order_by
  variance: restaurant_order_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_order"
"""
input restaurant_order_arr_rel_insert_input {
  data: [restaurant_order_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_avg_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by avg() on columns of table "restaurant_order"
"""
input restaurant_order_avg_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_order". All fields are combined with a logical 'AND'.
"""
input restaurant_order_bool_exp {
  _and: [restaurant_order_bool_exp!]
  _not: restaurant_order_bool_exp
  _or: [restaurant_order_bool_exp!]
  actual_food_ready_time: timestamptz_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  customer: customer_bool_exp
  customer_app_type: String_comparison_exp
  customer_id: Int_comparison_exp
  delivery: delivery_bool_exp
  delivery_cost: money_comparison_exp
  delivery_id: Int_comparison_exp
  estimated_food_ready_time: timestamptz_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  items: restaurant_order_item_bool_exp
  items_cost: money_comparison_exp
  notes: String_comparison_exp
  order_time: timestamptz_comparison_exp
  order_type: String_comparison_exp
  payment_type: String_comparison_exp
  refund_amount: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  review: review_bool_exp
  review_id: Int_comparison_exp
  status: String_comparison_exp
  stripe_payment_id: Int_comparison_exp
  tax: float8_comparison_exp
  to_location_address: String_comparison_exp
  to_location_gps: geography_comparison_exp
  total_cost: money_comparison_exp
}

"""Ordering options when selecting data from "restaurant"."""
input restaurant_order_by {
  approved: order_by
  categories_aggregate: restaurant_category_aggregate_order_by
  description: translation_order_by
  description_id: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  location_gps: order_by
  location_text: order_by
  name: order_by
  open_status: order_by
  orders_aggregate: restaurant_order_aggregate_order_by
  payment_info: service_provider_payment_info_order_by
  payment_info_id: order_by
  restaurant_operators_aggregate: restaurant_operator_aggregate_order_by
  schedule_id: order_by
}

"""
unique or primary key constraints on table "restaurant_order"
"""
enum restaurant_order_constraint {
  """
  unique or primary key constraint on columns "delivery_id"
  """
  restaurant_order_delivery_id_key

  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_order_firebase_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_order"
"""
input restaurant_order_inc_input {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: Int
  restaurant_id: Int
  review_id: Int
  stripe_payment_id: Int
  tax: float8
}

"""
input type for inserting data into table "restaurant_order"
"""
input restaurant_order_insert_input {
  actual_food_ready_time: timestamptz
  chat: chat_obj_rel_insert_input
  chat_id: Int
  customer: customer_obj_rel_insert_input
  customer_app_type: String
  customer_id: Int
  delivery: delivery_obj_rel_insert_input
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  items: restaurant_order_item_arr_rel_insert_input
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
  review: review_obj_rel_insert_input
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_payment_id: Int
  tax: float8
  to_location_address: String
  to_location_gps: geography
}

"""in_json:[name(en,es), selected_options]"""
type restaurant_order_item {
  cost_per_one: money!
  id: Int!
  in_json(
    """JSON select path"""
    path: String
  ): json!
  notes: String

  """An object relationship"""
  order: restaurant_order!
  quantity: Int!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!
  restaurant_order_id: Int!
  review_id: Int
  unavailable: Boolean!
}

"""
aggregated selection of "restaurant_order_item"
"""
type restaurant_order_item_aggregate {
  aggregate: restaurant_order_item_aggregate_fields
  nodes: [restaurant_order_item!]!
}

"""
aggregate fields of "restaurant_order_item"
"""
type restaurant_order_item_aggregate_fields {
  avg: restaurant_order_item_avg_fields
  count(columns: [restaurant_order_item_select_column!], distinct: Boolean): Int!
  max: restaurant_order_item_max_fields
  min: restaurant_order_item_min_fields
  stddev: restaurant_order_item_stddev_fields
  stddev_pop: restaurant_order_item_stddev_pop_fields
  stddev_samp: restaurant_order_item_stddev_samp_fields
  sum: restaurant_order_item_sum_fields
  var_pop: restaurant_order_item_var_pop_fields
  var_samp: restaurant_order_item_var_samp_fields
  variance: restaurant_order_item_variance_fields
}

"""
order by aggregate values of table "restaurant_order_item"
"""
input restaurant_order_item_aggregate_order_by {
  avg: restaurant_order_item_avg_order_by
  count: order_by
  max: restaurant_order_item_max_order_by
  min: restaurant_order_item_min_order_by
  stddev: restaurant_order_item_stddev_order_by
  stddev_pop: restaurant_order_item_stddev_pop_order_by
  stddev_samp: restaurant_order_item_stddev_samp_order_by
  sum: restaurant_order_item_sum_order_by
  var_pop: restaurant_order_item_var_pop_order_by
  var_samp: restaurant_order_item_var_samp_order_by
  variance: restaurant_order_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_order_item"
"""
input restaurant_order_item_arr_rel_insert_input {
  data: [restaurant_order_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_item_avg_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by avg() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_avg_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_order_item". All fields are combined with a logical 'AND'.
"""
input restaurant_order_item_bool_exp {
  _and: [restaurant_order_item_bool_exp!]
  _not: restaurant_order_item_bool_exp
  _or: [restaurant_order_item_bool_exp!]
  cost_per_one: money_comparison_exp
  id: Int_comparison_exp
  in_json: json_comparison_exp
  notes: String_comparison_exp
  order: restaurant_order_bool_exp
  quantity: Int_comparison_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  restaurant_order_id: Int_comparison_exp
  review_id: Int_comparison_exp
  unavailable: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_order_item"
"""
enum restaurant_order_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_order_item"
"""
input restaurant_order_item_inc_input {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
input type for inserting data into table "restaurant_order_item"
"""
input restaurant_order_item_insert_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  order: restaurant_order_obj_rel_insert_input
  quantity: Int
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate max on columns"""
type restaurant_order_item_max_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by max() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_max_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate min on columns"""
type restaurant_order_item_min_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by min() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_min_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
response of any mutation on the table "restaurant_order_item"
"""
type restaurant_order_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order_item!]!
}

"""
on_conflict condition type for table "restaurant_order_item"
"""
input restaurant_order_item_on_conflict {
  constraint: restaurant_order_item_constraint!
  update_columns: [restaurant_order_item_update_column!]! = []
  where: restaurant_order_item_bool_exp
}

"""Ordering options when selecting data from "restaurant_order_item"."""
input restaurant_order_item_order_by {
  cost_per_one: order_by
  id: order_by
  in_json: order_by
  notes: order_by
  order: restaurant_order_order_by
  quantity: order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
  unavailable: order_by
}

"""primary key columns input for table: restaurant_order_item"""
input restaurant_order_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_order_item"
"""
enum restaurant_order_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

"""
input type for updating data in table "restaurant_order_item"
"""
input restaurant_order_item_set_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate stddev on columns"""
type restaurant_order_item_stddev_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_item_stddev_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_item_stddev_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Streaming cursor of the table "restaurant_order_item"
"""
input restaurant_order_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_item_stream_cursor_value_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate sum on columns"""
type restaurant_order_item_sum_fields {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by sum() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_sum_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
update columns of table "restaurant_order_item"
"""
enum restaurant_order_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

input restaurant_order_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_item_set_input
  where: restaurant_order_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_item_var_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_pop() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_var_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_item_var_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_samp() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_var_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate variance on columns"""
type restaurant_order_item_variance_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by variance() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_variance_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate max on columns"""
type restaurant_order_max_fields {
  actual_food_ready_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: Int
  restaurant_id: Int
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_payment_id: Int
  tax: float8
  to_location_address: String
}

"""
order by max() on columns of table "restaurant_order"
"""
input restaurant_order_max_order_by {
  actual_food_ready_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_payment_id: order_by
  tax: order_by
  to_location_address: order_by
}

"""aggregate min on columns"""
type restaurant_order_min_fields {
  actual_food_ready_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: Int
  restaurant_id: Int
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_payment_id: Int
  tax: float8
  to_location_address: String
}

"""
order by min() on columns of table "restaurant_order"
"""
input restaurant_order_min_order_by {
  actual_food_ready_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_payment_id: order_by
  tax: order_by
  to_location_address: order_by
}

"""
response of any mutation on the table "restaurant_order"
"""
type restaurant_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order!]!
}

"""
input type for inserting object relation for remote table "restaurant_order"
"""
input restaurant_order_obj_rel_insert_input {
  data: restaurant_order_insert_input!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""
on_conflict condition type for table "restaurant_order"
"""
input restaurant_order_on_conflict {
  constraint: restaurant_order_constraint!
  update_columns: [restaurant_order_update_column!]! = []
  where: restaurant_order_bool_exp
}

"""Ordering options when selecting data from "restaurant_order"."""
input restaurant_order_order_by {
  actual_food_ready_time: order_by
  chat: chat_order_by
  chat_id: order_by
  customer: customer_order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery: delivery_order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  items_aggregate: restaurant_order_item_aggregate_order_by
  items_cost: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  review: review_order_by
  review_id: order_by
  status: order_by
  stripe_payment_id: order_by
  tax: order_by
  to_location_address: order_by
  to_location_gps: order_by
  total_cost: order_by
}

"""primary key columns input for table: restaurant_order"""
input restaurant_order_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_order"
"""
enum restaurant_order_select_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

"""
input type for updating data in table "restaurant_order"
"""
input restaurant_order_set_input {
  actual_food_ready_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: Int
  restaurant_id: Int
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_payment_id: Int
  tax: float8
  to_location_address: String
  to_location_gps: geography
}

"""aggregate stddev on columns"""
type restaurant_order_stddev_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by stddev() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_stddev_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by stddev_pop() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_stddev_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by stddev_samp() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""
Streaming cursor of the table "restaurant_order"
"""
input restaurant_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_stream_cursor_value_input {
  actual_food_ready_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: Int
  restaurant_id: Int
  review_id: Int

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_payment_id: Int
  tax: float8
  to_location_address: String
  to_location_gps: geography
}

"""aggregate sum on columns"""
type restaurant_order_sum_fields {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: Int
  restaurant_id: Int
  review_id: Int
  stripe_payment_id: Int
  tax: float8
}

"""
order by sum() on columns of table "restaurant_order"
"""
input restaurant_order_sum_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""
update columns of table "restaurant_order"
"""
enum restaurant_order_update_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

input restaurant_order_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_set_input
  where: restaurant_order_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_var_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by var_pop() on columns of table "restaurant_order"
"""
input restaurant_order_var_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_var_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by var_samp() on columns of table "restaurant_order"
"""
input restaurant_order_var_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""aggregate variance on columns"""
type restaurant_order_variance_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_payment_id: Float
  tax: Float
}

"""
order by variance() on columns of table "restaurant_order"
"""
input restaurant_order_variance_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_payment_id: order_by
  tax: order_by
}

"""primary key columns input for table: restaurant"""
input restaurant_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant"
"""
enum restaurant_select_column {
  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  payment_info_id

  """column name"""
  schedule_id
}

"""
input type for updating data in table "restaurant"
"""
input restaurant_set_input {
  approved: Boolean
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule_id: Int
}

"""aggregate stddev on columns"""
type restaurant_stddev_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_stddev_pop_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_stddev_samp_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""
Streaming cursor of the table "restaurant"
"""
input restaurant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_stream_cursor_value_input {
  approved: Boolean
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule_id: Int
}

"""aggregate sum on columns"""
type restaurant_sum_fields {
  description_id: Int
  id: Int
  payment_info_id: Int
  schedule_id: Int
}

"""
update columns of table "restaurant"
"""
enum restaurant_update_column {
  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  payment_info_id

  """column name"""
  schedule_id
}

input restaurant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_set_input
  where: restaurant_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_var_pop_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_var_samp_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""aggregate variance on columns"""
type restaurant_variance_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
  schedule_id: Float
}

"""
columns and relationships of "review"
"""
type review {
  from_entity_id: Int!
  from_entity_type: String!
  id: Int!
  note: String
  rating: Int!
  to_entity_id: Int!
  to_entity_type: String!
}

"""
aggregated selection of "review"
"""
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

"""
aggregate fields of "review"
"""
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int!
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

"""aggregate avg on columns"""
type review_avg_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
"""
input review_bool_exp {
  _and: [review_bool_exp!]
  _not: review_bool_exp
  _or: [review_bool_exp!]
  from_entity_id: Int_comparison_exp
  from_entity_type: String_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  rating: Int_comparison_exp
  to_entity_id: Int_comparison_exp
  to_entity_type: String_comparison_exp
}

"""
unique or primary key constraints on table "review"
"""
enum review_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  review_pkey
}

"""
input type for incrementing numeric columns in table "review"
"""
input review_inc_input {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
input type for inserting data into table "review"
"""
input review_insert_input {
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate max on columns"""
type review_max_fields {
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate min on columns"""
type review_min_fields {
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""
response of any mutation on the table "review"
"""
type review_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [review!]!
}

"""
input type for inserting object relation for remote table "review"
"""
input review_obj_rel_insert_input {
  data: review_insert_input!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""
on_conflict condition type for table "review"
"""
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]! = []
  where: review_bool_exp
}

"""Ordering options when selecting data from "review"."""
input review_order_by {
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""primary key columns input for table: review"""
input review_pk_columns_input {
  id: Int!
}

"""
select columns of table "review"
"""
enum review_select_column {
  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

"""
input type for updating data in table "review"
"""
input review_set_input {
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate stddev on columns"""
type review_stddev_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""aggregate stddev_pop on columns"""
type review_stddev_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""aggregate stddev_samp on columns"""
type review_stddev_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
Streaming cursor of the table "review"
"""
input review_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: review_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input review_stream_cursor_value_input {
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate sum on columns"""
type review_sum_fields {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
update columns of table "review"
"""
enum review_update_column {
  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

input review_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: review_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: review_set_input
  where: review_bool_exp!
}

"""aggregate var_pop on columns"""
type review_var_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""aggregate var_samp on columns"""
type review_var_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""aggregate variance on columns"""
type review_variance_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
columns and relationships of "service_provider_payment_info"
"""
type service_provider_payment_info {
  bank_transfer: Boolean!
  card: Boolean!
  cash: Boolean!
  id: Int!

  """An object relationship"""
  restaurant: restaurant
  service_provider_type: String!

  """An object relationship"""
  stripe_info: stripe_info
  stripe_info_id: Int
}

"""
aggregated selection of "service_provider_payment_info"
"""
type service_provider_payment_info_aggregate {
  aggregate: service_provider_payment_info_aggregate_fields
  nodes: [service_provider_payment_info!]!
}

"""
aggregate fields of "service_provider_payment_info"
"""
type service_provider_payment_info_aggregate_fields {
  avg: service_provider_payment_info_avg_fields
  count(columns: [service_provider_payment_info_select_column!], distinct: Boolean): Int!
  max: service_provider_payment_info_max_fields
  min: service_provider_payment_info_min_fields
  stddev: service_provider_payment_info_stddev_fields
  stddev_pop: service_provider_payment_info_stddev_pop_fields
  stddev_samp: service_provider_payment_info_stddev_samp_fields
  sum: service_provider_payment_info_sum_fields
  var_pop: service_provider_payment_info_var_pop_fields
  var_samp: service_provider_payment_info_var_samp_fields
  variance: service_provider_payment_info_variance_fields
}

"""aggregate avg on columns"""
type service_provider_payment_info_avg_fields {
  id: Float
  stripe_info_id: Float
}

"""
Boolean expression to filter rows from the table
"service_provider_payment_info". All fields are combined with a logical 'AND'.
"""
input service_provider_payment_info_bool_exp {
  _and: [service_provider_payment_info_bool_exp!]
  _not: service_provider_payment_info_bool_exp
  _or: [service_provider_payment_info_bool_exp!]
  bank_transfer: Boolean_comparison_exp
  card: Boolean_comparison_exp
  cash: Boolean_comparison_exp
  id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_type: String_comparison_exp
  stripe_info: stripe_info_bool_exp
  stripe_info_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "service_provider_payment_info"
"""
enum service_provider_payment_info_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_provider_payment_info_pkey

  """
  unique or primary key constraint on columns "stripe_info_id"
  """
  service_provider_payment_info_stripe_info_id_key
}

"""
input type for incrementing numeric columns in table "service_provider_payment_info"
"""
input service_provider_payment_info_inc_input {
  id: Int
  stripe_info_id: Int
}

"""
input type for inserting data into table "service_provider_payment_info"
"""
input service_provider_payment_info_insert_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  restaurant: restaurant_obj_rel_insert_input
  service_provider_type: String
  stripe_info: stripe_info_obj_rel_insert_input
  stripe_info_id: Int
}

"""aggregate max on columns"""
type service_provider_payment_info_max_fields {
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate min on columns"""
type service_provider_payment_info_min_fields {
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""
response of any mutation on the table "service_provider_payment_info"
"""
type service_provider_payment_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_payment_info!]!
}

"""
input type for inserting object relation for remote table "service_provider_payment_info"
"""
input service_provider_payment_info_obj_rel_insert_input {
  data: service_provider_payment_info_insert_input!

  """upsert condition"""
  on_conflict: service_provider_payment_info_on_conflict
}

"""
on_conflict condition type for table "service_provider_payment_info"
"""
input service_provider_payment_info_on_conflict {
  constraint: service_provider_payment_info_constraint!
  update_columns: [service_provider_payment_info_update_column!]! = []
  where: service_provider_payment_info_bool_exp
}

"""
Ordering options when selecting data from "service_provider_payment_info".
"""
input service_provider_payment_info_order_by {
  bank_transfer: order_by
  card: order_by
  cash: order_by
  id: order_by
  restaurant: restaurant_order_by
  service_provider_type: order_by
  stripe_info: stripe_info_order_by
  stripe_info_id: order_by
}

"""primary key columns input for table: service_provider_payment_info"""
input service_provider_payment_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider_payment_info"
"""
enum service_provider_payment_info_select_column {
  """column name"""
  bank_transfer

  """column name"""
  card

  """column name"""
  cash

  """column name"""
  id

  """column name"""
  service_provider_type

  """column name"""
  stripe_info_id
}

"""
input type for updating data in table "service_provider_payment_info"
"""
input service_provider_payment_info_set_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate stddev on columns"""
type service_provider_payment_info_stddev_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_payment_info_stddev_pop_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_payment_info_stddev_samp_fields {
  id: Float
  stripe_info_id: Float
}

"""
Streaming cursor of the table "service_provider_payment_info"
"""
input service_provider_payment_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_payment_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_payment_info_stream_cursor_value_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate sum on columns"""
type service_provider_payment_info_sum_fields {
  id: Int
  stripe_info_id: Int
}

"""
update columns of table "service_provider_payment_info"
"""
enum service_provider_payment_info_update_column {
  """column name"""
  bank_transfer

  """column name"""
  card

  """column name"""
  cash

  """column name"""
  id

  """column name"""
  service_provider_type

  """column name"""
  stripe_info_id
}

input service_provider_payment_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_payment_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_payment_info_set_input
  where: service_provider_payment_info_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_payment_info_var_pop_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_payment_info_var_samp_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate variance on columns"""
type service_provider_payment_info_variance_fields {
  id: Float
  stripe_info_id: Float
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "stripe_info"
"""
type stripe_info {
  charges_enabled: Boolean!
  details_submitted: Boolean!
  id: Int!
  pass_fees_to_customer: Boolean!
  payouts_enabled: Boolean!
  requirements(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  service_provider_payment_info: service_provider_payment_info
  stripe_id: String!
  stripe_status: String!
}

"""
aggregated selection of "stripe_info"
"""
type stripe_info_aggregate {
  aggregate: stripe_info_aggregate_fields
  nodes: [stripe_info!]!
}

"""
aggregate fields of "stripe_info"
"""
type stripe_info_aggregate_fields {
  avg: stripe_info_avg_fields
  count(columns: [stripe_info_select_column!], distinct: Boolean): Int!
  max: stripe_info_max_fields
  min: stripe_info_min_fields
  stddev: stripe_info_stddev_fields
  stddev_pop: stripe_info_stddev_pop_fields
  stddev_samp: stripe_info_stddev_samp_fields
  sum: stripe_info_sum_fields
  var_pop: stripe_info_var_pop_fields
  var_samp: stripe_info_var_samp_fields
  variance: stripe_info_variance_fields
}

"""aggregate avg on columns"""
type stripe_info_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "stripe_info". All fields are combined with a logical 'AND'.
"""
input stripe_info_bool_exp {
  _and: [stripe_info_bool_exp!]
  _not: stripe_info_bool_exp
  _or: [stripe_info_bool_exp!]
  charges_enabled: Boolean_comparison_exp
  details_submitted: Boolean_comparison_exp
  id: Int_comparison_exp
  pass_fees_to_customer: Boolean_comparison_exp
  payouts_enabled: Boolean_comparison_exp
  requirements: json_comparison_exp
  service_provider_payment_info: service_provider_payment_info_bool_exp
  stripe_id: String_comparison_exp
  stripe_status: String_comparison_exp
}

"""
unique or primary key constraints on table "stripe_info"
"""
enum stripe_info_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  stripe_info_pkey

  """
  unique or primary key constraint on columns "stripe_id"
  """
  stripe_info_stripe_id_key
}

"""
input type for incrementing numeric columns in table "stripe_info"
"""
input stripe_info_inc_input {
  id: Int
}

"""
input type for inserting data into table "stripe_info"
"""
input stripe_info_insert_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  service_provider_payment_info: service_provider_payment_info_obj_rel_insert_input
  stripe_id: String
  stripe_status: String
}

"""aggregate max on columns"""
type stripe_info_max_fields {
  id: Int
  stripe_id: String
  stripe_status: String
}

"""aggregate min on columns"""
type stripe_info_min_fields {
  id: Int
  stripe_id: String
  stripe_status: String
}

"""
response of any mutation on the table "stripe_info"
"""
type stripe_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [stripe_info!]!
}

"""
input type for inserting object relation for remote table "stripe_info"
"""
input stripe_info_obj_rel_insert_input {
  data: stripe_info_insert_input!

  """upsert condition"""
  on_conflict: stripe_info_on_conflict
}

"""
on_conflict condition type for table "stripe_info"
"""
input stripe_info_on_conflict {
  constraint: stripe_info_constraint!
  update_columns: [stripe_info_update_column!]! = []
  where: stripe_info_bool_exp
}

"""Ordering options when selecting data from "stripe_info"."""
input stripe_info_order_by {
  charges_enabled: order_by
  details_submitted: order_by
  id: order_by
  pass_fees_to_customer: order_by
  payouts_enabled: order_by
  requirements: order_by
  service_provider_payment_info: service_provider_payment_info_order_by
  stripe_id: order_by
  stripe_status: order_by
}

"""primary key columns input for table: stripe_info"""
input stripe_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "stripe_info"
"""
enum stripe_info_select_column {
  """column name"""
  charges_enabled

  """column name"""
  details_submitted

  """column name"""
  id

  """column name"""
  pass_fees_to_customer

  """column name"""
  payouts_enabled

  """column name"""
  requirements

  """column name"""
  stripe_id

  """column name"""
  stripe_status
}

"""
input type for updating data in table "stripe_info"
"""
input stripe_info_set_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  stripe_id: String
  stripe_status: String
}

"""aggregate stddev on columns"""
type stripe_info_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type stripe_info_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type stripe_info_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "stripe_info"
"""
input stripe_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: stripe_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input stripe_info_stream_cursor_value_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  stripe_id: String
  stripe_status: String
}

"""aggregate sum on columns"""
type stripe_info_sum_fields {
  id: Int
}

"""
update columns of table "stripe_info"
"""
enum stripe_info_update_column {
  """column name"""
  charges_enabled

  """column name"""
  details_submitted

  """column name"""
  id

  """column name"""
  pass_fees_to_customer

  """column name"""
  payouts_enabled

  """column name"""
  requirements

  """column name"""
  stripe_id

  """column name"""
  stripe_status
}

input stripe_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: stripe_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: stripe_info_set_input
  where: stripe_info_bool_exp!
}

"""aggregate var_pop on columns"""
type stripe_info_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type stripe_info_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type stripe_info_variance_fields {
  id: Float
}

type subscription_root {
  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table in a streaming manner : "chat_participant"
  """
  chat_participant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_participant_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch data from the table in a streaming manner : "chat"
  """
  chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(user_id: Int!): customer

  """
  fetch data from the table in a streaming manner : "customer"
  """
  customer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch data from the table: "deliverer"
  """
  deliverer(
    """distinct select on columns"""
    distinct_on: [deliverer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deliverer_order_by!]

    """filter the rows returned"""
    where: deliverer_bool_exp
  ): [deliverer!]!

  """
  fetch aggregated fields from the table: "deliverer"
  """
  deliverer_aggregate(
    """distinct select on columns"""
    distinct_on: [deliverer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deliverer_order_by!]

    """filter the rows returned"""
    where: deliverer_bool_exp
  ): deliverer_aggregate!

  """fetch data from the table: "deliverer" using primary key columns"""
  deliverer_by_pk(id: Int!): deliverer

  """
  fetch data from the table in a streaming manner : "deliverer"
  """
  deliverer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [deliverer_stream_cursor_input]!

    """filter the rows returned"""
    where: deliverer_bool_exp
  ): [deliverer!]!

  """
  fetch data from the table: "delivery"
  """
  delivery(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): [delivery!]!

  """
  fetch aggregated fields from the table: "delivery"
  """
  delivery_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_by!]

    """filter the rows returned"""
    where: delivery_bool_exp
  ): delivery_aggregate!

  """fetch data from the table: "delivery" using primary key columns"""
  delivery_by_pk(id: Int!): delivery

  """
  fetch data from the table in a streaming manner : "delivery"
  """
  delivery_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_bool_exp
  ): [delivery!]!

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table in a streaming manner : "mez_admin"
  """
  mez_admin_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mez_admin_stream_cursor_input]!

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table in a streaming manner : "notification_info"
  """
  notification_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_info_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch data from the table: "restaurant"
  """
  restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant"
  """
  restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): restaurant_aggregate!

  """fetch data from the table: "restaurant" using primary key columns"""
  restaurant_by_pk(id: Int!): restaurant

  """
  fetch data from the table: "restaurant_cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant_cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant_cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant_cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant_cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant_cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table in a streaming manner : "restaurant_cart_item"
  """
  restaurant_cart_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch data from the table in a streaming manner : "restaurant_cart"
  """
  restaurant_cart_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch data from the table: "restaurant_category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant_category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant_category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table in a streaming manner : "restaurant_category"
  """
  restaurant_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_category_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch data from the table: "restaurant_choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant_choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant_choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  fetch data from the table in a streaming manner : "restaurant_choice"
  """
  restaurant_choice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_choice_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch data from the table: "restaurant_item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant_item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant_item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant_item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(item_id: Int!, option_id: Int!): restaurant_item_option_map

  """
  fetch data from the table in a streaming manner : "restaurant_item_option_map"
  """
  restaurant_item_option_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_option_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch data from the table in a streaming manner : "restaurant_item"
  """
  restaurant_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch data from the table: "restaurant_operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant_operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant_operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table in a streaming manner : "restaurant_operator"
  """
  restaurant_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch data from the table: "restaurant_option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant_option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant_option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant_option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(choice_id: Int!, option_id: Int!): restaurant_option_choice_map

  """
  fetch data from the table in a streaming manner : "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_choice_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch data from the table in a streaming manner : "restaurant_option"
  """
  restaurant_option_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch data from the table: "restaurant_order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant_order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant_order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant_order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant_order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant_order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table in a streaming manner : "restaurant_order_item"
  """
  restaurant_order_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch data from the table in a streaming manner : "restaurant_order"
  """
  restaurant_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch data from the table in a streaming manner : "restaurant"
  """
  restaurant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table in a streaming manner : "review"
  """
  review_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [review_stream_cursor_input]!

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch data from the table: "service_provider_payment_info"
  """
  service_provider_payment_info(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch aggregated fields from the table: "service_provider_payment_info"
  """
  service_provider_payment_info_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): service_provider_payment_info_aggregate!

  """
  fetch data from the table: "service_provider_payment_info" using primary key columns
  """
  service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  fetch data from the table in a streaming manner : "service_provider_payment_info"
  """
  service_provider_payment_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_payment_info_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch data from the table: "stripe_info"
  """
  stripe_info(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch aggregated fields from the table: "stripe_info"
  """
  stripe_info_aggregate(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): stripe_info_aggregate!

  """fetch data from the table: "stripe_info" using primary key columns"""
  stripe_info_by_pk(id: Int!): stripe_info

  """
  fetch data from the table in a streaming manner : "stripe_info"
  """
  stripe_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [stripe_info_stream_cursor_input]!

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch data from the table: "topology.app_type"
  """
  topology_app_type(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch aggregated fields from the table: "topology.app_type"
  """
  topology_app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): topology_app_type_aggregate!

  """
  fetch data from the table: "topology.app_type" using primary key columns
  """
  topology_app_type_by_pk(id: String!): topology_app_type

  """
  fetch data from the table in a streaming manner : "topology.app_type"
  """
  topology_app_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_app_type_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch data from the table: "topology.language"
  """
  topology_language(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch aggregated fields from the table: "topology.language"
  """
  topology_language_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): topology_language_aggregate!

  """
  fetch data from the table: "topology.language" using primary key columns
  """
  topology_language_by_pk(id: String!): topology_language

  """
  fetch data from the table in a streaming manner : "topology.language"
  """
  topology_language_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_language_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table in a streaming manner : "translation"
  """
  translation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table in a streaming manner : "translation_value"
  """
  translation_value_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_value_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user

  """
  fetch data from the table in a streaming manner : "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topology.app_type"
"""
type topology_app_type {
  id: String!
}

"""
aggregated selection of "topology.app_type"
"""
type topology_app_type_aggregate {
  aggregate: topology_app_type_aggregate_fields
  nodes: [topology_app_type!]!
}

"""
aggregate fields of "topology.app_type"
"""
type topology_app_type_aggregate_fields {
  count(columns: [topology_app_type_select_column!], distinct: Boolean): Int!
  max: topology_app_type_max_fields
  min: topology_app_type_min_fields
}

"""
Boolean expression to filter rows from the table "topology.app_type". All fields are combined with a logical 'AND'.
"""
input topology_app_type_bool_exp {
  _and: [topology_app_type_bool_exp!]
  _not: topology_app_type_bool_exp
  _or: [topology_app_type_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "topology.app_type"
"""
enum topology_app_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_type_pkey
}

"""
input type for inserting data into table "topology.app_type"
"""
input topology_app_type_insert_input {
  id: String
}

"""aggregate max on columns"""
type topology_app_type_max_fields {
  id: String
}

"""aggregate min on columns"""
type topology_app_type_min_fields {
  id: String
}

"""
response of any mutation on the table "topology.app_type"
"""
type topology_app_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_app_type!]!
}

"""
on_conflict condition type for table "topology.app_type"
"""
input topology_app_type_on_conflict {
  constraint: topology_app_type_constraint!
  update_columns: [topology_app_type_update_column!]! = []
  where: topology_app_type_bool_exp
}

"""Ordering options when selecting data from "topology.app_type"."""
input topology_app_type_order_by {
  id: order_by
}

"""primary key columns input for table: topology_app_type"""
input topology_app_type_pk_columns_input {
  id: String!
}

"""
select columns of table "topology.app_type"
"""
enum topology_app_type_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "topology.app_type"
"""
input topology_app_type_set_input {
  id: String
}

"""
Streaming cursor of the table "topology_app_type"
"""
input topology_app_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_app_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_app_type_stream_cursor_value_input {
  id: String
}

"""
update columns of table "topology.app_type"
"""
enum topology_app_type_update_column {
  """column name"""
  id
}

input topology_app_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: topology_app_type_set_input
  where: topology_app_type_bool_exp!
}

"""
columns and relationships of "topology.language"
"""
type topology_language {
  id: String!
}

"""
aggregated selection of "topology.language"
"""
type topology_language_aggregate {
  aggregate: topology_language_aggregate_fields
  nodes: [topology_language!]!
}

"""
aggregate fields of "topology.language"
"""
type topology_language_aggregate_fields {
  count(columns: [topology_language_select_column!], distinct: Boolean): Int!
  max: topology_language_max_fields
  min: topology_language_min_fields
}

"""
Boolean expression to filter rows from the table "topology.language". All fields are combined with a logical 'AND'.
"""
input topology_language_bool_exp {
  _and: [topology_language_bool_exp!]
  _not: topology_language_bool_exp
  _or: [topology_language_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "topology.language"
"""
enum topology_language_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  language_pkey
}

"""
input type for inserting data into table "topology.language"
"""
input topology_language_insert_input {
  id: String
}

"""aggregate max on columns"""
type topology_language_max_fields {
  id: String
}

"""aggregate min on columns"""
type topology_language_min_fields {
  id: String
}

"""
response of any mutation on the table "topology.language"
"""
type topology_language_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_language!]!
}

"""
input type for inserting object relation for remote table "topology.language"
"""
input topology_language_obj_rel_insert_input {
  data: topology_language_insert_input!

  """upsert condition"""
  on_conflict: topology_language_on_conflict
}

"""
on_conflict condition type for table "topology.language"
"""
input topology_language_on_conflict {
  constraint: topology_language_constraint!
  update_columns: [topology_language_update_column!]! = []
  where: topology_language_bool_exp
}

"""Ordering options when selecting data from "topology.language"."""
input topology_language_order_by {
  id: order_by
}

"""primary key columns input for table: topology_language"""
input topology_language_pk_columns_input {
  id: String!
}

"""
select columns of table "topology.language"
"""
enum topology_language_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "topology.language"
"""
input topology_language_set_input {
  id: String
}

"""
Streaming cursor of the table "topology_language"
"""
input topology_language_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_language_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_language_stream_cursor_value_input {
  id: String
}

"""
update columns of table "topology.language"
"""
enum topology_language_update_column {
  """column name"""
  id
}

input topology_language_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: topology_language_set_input
  where: topology_language_bool_exp!
}

"""
columns and relationships of "translation"
"""
type translation {
  id: Int!
  shared: Boolean!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!
}

"""
aggregated selection of "translation"
"""
type translation_aggregate {
  aggregate: translation_aggregate_fields
  nodes: [translation!]!
}

"""
aggregate fields of "translation"
"""
type translation_aggregate_fields {
  avg: translation_avg_fields
  count(columns: [translation_select_column!], distinct: Boolean): Int!
  max: translation_max_fields
  min: translation_min_fields
  stddev: translation_stddev_fields
  stddev_pop: translation_stddev_pop_fields
  stddev_samp: translation_stddev_samp_fields
  sum: translation_sum_fields
  var_pop: translation_var_pop_fields
  var_samp: translation_var_samp_fields
  variance: translation_variance_fields
}

"""aggregate avg on columns"""
type translation_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "translation". All fields are combined with a logical 'AND'.
"""
input translation_bool_exp {
  _and: [translation_bool_exp!]
  _not: translation_bool_exp
  _or: [translation_bool_exp!]
  id: Int_comparison_exp
  shared: Boolean_comparison_exp
  translations: translation_value_bool_exp
}

"""
unique or primary key constraints on table "translation"
"""
enum translation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translation_pkey
}

"""
input type for incrementing numeric columns in table "translation"
"""
input translation_inc_input {
  id: Int
}

"""
input type for inserting data into table "translation"
"""
input translation_insert_input {
  id: Int
  shared: Boolean
  translations: translation_value_arr_rel_insert_input
}

"""aggregate max on columns"""
type translation_max_fields {
  id: Int
}

"""aggregate min on columns"""
type translation_min_fields {
  id: Int
}

"""
response of any mutation on the table "translation"
"""
type translation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation!]!
}

"""
input type for inserting object relation for remote table "translation"
"""
input translation_obj_rel_insert_input {
  data: translation_insert_input!

  """upsert condition"""
  on_conflict: translation_on_conflict
}

"""
on_conflict condition type for table "translation"
"""
input translation_on_conflict {
  constraint: translation_constraint!
  update_columns: [translation_update_column!]! = []
  where: translation_bool_exp
}

"""Ordering options when selecting data from "translation"."""
input translation_order_by {
  id: order_by
  shared: order_by
  translations_aggregate: translation_value_aggregate_order_by
}

"""primary key columns input for table: translation"""
input translation_pk_columns_input {
  id: Int!
}

"""
select columns of table "translation"
"""
enum translation_select_column {
  """column name"""
  id

  """column name"""
  shared
}

"""
input type for updating data in table "translation"
"""
input translation_set_input {
  id: Int
  shared: Boolean
}

"""aggregate stddev on columns"""
type translation_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type translation_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type translation_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "translation"
"""
input translation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_stream_cursor_value_input {
  id: Int
  shared: Boolean
}

"""aggregate sum on columns"""
type translation_sum_fields {
  id: Int
}

"""
update columns of table "translation"
"""
enum translation_update_column {
  """column name"""
  id

  """column name"""
  shared
}

input translation_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_set_input
  where: translation_bool_exp!
}

"""
columns and relationships of "translation_value"
"""
type translation_value {
  """An object relationship"""
  language: topology_language!
  language_id: String!

  """An object relationship"""
  translation_group: translation!
  translation_id: Int!
  value: String!
}

"""
aggregated selection of "translation_value"
"""
type translation_value_aggregate {
  aggregate: translation_value_aggregate_fields
  nodes: [translation_value!]!
}

"""
aggregate fields of "translation_value"
"""
type translation_value_aggregate_fields {
  avg: translation_value_avg_fields
  count(columns: [translation_value_select_column!], distinct: Boolean): Int!
  max: translation_value_max_fields
  min: translation_value_min_fields
  stddev: translation_value_stddev_fields
  stddev_pop: translation_value_stddev_pop_fields
  stddev_samp: translation_value_stddev_samp_fields
  sum: translation_value_sum_fields
  var_pop: translation_value_var_pop_fields
  var_samp: translation_value_var_samp_fields
  variance: translation_value_variance_fields
}

"""
order by aggregate values of table "translation_value"
"""
input translation_value_aggregate_order_by {
  avg: translation_value_avg_order_by
  count: order_by
  max: translation_value_max_order_by
  min: translation_value_min_order_by
  stddev: translation_value_stddev_order_by
  stddev_pop: translation_value_stddev_pop_order_by
  stddev_samp: translation_value_stddev_samp_order_by
  sum: translation_value_sum_order_by
  var_pop: translation_value_var_pop_order_by
  var_samp: translation_value_var_samp_order_by
  variance: translation_value_variance_order_by
}

"""
input type for inserting array relation for remote table "translation_value"
"""
input translation_value_arr_rel_insert_input {
  data: [translation_value_insert_input!]!

  """upsert condition"""
  on_conflict: translation_value_on_conflict
}

"""aggregate avg on columns"""
type translation_value_avg_fields {
  translation_id: Float
}

"""
order by avg() on columns of table "translation_value"
"""
input translation_value_avg_order_by {
  translation_id: order_by
}

"""
Boolean expression to filter rows from the table "translation_value". All fields are combined with a logical 'AND'.
"""
input translation_value_bool_exp {
  _and: [translation_value_bool_exp!]
  _not: translation_value_bool_exp
  _or: [translation_value_bool_exp!]
  language: topology_language_bool_exp
  language_id: String_comparison_exp
  translation_group: translation_bool_exp
  translation_id: Int_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "translation_value"
"""
enum translation_value_constraint {
  """
  unique or primary key constraint on columns "translation_id", "language_id"
  """
  translation_value_pkey
}

"""
input type for incrementing numeric columns in table "translation_value"
"""
input translation_value_inc_input {
  translation_id: Int
}

"""
input type for inserting data into table "translation_value"
"""
input translation_value_insert_input {
  language: topology_language_obj_rel_insert_input
  language_id: String
  translation_group: translation_obj_rel_insert_input
  translation_id: Int
  value: String
}

"""aggregate max on columns"""
type translation_value_max_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by max() on columns of table "translation_value"
"""
input translation_value_max_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type translation_value_min_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by min() on columns of table "translation_value"
"""
input translation_value_min_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""
response of any mutation on the table "translation_value"
"""
type translation_value_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation_value!]!
}

"""
on_conflict condition type for table "translation_value"
"""
input translation_value_on_conflict {
  constraint: translation_value_constraint!
  update_columns: [translation_value_update_column!]! = []
  where: translation_value_bool_exp
}

"""Ordering options when selecting data from "translation_value"."""
input translation_value_order_by {
  language: topology_language_order_by
  language_id: order_by
  translation_group: translation_order_by
  translation_id: order_by
  value: order_by
}

"""primary key columns input for table: translation_value"""
input translation_value_pk_columns_input {
  language_id: String!
  translation_id: Int!
}

"""
select columns of table "translation_value"
"""
enum translation_value_select_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

"""
input type for updating data in table "translation_value"
"""
input translation_value_set_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate stddev on columns"""
type translation_value_stddev_fields {
  translation_id: Float
}

"""
order by stddev() on columns of table "translation_value"
"""
input translation_value_stddev_order_by {
  translation_id: order_by
}

"""aggregate stddev_pop on columns"""
type translation_value_stddev_pop_fields {
  translation_id: Float
}

"""
order by stddev_pop() on columns of table "translation_value"
"""
input translation_value_stddev_pop_order_by {
  translation_id: order_by
}

"""aggregate stddev_samp on columns"""
type translation_value_stddev_samp_fields {
  translation_id: Float
}

"""
order by stddev_samp() on columns of table "translation_value"
"""
input translation_value_stddev_samp_order_by {
  translation_id: order_by
}

"""
Streaming cursor of the table "translation_value"
"""
input translation_value_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_value_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_value_stream_cursor_value_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate sum on columns"""
type translation_value_sum_fields {
  translation_id: Int
}

"""
order by sum() on columns of table "translation_value"
"""
input translation_value_sum_order_by {
  translation_id: order_by
}

"""
update columns of table "translation_value"
"""
enum translation_value_update_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

input translation_value_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_value_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_value_set_input
  where: translation_value_bool_exp!
}

"""aggregate var_pop on columns"""
type translation_value_var_pop_fields {
  translation_id: Float
}

"""
order by var_pop() on columns of table "translation_value"
"""
input translation_value_var_pop_order_by {
  translation_id: order_by
}

"""aggregate var_samp on columns"""
type translation_value_var_samp_fields {
  translation_id: Float
}

"""
order by var_samp() on columns of table "translation_value"
"""
input translation_value_var_samp_order_by {
  translation_id: order_by
}

"""aggregate variance on columns"""
type translation_value_variance_fields {
  translation_id: Float
}

"""
order by variance() on columns of table "translation_value"
"""
input translation_value_variance_order_by {
  translation_id: order_by
}

"""aggregate var_pop on columns"""
type translation_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type translation_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type translation_variance_fields {
  id: Float
}

"""
columns and relationships of "user"
"""
type user {
  deleted: Boolean!
  firebase_id: String!
  id: Int!
  image: String
  language_id: String!
  name: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""aggregate avg on columns"""
type user_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  deleted: Boolean_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for incrementing numeric columns in table "user"
"""
input user_inc_input {
  id: Int
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  deleted: Boolean
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
}

"""aggregate max on columns"""
type user_max_fields {
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
}

"""aggregate min on columns"""
type user_min_fields {
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  deleted: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  name: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: Int!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  deleted

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  deleted: Boolean
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
}

"""aggregate stddev on columns"""
type user_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type user_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type user_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  deleted: Boolean
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
}

"""aggregate sum on columns"""
type user_sum_fields {
  id: Int
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  deleted

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name
}

input user_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input
  where: user_bool_exp!
}

"""aggregate var_pop on columns"""
type user_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type user_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type user_variance_fields {
  id: Float
}
