schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "app_type"
"""
type app_type {
  """customer, delivery, restaurant, admin"""
  id: String!
}

"""
aggregated selection of "app_type"
"""
type app_type_aggregate {
  aggregate: app_type_aggregate_fields
  nodes: [app_type!]!
}

"""
aggregate fields of "app_type"
"""
type app_type_aggregate_fields {
  count(columns: [app_type_select_column!], distinct: Boolean): Int!
  max: app_type_max_fields
  min: app_type_min_fields
}

"""
Boolean expression to filter rows from the table "app_type". All fields are combined with a logical 'AND'.
"""
input app_type_bool_exp {
  _and: [app_type_bool_exp!]
  _not: app_type_bool_exp
  _or: [app_type_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "app_type"
"""
enum app_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_type_pkey
}

"""
input type for inserting data into table "app_type"
"""
input app_type_insert_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""aggregate max on columns"""
type app_type_max_fields {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""aggregate min on columns"""
type app_type_min_fields {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
response of any mutation on the table "app_type"
"""
type app_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_type!]!
}

"""
on_conflict condition type for table "app_type"
"""
input app_type_on_conflict {
  constraint: app_type_constraint!
  update_columns: [app_type_update_column!]! = []
  where: app_type_bool_exp
}

"""Ordering options when selecting data from "app_type"."""
input app_type_order_by {
  id: order_by
}

"""primary key columns input for table: app_type"""
input app_type_pk_columns_input {
  """customer, delivery, restaurant, admin"""
  id: String!
}

"""
select columns of table "app_type"
"""
enum app_type_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "app_type"
"""
input app_type_set_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
Streaming cursor of the table "app_type"
"""
input app_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: app_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input app_type_stream_cursor_value_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
update columns of table "app_type"
"""
enum app_type_update_column {
  """column name"""
  id
}

input app_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: app_type_set_input

  """filter the rows which have to be updated"""
  where: app_type_bool_exp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "chat"
"""
type chat {
  chat_info(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  chat_participants(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """An aggregate relationship"""
  chat_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """direct, group"""
  chat_type: String!
  creation_time: timestamptz!
  id: Int!
  messages(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "chat"
"""
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

"""
aggregate fields of "chat"
"""
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int!
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input chat_append_input {
  chat_info: jsonb
  messages: jsonb
}

"""aggregate avg on columns"""
type chat_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
"""
input chat_bool_exp {
  _and: [chat_bool_exp!]
  _not: chat_bool_exp
  _or: [chat_bool_exp!]
  chat_info: jsonb_comparison_exp
  chat_participants: chat_participant_bool_exp
  chat_participants_aggregate: chat_participant_aggregate_bool_exp
  chat_type: String_comparison_exp
  creation_time: timestamptz_comparison_exp
  id: Int_comparison_exp
  messages: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "chat"
"""
enum chat_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input chat_delete_at_path_input {
  chat_info: [String!]
  messages: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input chat_delete_elem_input {
  chat_info: Int
  messages: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input chat_delete_key_input {
  chat_info: String
  messages: String
}

"""
input type for incrementing numeric columns in table "chat"
"""
input chat_inc_input {
  id: Int
}

"""
input type for inserting data into table "chat"
"""
input chat_insert_input {
  chat_info: jsonb
  chat_participants: chat_participant_arr_rel_insert_input

  """direct, group"""
  chat_type: String
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate max on columns"""
type chat_max_fields {
  """direct, group"""
  chat_type: String
  creation_time: timestamptz
  id: Int
}

"""aggregate min on columns"""
type chat_min_fields {
  """direct, group"""
  chat_type: String
  creation_time: timestamptz
  id: Int
}

"""
response of any mutation on the table "chat"
"""
type chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat!]!
}

"""
input type for inserting object relation for remote table "chat"
"""
input chat_obj_rel_insert_input {
  data: chat_insert_input!

  """upsert condition"""
  on_conflict: chat_on_conflict
}

"""
on_conflict condition type for table "chat"
"""
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]! = []
  where: chat_bool_exp
}

"""Ordering options when selecting data from "chat"."""
input chat_order_by {
  chat_info: order_by
  chat_participants_aggregate: chat_participant_aggregate_order_by
  chat_type: order_by
  creation_time: order_by
  id: order_by
  messages: order_by
}

"""
columns and relationships of "chat_participant"
"""
type chat_participant {
  app_type_id: String!

  """An object relationship"""
  chat: chat!
  chat_id: Int!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  participant_id: Int!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "chat_participant"
"""
type chat_participant_aggregate {
  aggregate: chat_participant_aggregate_fields
  nodes: [chat_participant!]!
}

input chat_participant_aggregate_bool_exp {
  count: chat_participant_aggregate_bool_exp_count
}

input chat_participant_aggregate_bool_exp_count {
  arguments: [chat_participant_select_column!]
  distinct: Boolean
  filter: chat_participant_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "chat_participant"
"""
type chat_participant_aggregate_fields {
  avg: chat_participant_avg_fields
  count(columns: [chat_participant_select_column!], distinct: Boolean): Int!
  max: chat_participant_max_fields
  min: chat_participant_min_fields
  stddev: chat_participant_stddev_fields
  stddev_pop: chat_participant_stddev_pop_fields
  stddev_samp: chat_participant_stddev_samp_fields
  sum: chat_participant_sum_fields
  var_pop: chat_participant_var_pop_fields
  var_samp: chat_participant_var_samp_fields
  variance: chat_participant_variance_fields
}

"""
order by aggregate values of table "chat_participant"
"""
input chat_participant_aggregate_order_by {
  avg: chat_participant_avg_order_by
  count: order_by
  max: chat_participant_max_order_by
  min: chat_participant_min_order_by
  stddev: chat_participant_stddev_order_by
  stddev_pop: chat_participant_stddev_pop_order_by
  stddev_samp: chat_participant_stddev_samp_order_by
  sum: chat_participant_sum_order_by
  var_pop: chat_participant_var_pop_order_by
  var_samp: chat_participant_var_samp_order_by
  variance: chat_participant_variance_order_by
}

"""
input type for inserting array relation for remote table "chat_participant"
"""
input chat_participant_arr_rel_insert_input {
  data: [chat_participant_insert_input!]!

  """upsert condition"""
  on_conflict: chat_participant_on_conflict
}

"""aggregate avg on columns"""
type chat_participant_avg_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by avg() on columns of table "chat_participant"
"""
input chat_participant_avg_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
Boolean expression to filter rows from the table "chat_participant". All fields are combined with a logical 'AND'.
"""
input chat_participant_bool_exp {
  _and: [chat_participant_bool_exp!]
  _not: chat_participant_bool_exp
  _or: [chat_participant_bool_exp!]
  app_type_id: String_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  participant_id: Int_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "chat_participant"
"""
enum chat_participant_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_participants_pkey
}

"""
input type for incrementing numeric columns in table "chat_participant"
"""
input chat_participant_inc_input {
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
input type for inserting data into table "chat_participant"
"""
input chat_participant_insert_input {
  app_type_id: String
  chat: chat_obj_rel_insert_input
  chat_id: Int
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  participant_id: Int
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type chat_participant_max_fields {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by max() on columns of table "chat_participant"
"""
input chat_participant_max_order_by {
  app_type_id: order_by
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate min on columns"""
type chat_participant_min_fields {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by min() on columns of table "chat_participant"
"""
input chat_participant_min_order_by {
  app_type_id: order_by
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
response of any mutation on the table "chat_participant"
"""
type chat_participant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat_participant!]!
}

"""
on_conflict condition type for table "chat_participant"
"""
input chat_participant_on_conflict {
  constraint: chat_participant_constraint!
  update_columns: [chat_participant_update_column!]! = []
  where: chat_participant_bool_exp
}

"""Ordering options when selecting data from "chat_participant"."""
input chat_participant_order_by {
  app_type_id: order_by
  chat: chat_order_by
  chat_id: order_by
  id: order_by
  notification_info: notification_info_order_by
  participant_id: order_by
  user: user_order_by
}

"""primary key columns input for table: chat_participant"""
input chat_participant_pk_columns_input {
  id: Int!
}

"""
select columns of table "chat_participant"
"""
enum chat_participant_select_column {
  """column name"""
  app_type_id

  """column name"""
  chat_id

  """column name"""
  id

  """column name"""
  participant_id
}

"""
input type for updating data in table "chat_participant"
"""
input chat_participant_set_input {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""aggregate stddev on columns"""
type chat_participant_stddev_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev() on columns of table "chat_participant"
"""
input chat_participant_stddev_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate stddev_pop on columns"""
type chat_participant_stddev_pop_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev_pop() on columns of table "chat_participant"
"""
input chat_participant_stddev_pop_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate stddev_samp on columns"""
type chat_participant_stddev_samp_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev_samp() on columns of table "chat_participant"
"""
input chat_participant_stddev_samp_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
Streaming cursor of the table "chat_participant"
"""
input chat_participant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_participant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_participant_stream_cursor_value_input {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""aggregate sum on columns"""
type chat_participant_sum_fields {
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by sum() on columns of table "chat_participant"
"""
input chat_participant_sum_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
update columns of table "chat_participant"
"""
enum chat_participant_update_column {
  """column name"""
  app_type_id

  """column name"""
  chat_id

  """column name"""
  id

  """column name"""
  participant_id
}

input chat_participant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_participant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_participant_set_input

  """filter the rows which have to be updated"""
  where: chat_participant_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_participant_var_pop_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by var_pop() on columns of table "chat_participant"
"""
input chat_participant_var_pop_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate var_samp on columns"""
type chat_participant_var_samp_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by var_samp() on columns of table "chat_participant"
"""
input chat_participant_var_samp_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate variance on columns"""
type chat_participant_variance_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by variance() on columns of table "chat_participant"
"""
input chat_participant_variance_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""primary key columns input for table: chat"""
input chat_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input chat_prepend_input {
  chat_info: jsonb
  messages: jsonb
}

"""
select columns of table "chat"
"""
enum chat_select_column {
  """column name"""
  chat_info

  """column name"""
  chat_type

  """column name"""
  creation_time

  """column name"""
  id

  """column name"""
  messages
}

"""
input type for updating data in table "chat"
"""
input chat_set_input {
  chat_info: jsonb

  """direct, group"""
  chat_type: String
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate stddev on columns"""
type chat_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type chat_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type chat_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "chat"
"""
input chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_stream_cursor_value_input {
  chat_info: jsonb

  """direct, group"""
  chat_type: String
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate sum on columns"""
type chat_sum_fields {
  id: Int
}

"""
update columns of table "chat"
"""
enum chat_update_column {
  """column name"""
  chat_info

  """column name"""
  chat_type

  """column name"""
  creation_time

  """column name"""
  id

  """column name"""
  messages
}

input chat_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: chat_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: chat_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: chat_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: chat_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: chat_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_set_input

  """filter the rows which have to be updated"""
  where: chat_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type chat_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type chat_variance_fields {
  id: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "customer.customer"
"""
type customer_customer {
  app_type_id: String!
  app_version: String

  """An object relationship"""
  cart: restaurant_cart

  """An array relationship"""
  deliveries(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """An aggregate relationship"""
  deliveries_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """An object relationship"""
  notification_info: notification_info

  """An array relationship"""
  saved_locations(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): [customer_saved_location!]!

  """An aggregate relationship"""
  saved_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): customer_saved_location_aggregate!
  service_provider_type: String

  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "customer.customer"
"""
type customer_customer_aggregate {
  aggregate: customer_customer_aggregate_fields
  nodes: [customer_customer!]!
}

"""
aggregate fields of "customer.customer"
"""
type customer_customer_aggregate_fields {
  avg: customer_customer_avg_fields
  count(columns: [customer_customer_select_column!], distinct: Boolean): Int!
  max: customer_customer_max_fields
  min: customer_customer_min_fields
  stddev: customer_customer_stddev_fields
  stddev_pop: customer_customer_stddev_pop_fields
  stddev_samp: customer_customer_stddev_samp_fields
  sum: customer_customer_sum_fields
  var_pop: customer_customer_var_pop_fields
  var_samp: customer_customer_var_samp_fields
  variance: customer_customer_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input customer_customer_append_input {
  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: jsonb
}

"""aggregate avg on columns"""
type customer_customer_avg_fields {
  user_id: Float
}

"""
Boolean expression to filter rows from the table "customer.customer". All fields are combined with a logical 'AND'.
"""
input customer_customer_bool_exp {
  _and: [customer_customer_bool_exp!]
  _not: customer_customer_bool_exp
  _or: [customer_customer_bool_exp!]
  app_type_id: String_comparison_exp
  app_version: String_comparison_exp
  cart: restaurant_cart_bool_exp
  deliveries: delivery_order_bool_exp
  deliveries_aggregate: delivery_order_aggregate_bool_exp
  notification_info: notification_info_bool_exp
  saved_locations: customer_saved_location_bool_exp
  saved_locations_aggregate: customer_saved_location_aggregate_bool_exp
  service_provider_type: String_comparison_exp
  stripe_info: jsonb_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "customer.customer"
"""
enum customer_customer_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  customer_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  customer_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input customer_customer_delete_at_path_input {
  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input customer_customer_delete_elem_input {
  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input customer_customer_delete_key_input {
  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "customer.customer"
"""
input customer_customer_inc_input {
  user_id: Int
}

"""
input type for inserting data into table "customer.customer"
"""
input customer_customer_insert_input {
  app_type_id: String
  app_version: String
  cart: restaurant_cart_obj_rel_insert_input
  deliveries: delivery_order_arr_rel_insert_input
  notification_info: notification_info_obj_rel_insert_input
  saved_locations: customer_saved_location_arr_rel_insert_input
  service_provider_type: String

  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: jsonb
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type customer_customer_max_fields {
  app_type_id: String
  app_version: String
  service_provider_type: String
  user_id: Int
}

"""aggregate min on columns"""
type customer_customer_min_fields {
  app_type_id: String
  app_version: String
  service_provider_type: String
  user_id: Int
}

"""
response of any mutation on the table "customer.customer"
"""
type customer_customer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_customer!]!
}

"""
input type for inserting object relation for remote table "customer.customer"
"""
input customer_customer_obj_rel_insert_input {
  data: customer_customer_insert_input!

  """upsert condition"""
  on_conflict: customer_customer_on_conflict
}

"""
on_conflict condition type for table "customer.customer"
"""
input customer_customer_on_conflict {
  constraint: customer_customer_constraint!
  update_columns: [customer_customer_update_column!]! = []
  where: customer_customer_bool_exp
}

"""Ordering options when selecting data from "customer.customer"."""
input customer_customer_order_by {
  app_type_id: order_by
  app_version: order_by
  cart: restaurant_cart_order_by
  deliveries_aggregate: delivery_order_aggregate_order_by
  notification_info: notification_info_order_by
  saved_locations_aggregate: customer_saved_location_aggregate_order_by
  service_provider_type: order_by
  stripe_info: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: customer.customer"""
input customer_customer_pk_columns_input {
  user_id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input customer_customer_prepend_input {
  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: jsonb
}

"""
select columns of table "customer.customer"
"""
enum customer_customer_select_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  service_provider_type

  """column name"""
  stripe_info

  """column name"""
  user_id
}

"""
input type for updating data in table "customer.customer"
"""
input customer_customer_set_input {
  app_type_id: String
  app_version: String
  service_provider_type: String

  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: jsonb
  user_id: Int
}

"""aggregate stddev on columns"""
type customer_customer_stddev_fields {
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type customer_customer_stddev_pop_fields {
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type customer_customer_stddev_samp_fields {
  user_id: Float
}

"""
Streaming cursor of the table "customer_customer"
"""
input customer_customer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_customer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_customer_stream_cursor_value_input {
  app_type_id: String
  app_version: String
  service_provider_type: String

  """
  {     id: string,     idsWithServiceProvider: (Record of orderType and ids
  Object) {         restaurant: {Record of restaurantIds and
  stripeIdsWithServiceProvider}     },     cards: Record of cardId(string) and
  card object: {             id: string,             last4?: string,            
  brand?: string,             expMonth?: number,             expYear?: number,  
            idsWithServiceProvider: same as above,         }     } }
  """
  stripe_info: jsonb
  user_id: Int
}

"""aggregate sum on columns"""
type customer_customer_sum_fields {
  user_id: Int
}

"""
update columns of table "customer.customer"
"""
enum customer_customer_update_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  service_provider_type

  """column name"""
  stripe_info

  """column name"""
  user_id
}

input customer_customer_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: customer_customer_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: customer_customer_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: customer_customer_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: customer_customer_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: customer_customer_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: customer_customer_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: customer_customer_set_input

  """filter the rows which have to be updated"""
  where: customer_customer_bool_exp!
}

"""aggregate var_pop on columns"""
type customer_customer_var_pop_fields {
  user_id: Float
}

"""aggregate var_samp on columns"""
type customer_customer_var_samp_fields {
  user_id: Float
}

"""aggregate variance on columns"""
type customer_customer_variance_fields {
  user_id: Float
}

"""
columns and relationships of "customer.favourited_item"
"""
type customer_favourited_item {
  customer_id: Int!
  id: Int!
  restaurant_id: Int!
  restaurant_item_id: Int!
}

"""
aggregated selection of "customer.favourited_item"
"""
type customer_favourited_item_aggregate {
  aggregate: customer_favourited_item_aggregate_fields
  nodes: [customer_favourited_item!]!
}

"""
aggregate fields of "customer.favourited_item"
"""
type customer_favourited_item_aggregate_fields {
  avg: customer_favourited_item_avg_fields
  count(columns: [customer_favourited_item_select_column!], distinct: Boolean): Int!
  max: customer_favourited_item_max_fields
  min: customer_favourited_item_min_fields
  stddev: customer_favourited_item_stddev_fields
  stddev_pop: customer_favourited_item_stddev_pop_fields
  stddev_samp: customer_favourited_item_stddev_samp_fields
  sum: customer_favourited_item_sum_fields
  var_pop: customer_favourited_item_var_pop_fields
  var_samp: customer_favourited_item_var_samp_fields
  variance: customer_favourited_item_variance_fields
}

"""aggregate avg on columns"""
type customer_favourited_item_avg_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""
Boolean expression to filter rows from the table "customer.favourited_item". All fields are combined with a logical 'AND'.
"""
input customer_favourited_item_bool_exp {
  _and: [customer_favourited_item_bool_exp!]
  _not: customer_favourited_item_bool_exp
  _or: [customer_favourited_item_bool_exp!]
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  restaurant_id: Int_comparison_exp
  restaurant_item_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "customer.favourited_item"
"""
enum customer_favourited_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  favourited_item_pkey
}

"""
input type for incrementing numeric columns in table "customer.favourited_item"
"""
input customer_favourited_item_inc_input {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""
input type for inserting data into table "customer.favourited_item"
"""
input customer_favourited_item_insert_input {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""aggregate max on columns"""
type customer_favourited_item_max_fields {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""aggregate min on columns"""
type customer_favourited_item_min_fields {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""
response of any mutation on the table "customer.favourited_item"
"""
type customer_favourited_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_favourited_item!]!
}

"""
on_conflict condition type for table "customer.favourited_item"
"""
input customer_favourited_item_on_conflict {
  constraint: customer_favourited_item_constraint!
  update_columns: [customer_favourited_item_update_column!]! = []
  where: customer_favourited_item_bool_exp
}

"""Ordering options when selecting data from "customer.favourited_item"."""
input customer_favourited_item_order_by {
  customer_id: order_by
  id: order_by
  restaurant_id: order_by
  restaurant_item_id: order_by
}

"""primary key columns input for table: customer.favourited_item"""
input customer_favourited_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "customer.favourited_item"
"""
enum customer_favourited_item_select_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  restaurant_id

  """column name"""
  restaurant_item_id
}

"""
input type for updating data in table "customer.favourited_item"
"""
input customer_favourited_item_set_input {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""aggregate stddev on columns"""
type customer_favourited_item_stddev_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""aggregate stddev_pop on columns"""
type customer_favourited_item_stddev_pop_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""aggregate stddev_samp on columns"""
type customer_favourited_item_stddev_samp_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""
Streaming cursor of the table "customer_favourited_item"
"""
input customer_favourited_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_favourited_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_favourited_item_stream_cursor_value_input {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""aggregate sum on columns"""
type customer_favourited_item_sum_fields {
  customer_id: Int
  id: Int
  restaurant_id: Int
  restaurant_item_id: Int
}

"""
update columns of table "customer.favourited_item"
"""
enum customer_favourited_item_update_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  restaurant_id

  """column name"""
  restaurant_item_id
}

input customer_favourited_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: customer_favourited_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: customer_favourited_item_set_input

  """filter the rows which have to be updated"""
  where: customer_favourited_item_bool_exp!
}

"""aggregate var_pop on columns"""
type customer_favourited_item_var_pop_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""aggregate var_samp on columns"""
type customer_favourited_item_var_samp_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""aggregate variance on columns"""
type customer_favourited_item_variance_fields {
  customer_id: Float
  id: Float
  restaurant_id: Float
  restaurant_item_id: Float
}

"""Customer's saved locations"""
type customer_saved_location {
  customer_id: Int!
  default: Boolean!
  id: Int!
  location_gps: geography!
  location_text: String!
  name: String!
}

"""
aggregated selection of "customer.saved_location"
"""
type customer_saved_location_aggregate {
  aggregate: customer_saved_location_aggregate_fields
  nodes: [customer_saved_location!]!
}

input customer_saved_location_aggregate_bool_exp {
  bool_and: customer_saved_location_aggregate_bool_exp_bool_and
  bool_or: customer_saved_location_aggregate_bool_exp_bool_or
  count: customer_saved_location_aggregate_bool_exp_count
}

input customer_saved_location_aggregate_bool_exp_bool_and {
  arguments: customer_saved_location_select_column_customer_saved_location_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: customer_saved_location_bool_exp
  predicate: Boolean_comparison_exp!
}

input customer_saved_location_aggregate_bool_exp_bool_or {
  arguments: customer_saved_location_select_column_customer_saved_location_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: customer_saved_location_bool_exp
  predicate: Boolean_comparison_exp!
}

input customer_saved_location_aggregate_bool_exp_count {
  arguments: [customer_saved_location_select_column!]
  distinct: Boolean
  filter: customer_saved_location_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "customer.saved_location"
"""
type customer_saved_location_aggregate_fields {
  avg: customer_saved_location_avg_fields
  count(columns: [customer_saved_location_select_column!], distinct: Boolean): Int!
  max: customer_saved_location_max_fields
  min: customer_saved_location_min_fields
  stddev: customer_saved_location_stddev_fields
  stddev_pop: customer_saved_location_stddev_pop_fields
  stddev_samp: customer_saved_location_stddev_samp_fields
  sum: customer_saved_location_sum_fields
  var_pop: customer_saved_location_var_pop_fields
  var_samp: customer_saved_location_var_samp_fields
  variance: customer_saved_location_variance_fields
}

"""
order by aggregate values of table "customer.saved_location"
"""
input customer_saved_location_aggregate_order_by {
  avg: customer_saved_location_avg_order_by
  count: order_by
  max: customer_saved_location_max_order_by
  min: customer_saved_location_min_order_by
  stddev: customer_saved_location_stddev_order_by
  stddev_pop: customer_saved_location_stddev_pop_order_by
  stddev_samp: customer_saved_location_stddev_samp_order_by
  sum: customer_saved_location_sum_order_by
  var_pop: customer_saved_location_var_pop_order_by
  var_samp: customer_saved_location_var_samp_order_by
  variance: customer_saved_location_variance_order_by
}

"""
input type for inserting array relation for remote table "customer.saved_location"
"""
input customer_saved_location_arr_rel_insert_input {
  data: [customer_saved_location_insert_input!]!

  """upsert condition"""
  on_conflict: customer_saved_location_on_conflict
}

"""aggregate avg on columns"""
type customer_saved_location_avg_fields {
  customer_id: Float
  id: Float
}

"""
order by avg() on columns of table "customer.saved_location"
"""
input customer_saved_location_avg_order_by {
  customer_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "customer.saved_location". All fields are combined with a logical 'AND'.
"""
input customer_saved_location_bool_exp {
  _and: [customer_saved_location_bool_exp!]
  _not: customer_saved_location_bool_exp
  _or: [customer_saved_location_bool_exp!]
  customer_id: Int_comparison_exp
  default: Boolean_comparison_exp
  id: Int_comparison_exp
  location_gps: geography_comparison_exp
  location_text: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "customer.saved_location"
"""
enum customer_saved_location_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  saved_location_pkey
}

"""
input type for incrementing numeric columns in table "customer.saved_location"
"""
input customer_saved_location_inc_input {
  customer_id: Int
  id: Int
}

"""
input type for inserting data into table "customer.saved_location"
"""
input customer_saved_location_insert_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate max on columns"""
type customer_saved_location_max_fields {
  customer_id: Int
  id: Int
  location_text: String
  name: String
}

"""
order by max() on columns of table "customer.saved_location"
"""
input customer_saved_location_max_order_by {
  customer_id: order_by
  id: order_by
  location_text: order_by
  name: order_by
}

"""aggregate min on columns"""
type customer_saved_location_min_fields {
  customer_id: Int
  id: Int
  location_text: String
  name: String
}

"""
order by min() on columns of table "customer.saved_location"
"""
input customer_saved_location_min_order_by {
  customer_id: order_by
  id: order_by
  location_text: order_by
  name: order_by
}

"""
response of any mutation on the table "customer.saved_location"
"""
type customer_saved_location_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_saved_location!]!
}

"""
on_conflict condition type for table "customer.saved_location"
"""
input customer_saved_location_on_conflict {
  constraint: customer_saved_location_constraint!
  update_columns: [customer_saved_location_update_column!]! = []
  where: customer_saved_location_bool_exp
}

"""Ordering options when selecting data from "customer.saved_location"."""
input customer_saved_location_order_by {
  customer_id: order_by
  default: order_by
  id: order_by
  location_gps: order_by
  location_text: order_by
  name: order_by
}

"""primary key columns input for table: customer.saved_location"""
input customer_saved_location_pk_columns_input {
  id: Int!
}

"""
select columns of table "customer.saved_location"
"""
enum customer_saved_location_select_column {
  """column name"""
  customer_id

  """column name"""
  default

  """column name"""
  id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name
}

"""
select "customer_saved_location_aggregate_bool_exp_bool_and_arguments_columns" columns of table "customer.saved_location"
"""
enum customer_saved_location_select_column_customer_saved_location_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  default
}

"""
select "customer_saved_location_aggregate_bool_exp_bool_or_arguments_columns" columns of table "customer.saved_location"
"""
enum customer_saved_location_select_column_customer_saved_location_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  default
}

"""
input type for updating data in table "customer.saved_location"
"""
input customer_saved_location_set_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate stddev on columns"""
type customer_saved_location_stddev_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev() on columns of table "customer.saved_location"
"""
input customer_saved_location_stddev_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type customer_saved_location_stddev_pop_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "customer.saved_location"
"""
input customer_saved_location_stddev_pop_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type customer_saved_location_stddev_samp_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "customer.saved_location"
"""
input customer_saved_location_stddev_samp_order_by {
  customer_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "customer_saved_location"
"""
input customer_saved_location_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_saved_location_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_saved_location_stream_cursor_value_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate sum on columns"""
type customer_saved_location_sum_fields {
  customer_id: Int
  id: Int
}

"""
order by sum() on columns of table "customer.saved_location"
"""
input customer_saved_location_sum_order_by {
  customer_id: order_by
  id: order_by
}

"""
update columns of table "customer.saved_location"
"""
enum customer_saved_location_update_column {
  """column name"""
  customer_id

  """column name"""
  default

  """column name"""
  id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name
}

input customer_saved_location_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: customer_saved_location_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: customer_saved_location_set_input

  """filter the rows which have to be updated"""
  where: customer_saved_location_bool_exp!
}

"""aggregate var_pop on columns"""
type customer_saved_location_var_pop_fields {
  customer_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "customer.saved_location"
"""
input customer_saved_location_var_pop_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type customer_saved_location_var_samp_fields {
  customer_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "customer.saved_location"
"""
input customer_saved_location_var_samp_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type customer_saved_location_variance_fields {
  customer_id: Float
  id: Float
}

"""
order by variance() on columns of table "customer.saved_location"
"""
input customer_saved_location_variance_order_by {
  customer_id: order_by
  id: order_by
}

"""
columns and relationships of "delivery.company"
"""
type delivery_company {
  approved: Boolean!
  creation_time: timestamptz!

  """An object relationship"""
  delivery_details: delivery_details!
  delivery_details_id: Int!

  """An array relationship"""
  delivery_drivers(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """An aggregate relationship"""
  delivery_drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """An array relationship"""
  delivery_operators(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """An aggregate relationship"""
  delivery_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!
  image: String!

  """An object relationship"""
  location: service_provider_location!
  location_id: Int!
  name: String!
  open_status: String!
  service_provider_type: String!
}

"""
aggregated selection of "delivery.company"
"""
type delivery_company_aggregate {
  aggregate: delivery_company_aggregate_fields
  nodes: [delivery_company!]!
}

input delivery_company_aggregate_bool_exp {
  bool_and: delivery_company_aggregate_bool_exp_bool_and
  bool_or: delivery_company_aggregate_bool_exp_bool_or
  count: delivery_company_aggregate_bool_exp_count
}

input delivery_company_aggregate_bool_exp_bool_and {
  arguments: delivery_company_select_column_delivery_company_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_company_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_company_aggregate_bool_exp_bool_or {
  arguments: delivery_company_select_column_delivery_company_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_company_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_company_aggregate_bool_exp_count {
  arguments: [delivery_company_select_column!]
  distinct: Boolean
  filter: delivery_company_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery.company"
"""
type delivery_company_aggregate_fields {
  avg: delivery_company_avg_fields
  count(columns: [delivery_company_select_column!], distinct: Boolean): Int!
  max: delivery_company_max_fields
  min: delivery_company_min_fields
  stddev: delivery_company_stddev_fields
  stddev_pop: delivery_company_stddev_pop_fields
  stddev_samp: delivery_company_stddev_samp_fields
  sum: delivery_company_sum_fields
  var_pop: delivery_company_var_pop_fields
  var_samp: delivery_company_var_samp_fields
  variance: delivery_company_variance_fields
}

"""
order by aggregate values of table "delivery.company"
"""
input delivery_company_aggregate_order_by {
  avg: delivery_company_avg_order_by
  count: order_by
  max: delivery_company_max_order_by
  min: delivery_company_min_order_by
  stddev: delivery_company_stddev_order_by
  stddev_pop: delivery_company_stddev_pop_order_by
  stddev_samp: delivery_company_stddev_samp_order_by
  sum: delivery_company_sum_order_by
  var_pop: delivery_company_var_pop_order_by
  var_samp: delivery_company_var_samp_order_by
  variance: delivery_company_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery.company"
"""
input delivery_company_arr_rel_insert_input {
  data: [delivery_company_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_company_on_conflict
}

"""aggregate avg on columns"""
type delivery_company_avg_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by avg() on columns of table "delivery.company"
"""
input delivery_company_avg_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
Boolean expression to filter rows from the table "delivery.company". All fields are combined with a logical 'AND'.
"""
input delivery_company_bool_exp {
  _and: [delivery_company_bool_exp!]
  _not: delivery_company_bool_exp
  _or: [delivery_company_bool_exp!]
  approved: Boolean_comparison_exp
  creation_time: timestamptz_comparison_exp
  delivery_details: delivery_details_bool_exp
  delivery_details_id: Int_comparison_exp
  delivery_drivers: delivery_driver_bool_exp
  delivery_drivers_aggregate: delivery_driver_aggregate_bool_exp
  delivery_operators: delivery_operator_bool_exp
  delivery_operators_aggregate: delivery_operator_aggregate_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  location: service_provider_location_bool_exp
  location_id: Int_comparison_exp
  name: String_comparison_exp
  open_status: String_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery.company"
"""
enum delivery_company_constraint {
  """
  unique or primary key constraint on columns "delivery_details_id"
  """
  company_delivery_details_id_key

  """
  unique or primary key constraint on columns "location_id"
  """
  company_location_id_key

  """
  unique or primary key constraint on columns "id"
  """
  delivery_company_pkey
}

"""
input type for incrementing numeric columns in table "delivery.company"
"""
input delivery_company_inc_input {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int
}

"""
input type for inserting data into table "delivery.company"
"""
input delivery_company_insert_input {
  approved: Boolean
  creation_time: timestamptz
  delivery_details: delivery_details_obj_rel_insert_input
  delivery_details_id: Int
  delivery_drivers: delivery_driver_arr_rel_insert_input
  delivery_operators: delivery_operator_arr_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  image: String
  location: service_provider_location_obj_rel_insert_input
  location_id: Int
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate max on columns"""
type delivery_company_max_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  location_id: Int
  name: String
  open_status: String
  service_provider_type: String
}

"""
order by max() on columns of table "delivery.company"
"""
input delivery_company_max_order_by {
  creation_time: order_by
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  image: order_by
  location_id: order_by
  name: order_by
  open_status: order_by
  service_provider_type: order_by
}

"""aggregate min on columns"""
type delivery_company_min_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  location_id: Int
  name: String
  open_status: String
  service_provider_type: String
}

"""
order by min() on columns of table "delivery.company"
"""
input delivery_company_min_order_by {
  creation_time: order_by
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  image: order_by
  location_id: order_by
  name: order_by
  open_status: order_by
  service_provider_type: order_by
}

"""
response of any mutation on the table "delivery.company"
"""
type delivery_company_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_company!]!
}

"""
input type for inserting object relation for remote table "delivery.company"
"""
input delivery_company_obj_rel_insert_input {
  data: delivery_company_insert_input!

  """upsert condition"""
  on_conflict: delivery_company_on_conflict
}

"""
on_conflict condition type for table "delivery.company"
"""
input delivery_company_on_conflict {
  constraint: delivery_company_constraint!
  update_columns: [delivery_company_update_column!]! = []
  where: delivery_company_bool_exp
}

"""Ordering options when selecting data from "delivery.company"."""
input delivery_company_order_by {
  approved: order_by
  creation_time: order_by
  delivery_details: delivery_details_order_by
  delivery_details_id: order_by
  delivery_drivers_aggregate: delivery_driver_aggregate_order_by
  delivery_operators_aggregate: delivery_operator_aggregate_order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  image: order_by
  location: service_provider_location_order_by
  location_id: order_by
  name: order_by
  open_status: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: delivery.company"""
input delivery_company_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery.company"
"""
enum delivery_company_select_column {
  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  service_provider_type
}

"""
select "delivery_company_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery.company"
"""
enum delivery_company_select_column_delivery_company_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  approved
}

"""
select "delivery_company_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery.company"
"""
enum delivery_company_select_column_delivery_company_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  approved
}

"""
input type for updating data in table "delivery.company"
"""
input delivery_company_set_input {
  approved: Boolean
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  location_id: Int
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate stddev on columns"""
type delivery_company_stddev_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev() on columns of table "delivery.company"
"""
input delivery_company_stddev_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_company_stddev_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev_pop() on columns of table "delivery.company"
"""
input delivery_company_stddev_pop_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_company_stddev_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev_samp() on columns of table "delivery.company"
"""
input delivery_company_stddev_samp_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
Streaming cursor of the table "delivery_company"
"""
input delivery_company_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_company_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_company_stream_cursor_value_input {
  approved: Boolean
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  location_id: Int
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate sum on columns"""
type delivery_company_sum_fields {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int
}

"""
order by sum() on columns of table "delivery.company"
"""
input delivery_company_sum_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
update columns of table "delivery.company"
"""
enum delivery_company_update_column {
  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  service_provider_type
}

input delivery_company_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_company_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_company_set_input

  """filter the rows which have to be updated"""
  where: delivery_company_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_company_var_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by var_pop() on columns of table "delivery.company"
"""
input delivery_company_var_pop_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate var_samp on columns"""
type delivery_company_var_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by var_samp() on columns of table "delivery.company"
"""
input delivery_company_var_samp_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate variance on columns"""
type delivery_company_variance_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by variance() on columns of table "delivery.company"
"""
input delivery_company_variance_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
columns and relationships of "delivery.details"
"""
type delivery_details {
  cost_per_km: money!

  """An array relationship"""
  delivery_company(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """An aggregate relationship"""
  delivery_company_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int!

  """An object relationship"""
  laundry: laundry_store
  minimum_cost: money!

  """in metres"""
  radius: Int!

  """An array relationship"""
  restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """An aggregate relationship"""
  restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): restaurant_restaurant_aggregate!
}

"""
aggregated selection of "delivery.details"
"""
type delivery_details_aggregate {
  aggregate: delivery_details_aggregate_fields
  nodes: [delivery_details!]!
}

"""
aggregate fields of "delivery.details"
"""
type delivery_details_aggregate_fields {
  avg: delivery_details_avg_fields
  count(columns: [delivery_details_select_column!], distinct: Boolean): Int!
  max: delivery_details_max_fields
  min: delivery_details_min_fields
  stddev: delivery_details_stddev_fields
  stddev_pop: delivery_details_stddev_pop_fields
  stddev_samp: delivery_details_stddev_samp_fields
  sum: delivery_details_sum_fields
  var_pop: delivery_details_var_pop_fields
  var_samp: delivery_details_var_samp_fields
  variance: delivery_details_variance_fields
}

"""
order by aggregate values of table "delivery.details"
"""
input delivery_details_aggregate_order_by {
  avg: delivery_details_avg_order_by
  count: order_by
  max: delivery_details_max_order_by
  min: delivery_details_min_order_by
  stddev: delivery_details_stddev_order_by
  stddev_pop: delivery_details_stddev_pop_order_by
  stddev_samp: delivery_details_stddev_samp_order_by
  sum: delivery_details_sum_order_by
  var_pop: delivery_details_var_pop_order_by
  var_samp: delivery_details_var_samp_order_by
  variance: delivery_details_variance_order_by
}

"""aggregate avg on columns"""
type delivery_details_avg_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by avg() on columns of table "delivery.details"
"""
input delivery_details_avg_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""
Boolean expression to filter rows from the table "delivery.details". All fields are combined with a logical 'AND'.
"""
input delivery_details_bool_exp {
  _and: [delivery_details_bool_exp!]
  _not: delivery_details_bool_exp
  _or: [delivery_details_bool_exp!]
  cost_per_km: money_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_company_aggregate: delivery_company_aggregate_bool_exp
  free_delivery_km_range: Float_comparison_exp
  free_delivery_minimum_cost: money_comparison_exp
  id: Int_comparison_exp
  laundry: laundry_store_bool_exp
  minimum_cost: money_comparison_exp
  radius: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_aggregate: restaurant_restaurant_aggregate_bool_exp
}

"""
unique or primary key constraints on table "delivery.details"
"""
enum delivery_details_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_cost_pkey
}

"""
input type for incrementing numeric columns in table "delivery.details"
"""
input delivery_details_inc_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""
input type for inserting data into table "delivery.details"
"""
input delivery_details_insert_input {
  cost_per_km: money
  delivery_company: delivery_company_arr_rel_insert_input
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  minimum_cost: money

  """in metres"""
  radius: Int
  restaurant: restaurant_restaurant_arr_rel_insert_input
}

"""aggregate max on columns"""
type delivery_details_max_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""
order by max() on columns of table "delivery.details"
"""
input delivery_details_max_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""aggregate min on columns"""
type delivery_details_min_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""
order by min() on columns of table "delivery.details"
"""
input delivery_details_min_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""
response of any mutation on the table "delivery.details"
"""
type delivery_details_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_details!]!
}

"""
input type for inserting object relation for remote table "delivery.details"
"""
input delivery_details_obj_rel_insert_input {
  data: delivery_details_insert_input!

  """upsert condition"""
  on_conflict: delivery_details_on_conflict
}

"""
on_conflict condition type for table "delivery.details"
"""
input delivery_details_on_conflict {
  constraint: delivery_details_constraint!
  update_columns: [delivery_details_update_column!]! = []
  where: delivery_details_bool_exp
}

"""Ordering options when selecting data from "delivery.details"."""
input delivery_details_order_by {
  cost_per_km: order_by
  delivery_company_aggregate: delivery_company_aggregate_order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  laundry: laundry_store_order_by
  minimum_cost: order_by
  radius: order_by
  restaurant_aggregate: restaurant_restaurant_aggregate_order_by
}

"""primary key columns input for table: delivery.details"""
input delivery_details_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery.details"
"""
enum delivery_details_select_column {
  """column name"""
  cost_per_km

  """column name"""
  free_delivery_km_range

  """column name"""
  free_delivery_minimum_cost

  """column name"""
  id

  """column name"""
  minimum_cost

  """column name"""
  radius
}

"""
input type for updating data in table "delivery.details"
"""
input delivery_details_set_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""aggregate stddev on columns"""
type delivery_details_stddev_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by stddev() on columns of table "delivery.details"
"""
input delivery_details_stddev_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_details_stddev_pop_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by stddev_pop() on columns of table "delivery.details"
"""
input delivery_details_stddev_pop_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_details_stddev_samp_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by stddev_samp() on columns of table "delivery.details"
"""
input delivery_details_stddev_samp_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""
Streaming cursor of the table "delivery_details"
"""
input delivery_details_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_details_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_details_stream_cursor_value_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""aggregate sum on columns"""
type delivery_details_sum_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money

  """in metres"""
  radius: Int
}

"""
order by sum() on columns of table "delivery.details"
"""
input delivery_details_sum_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""
update columns of table "delivery.details"
"""
enum delivery_details_update_column {
  """column name"""
  cost_per_km

  """column name"""
  free_delivery_km_range

  """column name"""
  free_delivery_minimum_cost

  """column name"""
  id

  """column name"""
  minimum_cost

  """column name"""
  radius
}

input delivery_details_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_details_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_details_set_input

  """filter the rows which have to be updated"""
  where: delivery_details_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_details_var_pop_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by var_pop() on columns of table "delivery.details"
"""
input delivery_details_var_pop_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""aggregate var_samp on columns"""
type delivery_details_var_samp_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by var_samp() on columns of table "delivery.details"
"""
input delivery_details_var_samp_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""aggregate variance on columns"""
type delivery_details_variance_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float

  """in metres"""
  radius: Float
}

"""
order by variance() on columns of table "delivery.details"
"""
input delivery_details_variance_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by

  """in metres"""
  radius: order_by
}

"""
columns and relationships of "delivery.driver"
"""
type delivery_driver {
  app_type_id: String!
  app_version: String
  current_location: geography

  """An object relationship"""
  delivery_company: delivery_company
  delivery_company_id: Int!

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String!

  """Just for relationship"""
  delivery_driver_type: String!
  id: Int!

  """An object relationship"""
  laundry: laundry_store

  """An object relationship"""
  notification_info: notification_info
  online: Boolean!

  """An object relationship"""
  restaurant: restaurant_restaurant

  """awaiting_approval, authorized, banned"""
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "delivery.driver"
"""
type delivery_driver_aggregate {
  aggregate: delivery_driver_aggregate_fields
  nodes: [delivery_driver!]!
}

input delivery_driver_aggregate_bool_exp {
  bool_and: delivery_driver_aggregate_bool_exp_bool_and
  bool_or: delivery_driver_aggregate_bool_exp_bool_or
  count: delivery_driver_aggregate_bool_exp_count
}

input delivery_driver_aggregate_bool_exp_bool_and {
  arguments: delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_driver_aggregate_bool_exp_bool_or {
  arguments: delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_driver_aggregate_bool_exp_count {
  arguments: [delivery_driver_select_column!]
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery.driver"
"""
type delivery_driver_aggregate_fields {
  avg: delivery_driver_avg_fields
  count(columns: [delivery_driver_select_column!], distinct: Boolean): Int!
  max: delivery_driver_max_fields
  min: delivery_driver_min_fields
  stddev: delivery_driver_stddev_fields
  stddev_pop: delivery_driver_stddev_pop_fields
  stddev_samp: delivery_driver_stddev_samp_fields
  sum: delivery_driver_sum_fields
  var_pop: delivery_driver_var_pop_fields
  var_samp: delivery_driver_var_samp_fields
  variance: delivery_driver_variance_fields
}

"""
order by aggregate values of table "delivery.driver"
"""
input delivery_driver_aggregate_order_by {
  avg: delivery_driver_avg_order_by
  count: order_by
  max: delivery_driver_max_order_by
  min: delivery_driver_min_order_by
  stddev: delivery_driver_stddev_order_by
  stddev_pop: delivery_driver_stddev_pop_order_by
  stddev_samp: delivery_driver_stddev_samp_order_by
  sum: delivery_driver_sum_order_by
  var_pop: delivery_driver_var_pop_order_by
  var_samp: delivery_driver_var_samp_order_by
  variance: delivery_driver_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery.driver"
"""
input delivery_driver_arr_rel_insert_input {
  data: [delivery_driver_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_driver_on_conflict
}

"""aggregate avg on columns"""
type delivery_driver_avg_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "delivery.driver"
"""
input delivery_driver_avg_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "delivery.driver". All fields are combined with a logical 'AND'.
"""
input delivery_driver_bool_exp {
  _and: [delivery_driver_bool_exp!]
  _not: delivery_driver_bool_exp
  _or: [delivery_driver_bool_exp!]
  app_type_id: String_comparison_exp
  app_version: String_comparison_exp
  current_location: geography_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_company_id: Int_comparison_exp
  delivery_company_type: String_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  laundry: laundry_store_bool_exp
  notification_info: notification_info_bool_exp
  online: Boolean_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "delivery.driver"
"""
enum delivery_driver_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  delivery_driver_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  driver_pkey
}

"""
input type for incrementing numeric columns in table "delivery.driver"
"""
input delivery_driver_inc_input {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "delivery.driver"
"""
input delivery_driver_insert_input {
  app_type_id: String
  app_version: String
  current_location: geography
  delivery_company: delivery_company_obj_rel_insert_input
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  notification_info: notification_info_obj_rel_insert_input
  online: Boolean
  restaurant: restaurant_restaurant_obj_rel_insert_input

  """awaiting_approval, authorized, banned"""
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type delivery_driver_max_fields {
  app_type_id: String
  app_version: String
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""
order by max() on columns of table "delivery.driver"
"""
input delivery_driver_max_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_company_id: order_by

  """restaurant,laundry,delivery_company"""
  delivery_company_type: order_by

  """Just for relationship"""
  delivery_driver_type: order_by
  id: order_by

  """awaiting_approval, authorized, banned"""
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type delivery_driver_min_fields {
  app_type_id: String
  app_version: String
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""
order by min() on columns of table "delivery.driver"
"""
input delivery_driver_min_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_company_id: order_by

  """restaurant,laundry,delivery_company"""
  delivery_company_type: order_by

  """Just for relationship"""
  delivery_driver_type: order_by
  id: order_by

  """awaiting_approval, authorized, banned"""
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "delivery.driver"
"""
type delivery_driver_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_driver!]!
}

"""
input type for inserting object relation for remote table "delivery.driver"
"""
input delivery_driver_obj_rel_insert_input {
  data: delivery_driver_insert_input!

  """upsert condition"""
  on_conflict: delivery_driver_on_conflict
}

"""
on_conflict condition type for table "delivery.driver"
"""
input delivery_driver_on_conflict {
  constraint: delivery_driver_constraint!
  update_columns: [delivery_driver_update_column!]! = []
  where: delivery_driver_bool_exp
}

"""Ordering options when selecting data from "delivery.driver"."""
input delivery_driver_order_by {
  app_type_id: order_by
  app_version: order_by
  current_location: order_by
  delivery_company: delivery_company_order_by
  delivery_company_id: order_by
  delivery_company_type: order_by
  delivery_driver_type: order_by
  id: order_by
  laundry: laundry_store_order_by
  notification_info: notification_info_order_by
  online: order_by
  restaurant: restaurant_restaurant_order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: delivery.driver"""
input delivery_driver_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery.driver"
"""
enum delivery_driver_select_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "delivery_driver_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery.driver"
"""
enum delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  online
}

"""
select "delivery_driver_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery.driver"
"""
enum delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  online
}

"""
input type for updating data in table "delivery.driver"
"""
input delivery_driver_set_input {
  app_type_id: String
  app_version: String
  current_location: geography
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  online: Boolean

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type delivery_driver_stddev_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "delivery.driver"
"""
input delivery_driver_stddev_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_driver_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "delivery.driver"
"""
input delivery_driver_stddev_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_driver_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "delivery.driver"
"""
input delivery_driver_stddev_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "delivery_driver"
"""
input delivery_driver_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_driver_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_driver_stream_cursor_value_input {
  app_type_id: String
  app_version: String
  current_location: geography
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  online: Boolean

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type delivery_driver_sum_fields {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
order by sum() on columns of table "delivery.driver"
"""
input delivery_driver_sum_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
update columns of table "delivery.driver"
"""
enum delivery_driver_update_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  status

  """column name"""
  user_id
}

input delivery_driver_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_driver_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_driver_set_input

  """filter the rows which have to be updated"""
  where: delivery_driver_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_driver_var_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "delivery.driver"
"""
input delivery_driver_var_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type delivery_driver_var_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "delivery.driver"
"""
input delivery_driver_var_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type delivery_driver_variance_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "delivery.driver"
"""
input delivery_driver_variance_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

input delivery_get_delivery_companies_args {
  location: geography
}

"""
columns and relationships of "delivery.operator"
"""
type delivery_operator {
  app_type_id: String!
  app_version: String
  current_gps: geography

  """An object relationship"""
  delivery_company: delivery_company!
  delivery_company_id: Int!
  delivery_driver_type: String!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  owner: Boolean!
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "delivery.operator"
"""
type delivery_operator_aggregate {
  aggregate: delivery_operator_aggregate_fields
  nodes: [delivery_operator!]!
}

input delivery_operator_aggregate_bool_exp {
  bool_and: delivery_operator_aggregate_bool_exp_bool_and
  bool_or: delivery_operator_aggregate_bool_exp_bool_or
  count: delivery_operator_aggregate_bool_exp_count
}

input delivery_operator_aggregate_bool_exp_bool_and {
  arguments: delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_operator_aggregate_bool_exp_bool_or {
  arguments: delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_operator_aggregate_bool_exp_count {
  arguments: [delivery_operator_select_column!]
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery.operator"
"""
type delivery_operator_aggregate_fields {
  avg: delivery_operator_avg_fields
  count(columns: [delivery_operator_select_column!], distinct: Boolean): Int!
  max: delivery_operator_max_fields
  min: delivery_operator_min_fields
  stddev: delivery_operator_stddev_fields
  stddev_pop: delivery_operator_stddev_pop_fields
  stddev_samp: delivery_operator_stddev_samp_fields
  sum: delivery_operator_sum_fields
  var_pop: delivery_operator_var_pop_fields
  var_samp: delivery_operator_var_samp_fields
  variance: delivery_operator_variance_fields
}

"""
order by aggregate values of table "delivery.operator"
"""
input delivery_operator_aggregate_order_by {
  avg: delivery_operator_avg_order_by
  count: order_by
  max: delivery_operator_max_order_by
  min: delivery_operator_min_order_by
  stddev: delivery_operator_stddev_order_by
  stddev_pop: delivery_operator_stddev_pop_order_by
  stddev_samp: delivery_operator_stddev_samp_order_by
  sum: delivery_operator_sum_order_by
  var_pop: delivery_operator_var_pop_order_by
  var_samp: delivery_operator_var_samp_order_by
  variance: delivery_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery.operator"
"""
input delivery_operator_arr_rel_insert_input {
  data: [delivery_operator_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_operator_on_conflict
}

"""aggregate avg on columns"""
type delivery_operator_avg_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "delivery.operator"
"""
input delivery_operator_avg_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "delivery.operator". All fields are combined with a logical 'AND'.
"""
input delivery_operator_bool_exp {
  _and: [delivery_operator_bool_exp!]
  _not: delivery_operator_bool_exp
  _or: [delivery_operator_bool_exp!]
  app_type_id: String_comparison_exp
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_company_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  owner: Boolean_comparison_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "delivery.operator"
"""
enum delivery_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_operator_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  delivery_operator_user_id_key
}

"""
input type for incrementing numeric columns in table "delivery.operator"
"""
input delivery_operator_inc_input {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "delivery.operator"
"""
input delivery_operator_insert_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_company: delivery_company_obj_rel_insert_input
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  owner: Boolean
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type delivery_operator_max_fields {
  app_type_id: String
  app_version: String
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  status: String
  user_id: Int
}

"""
order by max() on columns of table "delivery.operator"
"""
input delivery_operator_max_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type delivery_operator_min_fields {
  app_type_id: String
  app_version: String
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  status: String
  user_id: Int
}

"""
order by min() on columns of table "delivery.operator"
"""
input delivery_operator_min_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "delivery.operator"
"""
type delivery_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_operator!]!
}

"""
input type for inserting object relation for remote table "delivery.operator"
"""
input delivery_operator_obj_rel_insert_input {
  data: delivery_operator_insert_input!

  """upsert condition"""
  on_conflict: delivery_operator_on_conflict
}

"""
on_conflict condition type for table "delivery.operator"
"""
input delivery_operator_on_conflict {
  constraint: delivery_operator_constraint!
  update_columns: [delivery_operator_update_column!]! = []
  where: delivery_operator_bool_exp
}

"""Ordering options when selecting data from "delivery.operator"."""
input delivery_operator_order_by {
  app_type_id: order_by
  app_version: order_by
  current_gps: order_by
  delivery_company: delivery_company_order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_info: notification_info_order_by
  owner: order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: delivery.operator"""
input delivery_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery.operator"
"""
enum delivery_operator_select_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_company_id

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "delivery_operator_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery.operator"
"""
enum delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  owner
}

"""
select "delivery_operator_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery.operator"
"""
enum delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  owner
}

"""
input type for updating data in table "delivery.operator"
"""
input delivery_operator_set_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  owner: Boolean
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type delivery_operator_stddev_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "delivery.operator"
"""
input delivery_operator_stddev_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_operator_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "delivery.operator"
"""
input delivery_operator_stddev_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_operator_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "delivery.operator"
"""
input delivery_operator_stddev_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "delivery_operator"
"""
input delivery_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_operator_stream_cursor_value_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  owner: Boolean
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type delivery_operator_sum_fields {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
order by sum() on columns of table "delivery.operator"
"""
input delivery_operator_sum_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
update columns of table "delivery.operator"
"""
enum delivery_operator_update_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_company_id

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  user_id
}

input delivery_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_operator_set_input

  """filter the rows which have to be updated"""
  where: delivery_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_operator_var_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "delivery.operator"
"""
input delivery_operator_var_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type delivery_operator_var_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "delivery.operator"
"""
input delivery_operator_var_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type delivery_operator_variance_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "delivery.operator"
"""
input delivery_operator_variance_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
columns and relationships of "delivery.order"
"""
type delivery_order {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz

  """An object relationship"""
  chat_with_customer: chat!
  chat_with_customer_id: Int!

  """An object relationship"""
  chat_with_service_provider: chat
  chat_with_service_provider_id: Int
  current_gps: geography

  """An object relationship"""
  customer: customer_customer!
  customer_id: Int!

  """An object relationship"""
  customer_review_by_driver: review
  customer_review_by_driver_id: Int

  """An object relationship"""
  delivery_company: delivery_company
  delivery_cost: money!

  """An object relationship"""
  delivery_driver: delivery_driver
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """An object relationship"""
  delivery_operator: delivery_operator

  """to_customer, from_customer"""
  direction: String!

  """An object relationship"""
  driver_review_by_customer: review
  driver_review_by_customer_id: Int

  """An object relationship"""
  driver_review_by_service_provider: review
  driver_review_by_service_provider_id: Int
  dropoff_address: String!
  dropoff_gps: geography!
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int!

  """
  A computed field, executes function "delivery_in_process"
  """
  in_process: Boolean

  """An object relationship"""
  laundry: laundry_store

  """An object relationship"""
  laundry_delivery_order: laundry_order

  """An object relationship"""
  laundry_pickup_order: laundry_order

  """
  A computed field, executes function "delivery_notification_token"
  """
  notification_token: String
  order_time: timestamptz!
  order_type: String!
  package_cost: money!
  package_ready: Boolean!
  payment_type: String!
  pickup_address: String!
  pickup_gps: geography!

  """An object relationship"""
  restaurant: restaurant_restaurant

  """An object relationship"""
  restaurant_operator: restaurant_operator

  """An object relationship"""
  restaurant_order: restaurant_order
  schedule_time: String
  service_provider_id: Int!

  """An object relationship"""
  service_provider_review_by_driver: review
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String!

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String!

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
aggregated selection of "delivery.order"
"""
type delivery_order_aggregate {
  aggregate: delivery_order_aggregate_fields
  nodes: [delivery_order!]!
}

input delivery_order_aggregate_bool_exp {
  bool_and: delivery_order_aggregate_bool_exp_bool_and
  bool_or: delivery_order_aggregate_bool_exp_bool_or
  count: delivery_order_aggregate_bool_exp_count
}

input delivery_order_aggregate_bool_exp_bool_and {
  arguments: delivery_order_select_column_delivery_order_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_order_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_order_aggregate_bool_exp_bool_or {
  arguments: delivery_order_select_column_delivery_order_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_order_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_order_aggregate_bool_exp_count {
  arguments: [delivery_order_select_column!]
  distinct: Boolean
  filter: delivery_order_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery.order"
"""
type delivery_order_aggregate_fields {
  avg: delivery_order_avg_fields
  count(columns: [delivery_order_select_column!], distinct: Boolean): Int!
  max: delivery_order_max_fields
  min: delivery_order_min_fields
  stddev: delivery_order_stddev_fields
  stddev_pop: delivery_order_stddev_pop_fields
  stddev_samp: delivery_order_stddev_samp_fields
  sum: delivery_order_sum_fields
  var_pop: delivery_order_var_pop_fields
  var_samp: delivery_order_var_samp_fields
  variance: delivery_order_variance_fields
}

"""
order by aggregate values of table "delivery.order"
"""
input delivery_order_aggregate_order_by {
  avg: delivery_order_avg_order_by
  count: order_by
  max: delivery_order_max_order_by
  min: delivery_order_min_order_by
  stddev: delivery_order_stddev_order_by
  stddev_pop: delivery_order_stddev_pop_order_by
  stddev_samp: delivery_order_stddev_samp_order_by
  sum: delivery_order_sum_order_by
  var_pop: delivery_order_var_pop_order_by
  var_samp: delivery_order_var_samp_order_by
  variance: delivery_order_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery.order"
"""
input delivery_order_arr_rel_insert_input {
  data: [delivery_order_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_order_on_conflict
}

"""aggregate avg on columns"""
type delivery_order_avg_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by avg() on columns of table "delivery.order"
"""
input delivery_order_avg_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Boolean expression to filter rows from the table "delivery.order". All fields are combined with a logical 'AND'.
"""
input delivery_order_bool_exp {
  _and: [delivery_order_bool_exp!]
  _not: delivery_order_bool_exp
  _or: [delivery_order_bool_exp!]
  actual_arrival_at_dropoff_time: timestamptz_comparison_exp
  actual_arrival_at_pickup_time: timestamptz_comparison_exp
  actual_delivered_time: timestamptz_comparison_exp
  actual_package_ready_time: timestamptz_comparison_exp
  cancellation_time: timestamptz_comparison_exp
  chat_with_customer: chat_bool_exp
  chat_with_customer_id: Int_comparison_exp
  chat_with_service_provider: chat_bool_exp
  chat_with_service_provider_id: Int_comparison_exp
  current_gps: geography_comparison_exp
  customer: customer_customer_bool_exp
  customer_id: Int_comparison_exp
  customer_review_by_driver: review_bool_exp
  customer_review_by_driver_id: Int_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_cost: money_comparison_exp
  delivery_driver: delivery_driver_bool_exp
  delivery_driver_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  delivery_operator: delivery_operator_bool_exp
  direction: String_comparison_exp
  driver_review_by_customer: review_bool_exp
  driver_review_by_customer_id: Int_comparison_exp
  driver_review_by_service_provider: review_bool_exp
  driver_review_by_service_provider_id: Int_comparison_exp
  dropoff_address: String_comparison_exp
  dropoff_gps: geography_comparison_exp
  estimated_arrival_at_dropoff_time: timestamptz_comparison_exp
  estimated_arrival_at_pickup_time: timestamptz_comparison_exp
  estimated_package_ready_time: timestamptz_comparison_exp
  id: Int_comparison_exp
  in_process: Boolean_comparison_exp
  laundry: laundry_store_bool_exp
  laundry_delivery_order: laundry_order_bool_exp
  laundry_pickup_order: laundry_order_bool_exp
  notification_token: String_comparison_exp
  order_time: timestamptz_comparison_exp
  order_type: String_comparison_exp
  package_cost: money_comparison_exp
  package_ready: Boolean_comparison_exp
  payment_type: String_comparison_exp
  pickup_address: String_comparison_exp
  pickup_gps: geography_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_operator: restaurant_operator_bool_exp
  restaurant_order: restaurant_order_bool_exp
  schedule_time: String_comparison_exp
  service_provider_id: Int_comparison_exp
  service_provider_review_by_driver: review_bool_exp
  service_provider_review_by_driver_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  status: String_comparison_exp
  trip_distance: Int_comparison_exp
  trip_duration: Int_comparison_exp
  trip_polyline: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery.order"
"""
enum delivery_order_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_pkey
}

"""
input type for incrementing numeric columns in table "delivery.order"
"""
input delivery_order_inc_input {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
input type for inserting data into table "delivery.order"
"""
input delivery_order_insert_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer: chat_obj_rel_insert_input
  chat_with_customer_id: Int
  chat_with_service_provider: chat_obj_rel_insert_input
  chat_with_service_provider_id: Int
  current_gps: geography
  customer: customer_customer_obj_rel_insert_input
  customer_id: Int
  customer_review_by_driver: review_obj_rel_insert_input
  customer_review_by_driver_id: Int
  delivery_company: delivery_company_obj_rel_insert_input
  delivery_cost: money
  delivery_driver: delivery_driver_obj_rel_insert_input
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String
  delivery_operator: delivery_operator_obj_rel_insert_input

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer: review_obj_rel_insert_input
  driver_review_by_customer_id: Int
  driver_review_by_service_provider: review_obj_rel_insert_input
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  laundry_delivery_order: laundry_order_obj_rel_insert_input
  laundry_pickup_order: laundry_order_obj_rel_insert_input
  order_time: timestamptz
  order_type: String
  package_cost: money
  package_ready: Boolean
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_operator: restaurant_operator_obj_rel_insert_input
  restaurant_order: restaurant_order_obj_rel_insert_input
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver: review_obj_rel_insert_input
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate max on columns"""
type delivery_order_max_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by max() on columns of table "delivery.order"
"""
input delivery_order_max_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: order_by

  """to_customer, from_customer"""
  direction: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """restaurant, delivery_company"""
  service_provider_type: order_by

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""aggregate min on columns"""
type delivery_order_min_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by min() on columns of table "delivery.order"
"""
input delivery_order_min_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: order_by

  """to_customer, from_customer"""
  direction: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """restaurant, delivery_company"""
  service_provider_type: order_by

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""
response of any mutation on the table "delivery.order"
"""
type delivery_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_order!]!
}

"""
input type for inserting object relation for remote table "delivery.order"
"""
input delivery_order_obj_rel_insert_input {
  data: delivery_order_insert_input!

  """upsert condition"""
  on_conflict: delivery_order_on_conflict
}

"""
on_conflict condition type for table "delivery.order"
"""
input delivery_order_on_conflict {
  constraint: delivery_order_constraint!
  update_columns: [delivery_order_update_column!]! = []
  where: delivery_order_bool_exp
}

"""Ordering options when selecting data from "delivery.order"."""
input delivery_order_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer: chat_order_by
  chat_with_customer_id: order_by
  chat_with_service_provider: chat_order_by
  chat_with_service_provider_id: order_by
  current_gps: order_by
  customer: customer_customer_order_by
  customer_id: order_by
  customer_review_by_driver: review_order_by
  customer_review_by_driver_id: order_by
  delivery_company: delivery_company_order_by
  delivery_cost: order_by
  delivery_driver: delivery_driver_order_by
  delivery_driver_id: order_by
  delivery_driver_type: order_by
  delivery_operator: delivery_operator_order_by
  direction: order_by
  driver_review_by_customer: review_order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider: review_order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  dropoff_gps: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  in_process: order_by
  laundry: laundry_store_order_by
  laundry_delivery_order: laundry_order_order_by
  laundry_pickup_order: laundry_order_order_by
  notification_token: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  package_ready: order_by
  payment_type: order_by
  pickup_address: order_by
  pickup_gps: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_operator: restaurant_operator_order_by
  restaurant_order: restaurant_order_order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver: review_order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by
  status: order_by
  trip_distance: order_by
  trip_duration: order_by
  trip_polyline: order_by
}

"""primary key columns input for table: delivery.order"""
input delivery_order_pk_columns_input {
  id: Int!
}

"""
columns and relationships of "delivery.order_public"
"""
type delivery_order_public {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""
aggregated selection of "delivery.order_public"
"""
type delivery_order_public_aggregate {
  aggregate: delivery_order_public_aggregate_fields
  nodes: [delivery_order_public!]!
}

"""
aggregate fields of "delivery.order_public"
"""
type delivery_order_public_aggregate_fields {
  avg: delivery_order_public_avg_fields
  count(columns: [delivery_order_public_select_column!], distinct: Boolean): Int!
  max: delivery_order_public_max_fields
  min: delivery_order_public_min_fields
  stddev: delivery_order_public_stddev_fields
  stddev_pop: delivery_order_public_stddev_pop_fields
  stddev_samp: delivery_order_public_stddev_samp_fields
  sum: delivery_order_public_sum_fields
  var_pop: delivery_order_public_var_pop_fields
  var_samp: delivery_order_public_var_samp_fields
  variance: delivery_order_public_variance_fields
}

"""aggregate avg on columns"""
type delivery_order_public_avg_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
Boolean expression to filter rows from the table "delivery.order_public". All fields are combined with a logical 'AND'.
"""
input delivery_order_public_bool_exp {
  _and: [delivery_order_public_bool_exp!]
  _not: delivery_order_public_bool_exp
  _or: [delivery_order_public_bool_exp!]
  actual_arrival_at_dropoff_time: timestamptz_comparison_exp
  actual_arrival_at_pickup_time: timestamptz_comparison_exp
  actual_delivered_time: timestamptz_comparison_exp
  actual_package_ready_time: timestamptz_comparison_exp
  customer_id: Int_comparison_exp
  customer_review_by_driver_id: Int_comparison_exp
  delivery_driver_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  driver_review_by_customer_id: Int_comparison_exp
  driver_review_by_service_provider_id: Int_comparison_exp
  estimated_arrival_at_dropoff_time: timestamptz_comparison_exp
  estimated_arrival_at_pickup_time: timestamptz_comparison_exp
  estimated_package_ready_time: timestamptz_comparison_exp
  order_time: timestamptz_comparison_exp
  service_provider_id: Int_comparison_exp
  service_provider_review_by_driver_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  status: String_comparison_exp
  trip_distance: Int_comparison_exp
  trip_duration: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "delivery.order_public"
"""
input delivery_order_public_inc_input {
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  trip_distance: Int
  trip_duration: Int
}

"""
input type for inserting data into table "delivery.order_public"
"""
input delivery_order_public_insert_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate max on columns"""
type delivery_order_public_max_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate min on columns"""
type delivery_order_public_min_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""
response of any mutation on the table "delivery.order_public"
"""
type delivery_order_public_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_order_public!]!
}

"""Ordering options when selecting data from "delivery.order_public"."""
input delivery_order_public_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_driver_id: order_by
  delivery_driver_type: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  order_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by
  status: order_by
  trip_distance: order_by
  trip_duration: order_by
}

"""
select columns of table "delivery.order_public"
"""
enum delivery_order_public_select_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  order_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  trip_distance

  """column name"""
  trip_duration
}

"""
input type for updating data in table "delivery.order_public"
"""
input delivery_order_public_set_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate stddev on columns"""
type delivery_order_public_stddev_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate stddev_pop on columns"""
type delivery_order_public_stddev_pop_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate stddev_samp on columns"""
type delivery_order_public_stddev_samp_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
Streaming cursor of the table "delivery_order_public"
"""
input delivery_order_public_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_order_public_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_order_public_stream_cursor_value_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate sum on columns"""
type delivery_order_public_sum_fields {
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  trip_distance: Int
  trip_duration: Int
}

input delivery_order_public_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_order_public_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_order_public_set_input

  """filter the rows which have to be updated"""
  where: delivery_order_public_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_order_public_var_pop_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate var_samp on columns"""
type delivery_order_public_var_samp_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate variance on columns"""
type delivery_order_public_variance_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
select columns of table "delivery.order"
"""
enum delivery_order_select_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  direction

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  package_cost

  """column name"""
  package_ready

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  schedule_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

"""
select "delivery_order_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery.order"
"""
enum delivery_order_select_column_delivery_order_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  package_ready
}

"""
select "delivery_order_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery.order"
"""
enum delivery_order_select_column_delivery_order_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  package_ready
}

"""
input type for updating data in table "delivery.order"
"""
input delivery_order_set_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  package_ready: Boolean
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate stddev on columns"""
type delivery_order_stddev_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev() on columns of table "delivery.order"
"""
input delivery_order_stddev_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_order_stddev_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_pop() on columns of table "delivery.order"
"""
input delivery_order_stddev_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_order_stddev_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_samp() on columns of table "delivery.order"
"""
input delivery_order_stddev_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Streaming cursor of the table "delivery_order"
"""
input delivery_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_order_stream_cursor_value_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  package_ready: Boolean
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate sum on columns"""
type delivery_order_sum_fields {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
order by sum() on columns of table "delivery.order"
"""
input delivery_order_sum_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
update columns of table "delivery.order"
"""
enum delivery_order_update_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  direction

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  package_cost

  """column name"""
  package_ready

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  schedule_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

input delivery_order_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_order_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_order_set_input

  """filter the rows which have to be updated"""
  where: delivery_order_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_order_var_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_pop() on columns of table "delivery.order"
"""
input delivery_order_var_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate var_samp on columns"""
type delivery_order_var_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_samp() on columns of table "delivery.order"
"""
input delivery_order_var_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate variance on columns"""
type delivery_order_variance_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by variance() on columns of table "delivery.order"
"""
input delivery_order_variance_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
columns and relationships of "direct_chat"
"""
type direct_chat {
  """An object relationship"""
  chat: chat
  chat_id: Int!

  """An object relationship"""
  user1: user

  """An object relationship"""
  user2: user
  user_id1: Int!
  user_id2: Int!
}

"""
aggregated selection of "direct_chat"
"""
type direct_chat_aggregate {
  aggregate: direct_chat_aggregate_fields
  nodes: [direct_chat!]!
}

"""
aggregate fields of "direct_chat"
"""
type direct_chat_aggregate_fields {
  avg: direct_chat_avg_fields
  count(columns: [direct_chat_select_column!], distinct: Boolean): Int!
  max: direct_chat_max_fields
  min: direct_chat_min_fields
  stddev: direct_chat_stddev_fields
  stddev_pop: direct_chat_stddev_pop_fields
  stddev_samp: direct_chat_stddev_samp_fields
  sum: direct_chat_sum_fields
  var_pop: direct_chat_var_pop_fields
  var_samp: direct_chat_var_samp_fields
  variance: direct_chat_variance_fields
}

"""aggregate avg on columns"""
type direct_chat_avg_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""
Boolean expression to filter rows from the table "direct_chat". All fields are combined with a logical 'AND'.
"""
input direct_chat_bool_exp {
  _and: [direct_chat_bool_exp!]
  _not: direct_chat_bool_exp
  _or: [direct_chat_bool_exp!]
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  user1: user_bool_exp
  user2: user_bool_exp
  user_id1: Int_comparison_exp
  user_id2: Int_comparison_exp
}

"""
unique or primary key constraints on table "direct_chat"
"""
enum direct_chat_constraint {
  """
  unique or primary key constraint on columns "chat_id"
  """
  direct_chat_pkey

  """
  unique or primary key constraint on columns "user_id1", "user_id2"
  """
  direct_chat_user_id_1_user_id_2_key
}

"""
input type for incrementing numeric columns in table "direct_chat"
"""
input direct_chat_inc_input {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""
input type for inserting data into table "direct_chat"
"""
input direct_chat_insert_input {
  chat: chat_obj_rel_insert_input
  chat_id: Int
  user1: user_obj_rel_insert_input
  user2: user_obj_rel_insert_input
  user_id1: Int
  user_id2: Int
}

"""aggregate max on columns"""
type direct_chat_max_fields {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""aggregate min on columns"""
type direct_chat_min_fields {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""
response of any mutation on the table "direct_chat"
"""
type direct_chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [direct_chat!]!
}

"""
on_conflict condition type for table "direct_chat"
"""
input direct_chat_on_conflict {
  constraint: direct_chat_constraint!
  update_columns: [direct_chat_update_column!]! = []
  where: direct_chat_bool_exp
}

"""Ordering options when selecting data from "direct_chat"."""
input direct_chat_order_by {
  chat: chat_order_by
  chat_id: order_by
  user1: user_order_by
  user2: user_order_by
  user_id1: order_by
  user_id2: order_by
}

"""primary key columns input for table: direct_chat"""
input direct_chat_pk_columns_input {
  chat_id: Int!
}

"""
select columns of table "direct_chat"
"""
enum direct_chat_select_column {
  """column name"""
  chat_id

  """column name"""
  user_id1

  """column name"""
  user_id2
}

"""
input type for updating data in table "direct_chat"
"""
input direct_chat_set_input {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""aggregate stddev on columns"""
type direct_chat_stddev_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""aggregate stddev_pop on columns"""
type direct_chat_stddev_pop_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""aggregate stddev_samp on columns"""
type direct_chat_stddev_samp_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""
Streaming cursor of the table "direct_chat"
"""
input direct_chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: direct_chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input direct_chat_stream_cursor_value_input {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""aggregate sum on columns"""
type direct_chat_sum_fields {
  chat_id: Int
  user_id1: Int
  user_id2: Int
}

"""
update columns of table "direct_chat"
"""
enum direct_chat_update_column {
  """column name"""
  chat_id

  """column name"""
  user_id1

  """column name"""
  user_id2
}

input direct_chat_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: direct_chat_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: direct_chat_set_input

  """filter the rows which have to be updated"""
  where: direct_chat_bool_exp!
}

"""aggregate var_pop on columns"""
type direct_chat_var_pop_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""aggregate var_samp on columns"""
type direct_chat_var_samp_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""aggregate variance on columns"""
type direct_chat_variance_fields {
  chat_id: Float
  user_id1: Float
  user_id2: Float
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "language"
"""
type language {
  id: String!
}

"""
aggregated selection of "language"
"""
type language_aggregate {
  aggregate: language_aggregate_fields
  nodes: [language!]!
}

"""
aggregate fields of "language"
"""
type language_aggregate_fields {
  count(columns: [language_select_column!], distinct: Boolean): Int!
  max: language_max_fields
  min: language_min_fields
}

"""
Boolean expression to filter rows from the table "language". All fields are combined with a logical 'AND'.
"""
input language_bool_exp {
  _and: [language_bool_exp!]
  _not: language_bool_exp
  _or: [language_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "language"
"""
enum language_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  language_pkey
}

"""
input type for inserting data into table "language"
"""
input language_insert_input {
  id: String
}

"""aggregate max on columns"""
type language_max_fields {
  id: String
}

"""aggregate min on columns"""
type language_min_fields {
  id: String
}

"""
response of any mutation on the table "language"
"""
type language_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [language!]!
}

"""
input type for inserting object relation for remote table "language"
"""
input language_obj_rel_insert_input {
  data: language_insert_input!

  """upsert condition"""
  on_conflict: language_on_conflict
}

"""
on_conflict condition type for table "language"
"""
input language_on_conflict {
  constraint: language_constraint!
  update_columns: [language_update_column!]! = []
  where: language_bool_exp
}

"""Ordering options when selecting data from "language"."""
input language_order_by {
  id: order_by
}

"""primary key columns input for table: language"""
input language_pk_columns_input {
  id: String!
}

"""
select columns of table "language"
"""
enum language_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "language"
"""
input language_set_input {
  id: String
}

"""
Streaming cursor of the table "language"
"""
input language_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: language_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input language_stream_cursor_value_input {
  id: String
}

"""
update columns of table "language"
"""
enum language_update_column {
  """column name"""
  id
}

input language_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: language_set_input

  """filter the rows which have to be updated"""
  where: language_bool_exp!
}

"""
columns and relationships of "laundry.category"
"""
type laundry_category {
  cost_by_kilo: money!
  id: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!
  position: Int!

  """An object relationship"""
  store: laundry_store!
  store_id: Int!
}

"""
aggregated selection of "laundry.category"
"""
type laundry_category_aggregate {
  aggregate: laundry_category_aggregate_fields
  nodes: [laundry_category!]!
}

"""
aggregate fields of "laundry.category"
"""
type laundry_category_aggregate_fields {
  avg: laundry_category_avg_fields
  count(columns: [laundry_category_select_column!], distinct: Boolean): Int!
  max: laundry_category_max_fields
  min: laundry_category_min_fields
  stddev: laundry_category_stddev_fields
  stddev_pop: laundry_category_stddev_pop_fields
  stddev_samp: laundry_category_stddev_samp_fields
  sum: laundry_category_sum_fields
  var_pop: laundry_category_var_pop_fields
  var_samp: laundry_category_var_samp_fields
  variance: laundry_category_variance_fields
}

"""aggregate avg on columns"""
type laundry_category_avg_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""
Boolean expression to filter rows from the table "laundry.category". All fields are combined with a logical 'AND'.
"""
input laundry_category_bool_exp {
  _and: [laundry_category_bool_exp!]
  _not: laundry_category_bool_exp
  _or: [laundry_category_bool_exp!]
  cost_by_kilo: money_comparison_exp
  id: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  position: Int_comparison_exp
  store: laundry_store_bool_exp
  store_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "laundry.category"
"""
enum laundry_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  type_pkey
}

"""
input type for incrementing numeric columns in table "laundry.category"
"""
input laundry_category_inc_input {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""
input type for inserting data into table "laundry.category"
"""
input laundry_category_insert_input {
  cost_by_kilo: money
  id: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  position: Int
  store: laundry_store_obj_rel_insert_input
  store_id: Int
}

"""aggregate max on columns"""
type laundry_category_max_fields {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""aggregate min on columns"""
type laundry_category_min_fields {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""
response of any mutation on the table "laundry.category"
"""
type laundry_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [laundry_category!]!
}

"""
input type for inserting object relation for remote table "laundry.category"
"""
input laundry_category_obj_rel_insert_input {
  data: laundry_category_insert_input!

  """upsert condition"""
  on_conflict: laundry_category_on_conflict
}

"""
on_conflict condition type for table "laundry.category"
"""
input laundry_category_on_conflict {
  constraint: laundry_category_constraint!
  update_columns: [laundry_category_update_column!]! = []
  where: laundry_category_bool_exp
}

"""Ordering options when selecting data from "laundry.category"."""
input laundry_category_order_by {
  cost_by_kilo: order_by
  id: order_by
  name: translation_order_by
  name_id: order_by
  position: order_by
  store: laundry_store_order_by
  store_id: order_by
}

"""primary key columns input for table: laundry.category"""
input laundry_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "laundry.category"
"""
enum laundry_category_select_column {
  """column name"""
  cost_by_kilo

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  store_id
}

"""
input type for updating data in table "laundry.category"
"""
input laundry_category_set_input {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""aggregate stddev on columns"""
type laundry_category_stddev_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""aggregate stddev_pop on columns"""
type laundry_category_stddev_pop_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""aggregate stddev_samp on columns"""
type laundry_category_stddev_samp_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""
Streaming cursor of the table "laundry_category"
"""
input laundry_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: laundry_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input laundry_category_stream_cursor_value_input {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""aggregate sum on columns"""
type laundry_category_sum_fields {
  cost_by_kilo: money
  id: Int
  name_id: Int
  position: Int
  store_id: Int
}

"""
update columns of table "laundry.category"
"""
enum laundry_category_update_column {
  """column name"""
  cost_by_kilo

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  store_id
}

input laundry_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: laundry_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: laundry_category_set_input

  """filter the rows which have to be updated"""
  where: laundry_category_bool_exp!
}

"""aggregate var_pop on columns"""
type laundry_category_var_pop_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""aggregate var_samp on columns"""
type laundry_category_var_samp_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""aggregate variance on columns"""
type laundry_category_variance_fields {
  cost_by_kilo: Float
  id: Float
  name_id: Float
  position: Float
  store_id: Float
}

"""
columns and relationships of "laundry.operator"
"""
type laundry_operator {
  app_type_id: String!
  app_version: String
  current_gps: geography
  delivery_driver_type: String!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  online: Boolean!
  owner: Boolean!
  status: String!

  """An object relationship"""
  store: laundry_store!
  store_id: Int!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "laundry.operator"
"""
type laundry_operator_aggregate {
  aggregate: laundry_operator_aggregate_fields
  nodes: [laundry_operator!]!
}

input laundry_operator_aggregate_bool_exp {
  bool_and: laundry_operator_aggregate_bool_exp_bool_and
  bool_or: laundry_operator_aggregate_bool_exp_bool_or
  count: laundry_operator_aggregate_bool_exp_count
}

input laundry_operator_aggregate_bool_exp_bool_and {
  arguments: laundry_operator_select_column_laundry_operator_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: laundry_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input laundry_operator_aggregate_bool_exp_bool_or {
  arguments: laundry_operator_select_column_laundry_operator_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: laundry_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input laundry_operator_aggregate_bool_exp_count {
  arguments: [laundry_operator_select_column!]
  distinct: Boolean
  filter: laundry_operator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "laundry.operator"
"""
type laundry_operator_aggregate_fields {
  avg: laundry_operator_avg_fields
  count(columns: [laundry_operator_select_column!], distinct: Boolean): Int!
  max: laundry_operator_max_fields
  min: laundry_operator_min_fields
  stddev: laundry_operator_stddev_fields
  stddev_pop: laundry_operator_stddev_pop_fields
  stddev_samp: laundry_operator_stddev_samp_fields
  sum: laundry_operator_sum_fields
  var_pop: laundry_operator_var_pop_fields
  var_samp: laundry_operator_var_samp_fields
  variance: laundry_operator_variance_fields
}

"""
order by aggregate values of table "laundry.operator"
"""
input laundry_operator_aggregate_order_by {
  avg: laundry_operator_avg_order_by
  count: order_by
  max: laundry_operator_max_order_by
  min: laundry_operator_min_order_by
  stddev: laundry_operator_stddev_order_by
  stddev_pop: laundry_operator_stddev_pop_order_by
  stddev_samp: laundry_operator_stddev_samp_order_by
  sum: laundry_operator_sum_order_by
  var_pop: laundry_operator_var_pop_order_by
  var_samp: laundry_operator_var_samp_order_by
  variance: laundry_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "laundry.operator"
"""
input laundry_operator_arr_rel_insert_input {
  data: [laundry_operator_insert_input!]!

  """upsert condition"""
  on_conflict: laundry_operator_on_conflict
}

"""aggregate avg on columns"""
type laundry_operator_avg_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "laundry.operator"
"""
input laundry_operator_avg_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "laundry.operator". All fields are combined with a logical 'AND'.
"""
input laundry_operator_bool_exp {
  _and: [laundry_operator_bool_exp!]
  _not: laundry_operator_bool_exp
  _or: [laundry_operator_bool_exp!]
  app_type_id: String_comparison_exp
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  online: Boolean_comparison_exp
  owner: Boolean_comparison_exp
  status: String_comparison_exp
  store: laundry_store_bool_exp
  store_id: Int_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "laundry.operator"
"""
enum laundry_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  operator_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  operator_user_id_key
}

"""
input type for incrementing numeric columns in table "laundry.operator"
"""
input laundry_operator_inc_input {
  id: Int
  store_id: Int
  user_id: Int
}

"""
input type for inserting data into table "laundry.operator"
"""
input laundry_operator_insert_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  online: Boolean
  owner: Boolean
  status: String
  store: laundry_store_obj_rel_insert_input
  store_id: Int
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type laundry_operator_max_fields {
  app_type_id: String
  app_version: String
  delivery_driver_type: String
  id: Int
  status: String
  store_id: Int
  user_id: Int
}

"""
order by max() on columns of table "laundry.operator"
"""
input laundry_operator_max_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  store_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type laundry_operator_min_fields {
  app_type_id: String
  app_version: String
  delivery_driver_type: String
  id: Int
  status: String
  store_id: Int
  user_id: Int
}

"""
order by min() on columns of table "laundry.operator"
"""
input laundry_operator_min_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  store_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "laundry.operator"
"""
type laundry_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [laundry_operator!]!
}

"""
on_conflict condition type for table "laundry.operator"
"""
input laundry_operator_on_conflict {
  constraint: laundry_operator_constraint!
  update_columns: [laundry_operator_update_column!]! = []
  where: laundry_operator_bool_exp
}

"""Ordering options when selecting data from "laundry.operator"."""
input laundry_operator_order_by {
  app_type_id: order_by
  app_version: order_by
  current_gps: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_info: notification_info_order_by
  online: order_by
  owner: order_by
  status: order_by
  store: laundry_store_order_by
  store_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: laundry.operator"""
input laundry_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "laundry.operator"
"""
enum laundry_operator_select_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  store_id

  """column name"""
  user_id
}

"""
select "laundry_operator_aggregate_bool_exp_bool_and_arguments_columns" columns of table "laundry.operator"
"""
enum laundry_operator_select_column_laundry_operator_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  online

  """column name"""
  owner
}

"""
select "laundry_operator_aggregate_bool_exp_bool_or_arguments_columns" columns of table "laundry.operator"
"""
enum laundry_operator_select_column_laundry_operator_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  online

  """column name"""
  owner
}

"""
input type for updating data in table "laundry.operator"
"""
input laundry_operator_set_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  online: Boolean
  owner: Boolean
  status: String
  store_id: Int
  user_id: Int
}

"""aggregate stddev on columns"""
type laundry_operator_stddev_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "laundry.operator"
"""
input laundry_operator_stddev_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type laundry_operator_stddev_pop_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "laundry.operator"
"""
input laundry_operator_stddev_pop_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type laundry_operator_stddev_samp_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "laundry.operator"
"""
input laundry_operator_stddev_samp_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "laundry_operator"
"""
input laundry_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: laundry_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input laundry_operator_stream_cursor_value_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  online: Boolean
  owner: Boolean
  status: String
  store_id: Int
  user_id: Int
}

"""aggregate sum on columns"""
type laundry_operator_sum_fields {
  id: Int
  store_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "laundry.operator"
"""
input laundry_operator_sum_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""
update columns of table "laundry.operator"
"""
enum laundry_operator_update_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  store_id

  """column name"""
  user_id
}

input laundry_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: laundry_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: laundry_operator_set_input

  """filter the rows which have to be updated"""
  where: laundry_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type laundry_operator_var_pop_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "laundry.operator"
"""
input laundry_operator_var_pop_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type laundry_operator_var_samp_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "laundry.operator"
"""
input laundry_operator_var_samp_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type laundry_operator_variance_fields {
  id: Float
  store_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "laundry.operator"
"""
input laundry_operator_variance_order_by {
  id: order_by
  store_id: order_by
  user_id: order_by
}

"""
columns and relationships of "laundry.order"
"""
type laundry_order {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): [laundry_order_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): laundry_order_category_aggregate!

  """An object relationship"""
  chat: chat
  chat_id: Int

  """An object relationship"""
  customer: customer_customer!
  customer_address: String
  customer_app_type: String!
  customer_id: Int!
  customer_location_gps: geography
  delivery_cost: money!
  delivery_type: String!
  discount_value: money!
  estimated_ready_time: timestamptz
  firebase_id: String

  """An object relationship"""
  from_customer_delivery: delivery_order
  from_customer_delivery_id: Int
  id: Int!

  """
  A computed field, executes function "laundry.order_in_process"
  """
  in_process: Boolean

  """
  A computed field, executes function "laundry.itemscost"
  """
  items_cost: money
  notes: String
  order_time: timestamptz!
  payment_type: String!
  refund_amount: money!

  """An object relationship"""
  review: review
  review_id: Int
  scheduled_time: timestamptz
  status: String!

  """An object relationship"""
  store: laundry_store!
  store_id: Int!
  stripe_fees: money!
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
  tax: money!

  """An object relationship"""
  to_customer_delivery: delivery_order
  to_customer_delivery_id: Int

  """
  A computed field, executes function "laundry.totalcost"
  """
  total_cost: money
}

"""
aggregated selection of "laundry.order"
"""
type laundry_order_aggregate {
  aggregate: laundry_order_aggregate_fields
  nodes: [laundry_order!]!
}

"""
aggregate fields of "laundry.order"
"""
type laundry_order_aggregate_fields {
  avg: laundry_order_avg_fields
  count(columns: [laundry_order_select_column!], distinct: Boolean): Int!
  max: laundry_order_max_fields
  min: laundry_order_min_fields
  stddev: laundry_order_stddev_fields
  stddev_pop: laundry_order_stddev_pop_fields
  stddev_samp: laundry_order_stddev_samp_fields
  sum: laundry_order_sum_fields
  var_pop: laundry_order_var_pop_fields
  var_samp: laundry_order_var_samp_fields
  variance: laundry_order_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input laundry_order_append_input {
  stripe_info: jsonb
}

"""aggregate avg on columns"""
type laundry_order_avg_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""
Boolean expression to filter rows from the table "laundry.order". All fields are combined with a logical 'AND'.
"""
input laundry_order_bool_exp {
  _and: [laundry_order_bool_exp!]
  _not: laundry_order_bool_exp
  _or: [laundry_order_bool_exp!]
  actual_ready_time: timestamptz_comparison_exp
  cancellation_time: timestamptz_comparison_exp
  categories: laundry_order_category_bool_exp
  categories_aggregate: laundry_order_category_aggregate_bool_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  customer: customer_customer_bool_exp
  customer_address: String_comparison_exp
  customer_app_type: String_comparison_exp
  customer_id: Int_comparison_exp
  customer_location_gps: geography_comparison_exp
  delivery_cost: money_comparison_exp
  delivery_type: String_comparison_exp
  discount_value: money_comparison_exp
  estimated_ready_time: timestamptz_comparison_exp
  firebase_id: String_comparison_exp
  from_customer_delivery: delivery_order_bool_exp
  from_customer_delivery_id: Int_comparison_exp
  id: Int_comparison_exp
  in_process: Boolean_comparison_exp
  items_cost: money_comparison_exp
  notes: String_comparison_exp
  order_time: timestamptz_comparison_exp
  payment_type: String_comparison_exp
  refund_amount: money_comparison_exp
  review: review_bool_exp
  review_id: Int_comparison_exp
  scheduled_time: timestamptz_comparison_exp
  status: String_comparison_exp
  store: laundry_store_bool_exp
  store_id: Int_comparison_exp
  stripe_fees: money_comparison_exp
  stripe_info: jsonb_comparison_exp
  tax: money_comparison_exp
  to_customer_delivery: delivery_order_bool_exp
  to_customer_delivery_id: Int_comparison_exp
  total_cost: money_comparison_exp
}

"""
columns and relationships of "laundry.order_category"
"""
type laundry_order_category {
  """An object relationship"""
  category: laundry_category!
  category_id: Int!
  id: Int!

  """An object relationship"""
  order: laundry_order!
  order_id: Int!
  weight_in_kilo: float8
}

"""
aggregated selection of "laundry.order_category"
"""
type laundry_order_category_aggregate {
  aggregate: laundry_order_category_aggregate_fields
  nodes: [laundry_order_category!]!
}

input laundry_order_category_aggregate_bool_exp {
  avg: laundry_order_category_aggregate_bool_exp_avg
  corr: laundry_order_category_aggregate_bool_exp_corr
  count: laundry_order_category_aggregate_bool_exp_count
  covar_samp: laundry_order_category_aggregate_bool_exp_covar_samp
  max: laundry_order_category_aggregate_bool_exp_max
  min: laundry_order_category_aggregate_bool_exp_min
  stddev_samp: laundry_order_category_aggregate_bool_exp_stddev_samp
  sum: laundry_order_category_aggregate_bool_exp_sum
  var_samp: laundry_order_category_aggregate_bool_exp_var_samp
}

input laundry_order_category_aggregate_bool_exp_avg {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_corr {
  arguments: laundry_order_category_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_corr_arguments {
  X: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_corr_arguments_columns!
  Y: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_corr_arguments_columns!
}

input laundry_order_category_aggregate_bool_exp_count {
  arguments: [laundry_order_category_select_column!]
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: Int_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_covar_samp {
  arguments: laundry_order_category_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_covar_samp_arguments {
  X: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_covar_samp_arguments_columns!
}

input laundry_order_category_aggregate_bool_exp_max {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_min {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_stddev_samp {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_sum {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

input laundry_order_category_aggregate_bool_exp_var_samp {
  arguments: laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: laundry_order_category_bool_exp
  predicate: float8_comparison_exp!
}

"""
aggregate fields of "laundry.order_category"
"""
type laundry_order_category_aggregate_fields {
  avg: laundry_order_category_avg_fields
  count(columns: [laundry_order_category_select_column!], distinct: Boolean): Int!
  max: laundry_order_category_max_fields
  min: laundry_order_category_min_fields
  stddev: laundry_order_category_stddev_fields
  stddev_pop: laundry_order_category_stddev_pop_fields
  stddev_samp: laundry_order_category_stddev_samp_fields
  sum: laundry_order_category_sum_fields
  var_pop: laundry_order_category_var_pop_fields
  var_samp: laundry_order_category_var_samp_fields
  variance: laundry_order_category_variance_fields
}

"""
order by aggregate values of table "laundry.order_category"
"""
input laundry_order_category_aggregate_order_by {
  avg: laundry_order_category_avg_order_by
  count: order_by
  max: laundry_order_category_max_order_by
  min: laundry_order_category_min_order_by
  stddev: laundry_order_category_stddev_order_by
  stddev_pop: laundry_order_category_stddev_pop_order_by
  stddev_samp: laundry_order_category_stddev_samp_order_by
  sum: laundry_order_category_sum_order_by
  var_pop: laundry_order_category_var_pop_order_by
  var_samp: laundry_order_category_var_samp_order_by
  variance: laundry_order_category_variance_order_by
}

"""
input type for inserting array relation for remote table "laundry.order_category"
"""
input laundry_order_category_arr_rel_insert_input {
  data: [laundry_order_category_insert_input!]!

  """upsert condition"""
  on_conflict: laundry_order_category_on_conflict
}

"""aggregate avg on columns"""
type laundry_order_category_avg_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by avg() on columns of table "laundry.order_category"
"""
input laundry_order_category_avg_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""
Boolean expression to filter rows from the table "laundry.order_category". All fields are combined with a logical 'AND'.
"""
input laundry_order_category_bool_exp {
  _and: [laundry_order_category_bool_exp!]
  _not: laundry_order_category_bool_exp
  _or: [laundry_order_category_bool_exp!]
  category: laundry_category_bool_exp
  category_id: Int_comparison_exp
  id: Int_comparison_exp
  order: laundry_order_bool_exp
  order_id: Int_comparison_exp
  weight_in_kilo: float8_comparison_exp
}

"""
unique or primary key constraints on table "laundry.order_category"
"""
enum laundry_order_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_type_pkey
}

"""
input type for incrementing numeric columns in table "laundry.order_category"
"""
input laundry_order_category_inc_input {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""
input type for inserting data into table "laundry.order_category"
"""
input laundry_order_category_insert_input {
  category: laundry_category_obj_rel_insert_input
  category_id: Int
  id: Int
  order: laundry_order_obj_rel_insert_input
  order_id: Int
  weight_in_kilo: float8
}

"""aggregate max on columns"""
type laundry_order_category_max_fields {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""
order by max() on columns of table "laundry.order_category"
"""
input laundry_order_category_max_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""aggregate min on columns"""
type laundry_order_category_min_fields {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""
order by min() on columns of table "laundry.order_category"
"""
input laundry_order_category_min_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""
response of any mutation on the table "laundry.order_category"
"""
type laundry_order_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [laundry_order_category!]!
}

"""
on_conflict condition type for table "laundry.order_category"
"""
input laundry_order_category_on_conflict {
  constraint: laundry_order_category_constraint!
  update_columns: [laundry_order_category_update_column!]! = []
  where: laundry_order_category_bool_exp
}

"""Ordering options when selecting data from "laundry.order_category"."""
input laundry_order_category_order_by {
  category: laundry_category_order_by
  category_id: order_by
  id: order_by
  order: laundry_order_order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""primary key columns input for table: laundry.order_category"""
input laundry_order_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column {
  """column name"""
  category_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_avg_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_avg_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_corr_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_corr_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_covar_samp_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_max_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_max_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_min_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_min_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_stddev_samp_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_sum_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_sum_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
select "laundry_order_category_aggregate_bool_exp_var_samp_arguments_columns" columns of table "laundry.order_category"
"""
enum laundry_order_category_select_column_laundry_order_category_aggregate_bool_exp_var_samp_arguments_columns {
  """column name"""
  weight_in_kilo
}

"""
input type for updating data in table "laundry.order_category"
"""
input laundry_order_category_set_input {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""aggregate stddev on columns"""
type laundry_order_category_stddev_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by stddev() on columns of table "laundry.order_category"
"""
input laundry_order_category_stddev_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""aggregate stddev_pop on columns"""
type laundry_order_category_stddev_pop_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by stddev_pop() on columns of table "laundry.order_category"
"""
input laundry_order_category_stddev_pop_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""aggregate stddev_samp on columns"""
type laundry_order_category_stddev_samp_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by stddev_samp() on columns of table "laundry.order_category"
"""
input laundry_order_category_stddev_samp_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""
Streaming cursor of the table "laundry_order_category"
"""
input laundry_order_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: laundry_order_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input laundry_order_category_stream_cursor_value_input {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""aggregate sum on columns"""
type laundry_order_category_sum_fields {
  category_id: Int
  id: Int
  order_id: Int
  weight_in_kilo: float8
}

"""
order by sum() on columns of table "laundry.order_category"
"""
input laundry_order_category_sum_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""
update columns of table "laundry.order_category"
"""
enum laundry_order_category_update_column {
  """column name"""
  category_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  weight_in_kilo
}

input laundry_order_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: laundry_order_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: laundry_order_category_set_input

  """filter the rows which have to be updated"""
  where: laundry_order_category_bool_exp!
}

"""aggregate var_pop on columns"""
type laundry_order_category_var_pop_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by var_pop() on columns of table "laundry.order_category"
"""
input laundry_order_category_var_pop_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""aggregate var_samp on columns"""
type laundry_order_category_var_samp_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by var_samp() on columns of table "laundry.order_category"
"""
input laundry_order_category_var_samp_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""aggregate variance on columns"""
type laundry_order_category_variance_fields {
  category_id: Float
  id: Float
  order_id: Float
  weight_in_kilo: Float
}

"""
order by variance() on columns of table "laundry.order_category"
"""
input laundry_order_category_variance_order_by {
  category_id: order_by
  id: order_by
  order_id: order_by
  weight_in_kilo: order_by
}

"""
unique or primary key constraints on table "laundry.order"
"""
enum laundry_order_constraint {
  """
  unique or primary key constraint on columns "firebase_id"
  """
  order_firebase_id_key

  """
  unique or primary key constraint on columns "id"
  """
  order_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input laundry_order_delete_at_path_input {
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input laundry_order_delete_elem_input {
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input laundry_order_delete_key_input {
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "laundry.order"
"""
input laundry_order_inc_input {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  discount_value: money
  from_customer_delivery_id: Int
  id: Int
  refund_amount: money
  review_id: Int
  store_id: Int
  stripe_fees: money
  tax: money
  to_customer_delivery_id: Int
}

"""
input type for inserting data into table "laundry.order"
"""
input laundry_order_insert_input {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz
  categories: laundry_order_category_arr_rel_insert_input
  chat: chat_obj_rel_insert_input
  chat_id: Int
  customer: customer_customer_obj_rel_insert_input
  customer_address: String
  customer_app_type: String
  customer_id: Int
  customer_location_gps: geography
  delivery_cost: money
  delivery_type: String
  discount_value: money
  estimated_ready_time: timestamptz
  firebase_id: String
  from_customer_delivery: delivery_order_obj_rel_insert_input
  from_customer_delivery_id: Int
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  review: review_obj_rel_insert_input
  review_id: Int
  scheduled_time: timestamptz
  status: String
  store: laundry_store_obj_rel_insert_input
  store_id: Int
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_customer_delivery: delivery_order_obj_rel_insert_input
  to_customer_delivery_id: Int
}

"""aggregate max on columns"""
type laundry_order_max_fields {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_address: String
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_type: String
  discount_value: money
  estimated_ready_time: timestamptz
  firebase_id: String
  from_customer_delivery_id: Int
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  review_id: Int
  scheduled_time: timestamptz
  status: String
  store_id: Int
  stripe_fees: money
  tax: money
  to_customer_delivery_id: Int
}

"""aggregate min on columns"""
type laundry_order_min_fields {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_address: String
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_type: String
  discount_value: money
  estimated_ready_time: timestamptz
  firebase_id: String
  from_customer_delivery_id: Int
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  review_id: Int
  scheduled_time: timestamptz
  status: String
  store_id: Int
  stripe_fees: money
  tax: money
  to_customer_delivery_id: Int
}

"""
response of any mutation on the table "laundry.order"
"""
type laundry_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [laundry_order!]!
}

"""
input type for inserting object relation for remote table "laundry.order"
"""
input laundry_order_obj_rel_insert_input {
  data: laundry_order_insert_input!

  """upsert condition"""
  on_conflict: laundry_order_on_conflict
}

"""
on_conflict condition type for table "laundry.order"
"""
input laundry_order_on_conflict {
  constraint: laundry_order_constraint!
  update_columns: [laundry_order_update_column!]! = []
  where: laundry_order_bool_exp
}

"""Ordering options when selecting data from "laundry.order"."""
input laundry_order_order_by {
  actual_ready_time: order_by
  cancellation_time: order_by
  categories_aggregate: laundry_order_category_aggregate_order_by
  chat: chat_order_by
  chat_id: order_by
  customer: customer_customer_order_by
  customer_address: order_by
  customer_app_type: order_by
  customer_id: order_by
  customer_location_gps: order_by
  delivery_cost: order_by
  delivery_type: order_by
  discount_value: order_by
  estimated_ready_time: order_by
  firebase_id: order_by
  from_customer_delivery: delivery_order_order_by
  from_customer_delivery_id: order_by
  id: order_by
  in_process: order_by
  items_cost: order_by
  notes: order_by
  order_time: order_by
  payment_type: order_by
  refund_amount: order_by
  review: review_order_by
  review_id: order_by
  scheduled_time: order_by
  status: order_by
  store: laundry_store_order_by
  store_id: order_by
  stripe_fees: order_by
  stripe_info: order_by
  tax: order_by
  to_customer_delivery: delivery_order_order_by
  to_customer_delivery_id: order_by
  total_cost: order_by
}

"""primary key columns input for table: laundry.order"""
input laundry_order_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input laundry_order_prepend_input {
  stripe_info: jsonb
}

"""
select columns of table "laundry.order"
"""
enum laundry_order_select_column {
  """column name"""
  actual_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_address

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  customer_location_gps

  """column name"""
  delivery_cost

  """column name"""
  delivery_type

  """column name"""
  discount_value

  """column name"""
  estimated_ready_time

  """column name"""
  firebase_id

  """column name"""
  from_customer_delivery_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  store_id

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_customer_delivery_id
}

"""
input type for updating data in table "laundry.order"
"""
input laundry_order_set_input {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_address: String
  customer_app_type: String
  customer_id: Int
  customer_location_gps: geography
  delivery_cost: money
  delivery_type: String
  discount_value: money
  estimated_ready_time: timestamptz
  firebase_id: String
  from_customer_delivery_id: Int
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  review_id: Int
  scheduled_time: timestamptz
  status: String
  store_id: Int
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_customer_delivery_id: Int
}

"""aggregate stddev on columns"""
type laundry_order_stddev_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""aggregate stddev_pop on columns"""
type laundry_order_stddev_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""aggregate stddev_samp on columns"""
type laundry_order_stddev_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""
Streaming cursor of the table "laundry_order"
"""
input laundry_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: laundry_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input laundry_order_stream_cursor_value_input {
  actual_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_address: String
  customer_app_type: String
  customer_id: Int
  customer_location_gps: geography
  delivery_cost: money
  delivery_type: String
  discount_value: money
  estimated_ready_time: timestamptz
  firebase_id: String
  from_customer_delivery_id: Int
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  review_id: Int
  scheduled_time: timestamptz
  status: String
  store_id: Int
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_customer_delivery_id: Int
}

"""aggregate sum on columns"""
type laundry_order_sum_fields {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  discount_value: money
  from_customer_delivery_id: Int
  id: Int
  refund_amount: money
  review_id: Int
  store_id: Int
  stripe_fees: money
  tax: money
  to_customer_delivery_id: Int
}

"""
update columns of table "laundry.order"
"""
enum laundry_order_update_column {
  """column name"""
  actual_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_address

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  customer_location_gps

  """column name"""
  delivery_cost

  """column name"""
  delivery_type

  """column name"""
  discount_value

  """column name"""
  estimated_ready_time

  """column name"""
  firebase_id

  """column name"""
  from_customer_delivery_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  store_id

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_customer_delivery_id
}

input laundry_order_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: laundry_order_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: laundry_order_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: laundry_order_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: laundry_order_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: laundry_order_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: laundry_order_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: laundry_order_set_input

  """filter the rows which have to be updated"""
  where: laundry_order_bool_exp!
}

"""aggregate var_pop on columns"""
type laundry_order_var_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""aggregate var_samp on columns"""
type laundry_order_var_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""aggregate variance on columns"""
type laundry_order_variance_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  discount_value: Float
  from_customer_delivery_id: Float
  id: Float
  refund_amount: Float
  review_id: Float
  store_id: Float
  stripe_fees: Float
  tax: Float
  to_customer_delivery_id: Float
}

"""
columns and relationships of "laundry.store"
"""
type laundry_store {
  accepted_payments(
    """JSON select path"""
    path: String
  ): jsonb
  approved: Boolean!
  creation_time: timestamptz!
  customer_pickup: Boolean!
  delivery: Boolean!

  """An object relationship"""
  delivery_details: delivery_details
  delivery_details_id: Int

  """
  A computed field, executes function "laundry_delivery_details"
  """
  delivery_details_of_deliverer(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): [delivery_details!]

  """An object relationship"""
  delivery_partner: service_provider_delivery_partner

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!
  image: String!
  language_id: String!

  """An object relationship"""
  location: service_provider_location!
  location_id: Int!
  name: String!

  """in days"""
  normal_delivery_time: Int!
  open_status: String!

  """An array relationship"""
  operators(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): [laundry_operator!]!

  """An aggregate relationship"""
  operators_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): laundry_operator_aggregate!
  phone_number: String
  schedule(
    """JSON select path"""
    path: String
  ): jsonb
  self_delivery: Boolean!
  service_provider_type: String!
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "laundry.store"
"""
type laundry_store_aggregate {
  aggregate: laundry_store_aggregate_fields
  nodes: [laundry_store!]!
}

"""
aggregate fields of "laundry.store"
"""
type laundry_store_aggregate_fields {
  avg: laundry_store_avg_fields
  count(columns: [laundry_store_select_column!], distinct: Boolean): Int!
  max: laundry_store_max_fields
  min: laundry_store_min_fields
  stddev: laundry_store_stddev_fields
  stddev_pop: laundry_store_stddev_pop_fields
  stddev_samp: laundry_store_stddev_samp_fields
  sum: laundry_store_sum_fields
  var_pop: laundry_store_var_pop_fields
  var_samp: laundry_store_var_samp_fields
  variance: laundry_store_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input laundry_store_append_input {
  accepted_payments: jsonb
  schedule: jsonb
  stripe_info: jsonb
}

"""aggregate avg on columns"""
type laundry_store_avg_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""
Boolean expression to filter rows from the table "laundry.store". All fields are combined with a logical 'AND'.
"""
input laundry_store_bool_exp {
  _and: [laundry_store_bool_exp!]
  _not: laundry_store_bool_exp
  _or: [laundry_store_bool_exp!]
  accepted_payments: jsonb_comparison_exp
  approved: Boolean_comparison_exp
  creation_time: timestamptz_comparison_exp
  customer_pickup: Boolean_comparison_exp
  delivery: Boolean_comparison_exp
  delivery_details: delivery_details_bool_exp
  delivery_details_id: Int_comparison_exp
  delivery_details_of_deliverer: delivery_details_bool_exp
  delivery_partner: service_provider_delivery_partner_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  location: service_provider_location_bool_exp
  location_id: Int_comparison_exp
  name: String_comparison_exp
  normal_delivery_time: Int_comparison_exp
  open_status: String_comparison_exp
  operators: laundry_operator_bool_exp
  operators_aggregate: laundry_operator_aggregate_bool_exp
  phone_number: String_comparison_exp
  schedule: jsonb_comparison_exp
  self_delivery: Boolean_comparison_exp
  service_provider_type: String_comparison_exp
  stripe_info: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "laundry.store"
"""
enum laundry_store_constraint {
  """
  unique or primary key constraint on columns "delivery_details_id"
  """
  store_delivery_details_id_key

  """
  unique or primary key constraint on columns "location_id"
  """
  store_location_id_key

  """
  unique or primary key constraint on columns "id"
  """
  store_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input laundry_store_delete_at_path_input {
  accepted_payments: [String!]
  schedule: [String!]
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input laundry_store_delete_elem_input {
  accepted_payments: Int
  schedule: Int
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input laundry_store_delete_key_input {
  accepted_payments: String
  schedule: String
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "laundry.store"
"""
input laundry_store_inc_input {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int

  """in days"""
  normal_delivery_time: Int
}

"""
input type for inserting data into table "laundry.store"
"""
input laundry_store_insert_input {
  accepted_payments: jsonb
  approved: Boolean
  creation_time: timestamptz
  customer_pickup: Boolean
  delivery: Boolean
  delivery_details: delivery_details_obj_rel_insert_input
  delivery_details_id: Int
  delivery_partner: service_provider_delivery_partner_obj_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  image: String
  language_id: String
  location: service_provider_location_obj_rel_insert_input
  location_id: Int
  name: String

  """in days"""
  normal_delivery_time: Int
  open_status: String
  operators: laundry_operator_arr_rel_insert_input
  phone_number: String
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""aggregate max on columns"""
type laundry_store_max_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """in days"""
  normal_delivery_time: Int
  open_status: String
  phone_number: String
  service_provider_type: String
}

"""aggregate min on columns"""
type laundry_store_min_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """in days"""
  normal_delivery_time: Int
  open_status: String
  phone_number: String
  service_provider_type: String
}

"""
response of any mutation on the table "laundry.store"
"""
type laundry_store_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [laundry_store!]!
}

"""
input type for inserting object relation for remote table "laundry.store"
"""
input laundry_store_obj_rel_insert_input {
  data: laundry_store_insert_input!

  """upsert condition"""
  on_conflict: laundry_store_on_conflict
}

"""
on_conflict condition type for table "laundry.store"
"""
input laundry_store_on_conflict {
  constraint: laundry_store_constraint!
  update_columns: [laundry_store_update_column!]! = []
  where: laundry_store_bool_exp
}

"""Ordering options when selecting data from "laundry.store"."""
input laundry_store_order_by {
  accepted_payments: order_by
  approved: order_by
  creation_time: order_by
  customer_pickup: order_by
  delivery: order_by
  delivery_details: delivery_details_order_by
  delivery_details_id: order_by
  delivery_details_of_deliverer_aggregate: delivery_details_aggregate_order_by
  delivery_partner: service_provider_delivery_partner_order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  location: service_provider_location_order_by
  location_id: order_by
  name: order_by
  normal_delivery_time: order_by
  open_status: order_by
  operators_aggregate: laundry_operator_aggregate_order_by
  phone_number: order_by
  schedule: order_by
  self_delivery: order_by
  service_provider_type: order_by
  stripe_info: order_by
}

"""primary key columns input for table: laundry.store"""
input laundry_store_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input laundry_store_prepend_input {
  accepted_payments: jsonb
  schedule: jsonb
  stripe_info: jsonb
}

"""
select columns of table "laundry.store"
"""
enum laundry_store_select_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  normal_delivery_time

  """column name"""
  open_status

  """column name"""
  phone_number

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

"""
input type for updating data in table "laundry.store"
"""
input laundry_store_set_input {
  accepted_payments: jsonb
  approved: Boolean
  creation_time: timestamptz
  customer_pickup: Boolean
  delivery: Boolean
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """in days"""
  normal_delivery_time: Int
  open_status: String
  phone_number: String
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""aggregate stddev on columns"""
type laundry_store_stddev_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""aggregate stddev_pop on columns"""
type laundry_store_stddev_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""aggregate stddev_samp on columns"""
type laundry_store_stddev_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""
Streaming cursor of the table "laundry_store"
"""
input laundry_store_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: laundry_store_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input laundry_store_stream_cursor_value_input {
  accepted_payments: jsonb
  approved: Boolean
  creation_time: timestamptz
  customer_pickup: Boolean
  delivery: Boolean
  delivery_details_id: Int
  description_id: Int
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """in days"""
  normal_delivery_time: Int
  open_status: String
  phone_number: String
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""aggregate sum on columns"""
type laundry_store_sum_fields {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int

  """in days"""
  normal_delivery_time: Int
}

"""
update columns of table "laundry.store"
"""
enum laundry_store_update_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  normal_delivery_time

  """column name"""
  open_status

  """column name"""
  phone_number

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

input laundry_store_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: laundry_store_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: laundry_store_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: laundry_store_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: laundry_store_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: laundry_store_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: laundry_store_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: laundry_store_set_input

  """filter the rows which have to be updated"""
  where: laundry_store_bool_exp!
}

"""aggregate var_pop on columns"""
type laundry_store_var_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""aggregate var_samp on columns"""
type laundry_store_var_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""aggregate variance on columns"""
type laundry_store_variance_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float

  """in days"""
  normal_delivery_time: Float
}

"""
columns and relationships of "mez_admin"
"""
type mez_admin {
  app_type_id: String!

  """An object relationship"""
  notification_info: notification_info

  """An object relationship"""
  user: user
  user_id: Int!
  version: String
}

"""
aggregated selection of "mez_admin"
"""
type mez_admin_aggregate {
  aggregate: mez_admin_aggregate_fields
  nodes: [mez_admin!]!
}

"""
aggregate fields of "mez_admin"
"""
type mez_admin_aggregate_fields {
  avg: mez_admin_avg_fields
  count(columns: [mez_admin_select_column!], distinct: Boolean): Int!
  max: mez_admin_max_fields
  min: mez_admin_min_fields
  stddev: mez_admin_stddev_fields
  stddev_pop: mez_admin_stddev_pop_fields
  stddev_samp: mez_admin_stddev_samp_fields
  sum: mez_admin_sum_fields
  var_pop: mez_admin_var_pop_fields
  var_samp: mez_admin_var_samp_fields
  variance: mez_admin_variance_fields
}

"""aggregate avg on columns"""
type mez_admin_avg_fields {
  user_id: Float
}

"""
Boolean expression to filter rows from the table "mez_admin". All fields are combined with a logical 'AND'.
"""
input mez_admin_bool_exp {
  _and: [mez_admin_bool_exp!]
  _not: mez_admin_bool_exp
  _or: [mez_admin_bool_exp!]
  app_type_id: String_comparison_exp
  notification_info: notification_info_bool_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
  version: String_comparison_exp
}

"""
columns and relationships of "mez_admin_chat"
"""
type mez_admin_chat {
  app_type: String!

  """An object relationship"""
  chat: chat
  chat_id: Int!

  """An object relationship"""
  user: user
  user_id: Int!
}

"""
aggregated selection of "mez_admin_chat"
"""
type mez_admin_chat_aggregate {
  aggregate: mez_admin_chat_aggregate_fields
  nodes: [mez_admin_chat!]!
}

"""
aggregate fields of "mez_admin_chat"
"""
type mez_admin_chat_aggregate_fields {
  avg: mez_admin_chat_avg_fields
  count(columns: [mez_admin_chat_select_column!], distinct: Boolean): Int!
  max: mez_admin_chat_max_fields
  min: mez_admin_chat_min_fields
  stddev: mez_admin_chat_stddev_fields
  stddev_pop: mez_admin_chat_stddev_pop_fields
  stddev_samp: mez_admin_chat_stddev_samp_fields
  sum: mez_admin_chat_sum_fields
  var_pop: mez_admin_chat_var_pop_fields
  var_samp: mez_admin_chat_var_samp_fields
  variance: mez_admin_chat_variance_fields
}

"""aggregate avg on columns"""
type mez_admin_chat_avg_fields {
  chat_id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "mez_admin_chat". All fields are combined with a logical 'AND'.
"""
input mez_admin_chat_bool_exp {
  _and: [mez_admin_chat_bool_exp!]
  _not: mez_admin_chat_bool_exp
  _or: [mez_admin_chat_bool_exp!]
  app_type: String_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "mez_admin_chat"
"""
enum mez_admin_chat_constraint {
  """
  unique or primary key constraint on columns "chat_id"
  """
  mez_admin_chat_pkey
}

"""
input type for incrementing numeric columns in table "mez_admin_chat"
"""
input mez_admin_chat_inc_input {
  chat_id: Int
  user_id: Int
}

"""
input type for inserting data into table "mez_admin_chat"
"""
input mez_admin_chat_insert_input {
  app_type: String
  chat: chat_obj_rel_insert_input
  chat_id: Int
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type mez_admin_chat_max_fields {
  app_type: String
  chat_id: Int
  user_id: Int
}

"""aggregate min on columns"""
type mez_admin_chat_min_fields {
  app_type: String
  chat_id: Int
  user_id: Int
}

"""
response of any mutation on the table "mez_admin_chat"
"""
type mez_admin_chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mez_admin_chat!]!
}

"""
on_conflict condition type for table "mez_admin_chat"
"""
input mez_admin_chat_on_conflict {
  constraint: mez_admin_chat_constraint!
  update_columns: [mez_admin_chat_update_column!]! = []
  where: mez_admin_chat_bool_exp
}

"""Ordering options when selecting data from "mez_admin_chat"."""
input mez_admin_chat_order_by {
  app_type: order_by
  chat: chat_order_by
  chat_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: mez_admin_chat"""
input mez_admin_chat_pk_columns_input {
  chat_id: Int!
}

"""
select columns of table "mez_admin_chat"
"""
enum mez_admin_chat_select_column {
  """column name"""
  app_type

  """column name"""
  chat_id

  """column name"""
  user_id
}

"""
input type for updating data in table "mez_admin_chat"
"""
input mez_admin_chat_set_input {
  app_type: String
  chat_id: Int
  user_id: Int
}

"""aggregate stddev on columns"""
type mez_admin_chat_stddev_fields {
  chat_id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type mez_admin_chat_stddev_pop_fields {
  chat_id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type mez_admin_chat_stddev_samp_fields {
  chat_id: Float
  user_id: Float
}

"""
Streaming cursor of the table "mez_admin_chat"
"""
input mez_admin_chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mez_admin_chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mez_admin_chat_stream_cursor_value_input {
  app_type: String
  chat_id: Int
  user_id: Int
}

"""aggregate sum on columns"""
type mez_admin_chat_sum_fields {
  chat_id: Int
  user_id: Int
}

"""
update columns of table "mez_admin_chat"
"""
enum mez_admin_chat_update_column {
  """column name"""
  app_type

  """column name"""
  chat_id

  """column name"""
  user_id
}

input mez_admin_chat_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mez_admin_chat_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mez_admin_chat_set_input

  """filter the rows which have to be updated"""
  where: mez_admin_chat_bool_exp!
}

"""aggregate var_pop on columns"""
type mez_admin_chat_var_pop_fields {
  chat_id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type mez_admin_chat_var_samp_fields {
  chat_id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type mez_admin_chat_variance_fields {
  chat_id: Float
  user_id: Float
}

"""
unique or primary key constraints on table "mez_admin"
"""
enum mez_admin_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  mez_admin_pkey
}

"""
input type for incrementing numeric columns in table "mez_admin"
"""
input mez_admin_inc_input {
  user_id: Int
}

"""
input type for inserting data into table "mez_admin"
"""
input mez_admin_insert_input {
  app_type_id: String
  notification_info: notification_info_obj_rel_insert_input
  user: user_obj_rel_insert_input
  user_id: Int
  version: String
}

"""aggregate max on columns"""
type mez_admin_max_fields {
  app_type_id: String
  user_id: Int
  version: String
}

"""aggregate min on columns"""
type mez_admin_min_fields {
  app_type_id: String
  user_id: Int
  version: String
}

"""
response of any mutation on the table "mez_admin"
"""
type mez_admin_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mez_admin!]!
}

"""
on_conflict condition type for table "mez_admin"
"""
input mez_admin_on_conflict {
  constraint: mez_admin_constraint!
  update_columns: [mez_admin_update_column!]! = []
  where: mez_admin_bool_exp
}

"""Ordering options when selecting data from "mez_admin"."""
input mez_admin_order_by {
  app_type_id: order_by
  notification_info: notification_info_order_by
  user: user_order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: mez_admin"""
input mez_admin_pk_columns_input {
  user_id: Int!
}

"""
select columns of table "mez_admin"
"""
enum mez_admin_select_column {
  """column name"""
  app_type_id

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "mez_admin"
"""
input mez_admin_set_input {
  app_type_id: String
  user_id: Int
  version: String
}

"""aggregate stddev on columns"""
type mez_admin_stddev_fields {
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type mez_admin_stddev_pop_fields {
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type mez_admin_stddev_samp_fields {
  user_id: Float
}

"""
Streaming cursor of the table "mez_admin"
"""
input mez_admin_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mez_admin_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mez_admin_stream_cursor_value_input {
  app_type_id: String
  user_id: Int
  version: String
}

"""aggregate sum on columns"""
type mez_admin_sum_fields {
  user_id: Int
}

"""
update columns of table "mez_admin"
"""
enum mez_admin_update_column {
  """column name"""
  app_type_id

  """column name"""
  user_id

  """column name"""
  version
}

input mez_admin_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mez_admin_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mez_admin_set_input

  """filter the rows which have to be updated"""
  where: mez_admin_bool_exp!
}

"""aggregate var_pop on columns"""
type mez_admin_var_pop_fields {
  user_id: Float
}

"""aggregate var_samp on columns"""
type mez_admin_var_samp_fields {
  user_id: Float
}

"""aggregate variance on columns"""
type mez_admin_variance_fields {
  user_id: Float
}

"""
columns and relationships of "mez_json"
"""
type mez_json {
  json_object(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "mez_json"
"""
type mez_json_aggregate {
  aggregate: mez_json_aggregate_fields
  nodes: [mez_json!]!
}

"""
aggregate fields of "mez_json"
"""
type mez_json_aggregate_fields {
  count(columns: [mez_json_select_column!], distinct: Boolean): Int!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input mez_json_append_input {
  json_object: jsonb
}

"""
Boolean expression to filter rows from the table "mez_json". All fields are combined with a logical 'AND'.
"""
input mez_json_bool_exp {
  _and: [mez_json_bool_exp!]
  _not: mez_json_bool_exp
  _or: [mez_json_bool_exp!]
  json_object: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "mez_json"
"""
enum mez_json_constraint {
  """
  unique or primary key constraint on columns "json_object"
  """
  mez_json_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input mez_json_delete_at_path_input {
  json_object: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input mez_json_delete_elem_input {
  json_object: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input mez_json_delete_key_input {
  json_object: String
}

"""
input type for inserting data into table "mez_json"
"""
input mez_json_insert_input {
  json_object: jsonb
}

"""
response of any mutation on the table "mez_json"
"""
type mez_json_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mez_json!]!
}

"""
on_conflict condition type for table "mez_json"
"""
input mez_json_on_conflict {
  constraint: mez_json_constraint!
  update_columns: [mez_json_update_column!]! = []
  where: mez_json_bool_exp
}

"""Ordering options when selecting data from "mez_json"."""
input mez_json_order_by {
  json_object: order_by
}

"""primary key columns input for table: mez_json"""
input mez_json_pk_columns_input {
  json_object: jsonb!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input mez_json_prepend_input {
  json_object: jsonb
}

"""
select columns of table "mez_json"
"""
enum mez_json_select_column {
  """column name"""
  json_object
}

"""
input type for updating data in table "mez_json"
"""
input mez_json_set_input {
  json_object: jsonb
}

"""
Streaming cursor of the table "mez_json"
"""
input mez_json_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mez_json_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mez_json_stream_cursor_value_input {
  json_object: jsonb
}

"""
update columns of table "mez_json"
"""
enum mez_json_update_column {
  """column name"""
  json_object
}

input mez_json_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: mez_json_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: mez_json_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: mez_json_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: mez_json_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: mez_json_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: mez_json_set_input

  """filter the rows which have to be updated"""
  where: mez_json_bool_exp!
}

scalar money

"""
Boolean expression to compare columns of type "money". All fields are combined with logical 'AND'.
"""
input money_comparison_exp {
  _eq: money
  _gt: money
  _gte: money
  _in: [money!]
  _is_null: Boolean
  _lt: money
  _lte: money
  _neq: money
  _nin: [money!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "app_type"
  """
  delete_app_type(
    """filter the rows which have to be deleted"""
    where: app_type_bool_exp!
  ): app_type_mutation_response

  """
  delete single row from the table: "app_type"
  """
  delete_app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): app_type

  """
  delete data from the table: "chat"
  """
  delete_chat(
    """filter the rows which have to be deleted"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  delete single row from the table: "chat"
  """
  delete_chat_by_pk(id: Int!): chat

  """
  delete data from the table: "chat_participant"
  """
  delete_chat_participant(
    """filter the rows which have to be deleted"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  delete single row from the table: "chat_participant"
  """
  delete_chat_participant_by_pk(id: Int!): chat_participant

  """
  delete data from the table: "customer.customer"
  """
  delete_customer_customer(
    """filter the rows which have to be deleted"""
    where: customer_customer_bool_exp!
  ): customer_customer_mutation_response

  """
  delete single row from the table: "customer.customer"
  """
  delete_customer_customer_by_pk(user_id: Int!): customer_customer

  """
  delete data from the table: "customer.favourited_item"
  """
  delete_customer_favourited_item(
    """filter the rows which have to be deleted"""
    where: customer_favourited_item_bool_exp!
  ): customer_favourited_item_mutation_response

  """
  delete single row from the table: "customer.favourited_item"
  """
  delete_customer_favourited_item_by_pk(id: Int!): customer_favourited_item

  """
  delete data from the table: "customer.saved_location"
  """
  delete_customer_saved_location(
    """filter the rows which have to be deleted"""
    where: customer_saved_location_bool_exp!
  ): customer_saved_location_mutation_response

  """
  delete single row from the table: "customer.saved_location"
  """
  delete_customer_saved_location_by_pk(id: Int!): customer_saved_location

  """
  delete data from the table: "delivery.company"
  """
  delete_delivery_company(
    """filter the rows which have to be deleted"""
    where: delivery_company_bool_exp!
  ): delivery_company_mutation_response

  """
  delete single row from the table: "delivery.company"
  """
  delete_delivery_company_by_pk(id: Int!): delivery_company

  """
  delete data from the table: "delivery.details"
  """
  delete_delivery_details(
    """filter the rows which have to be deleted"""
    where: delivery_details_bool_exp!
  ): delivery_details_mutation_response

  """
  delete single row from the table: "delivery.details"
  """
  delete_delivery_details_by_pk(id: Int!): delivery_details

  """
  delete data from the table: "delivery.driver"
  """
  delete_delivery_driver(
    """filter the rows which have to be deleted"""
    where: delivery_driver_bool_exp!
  ): delivery_driver_mutation_response

  """
  delete single row from the table: "delivery.driver"
  """
  delete_delivery_driver_by_pk(id: Int!): delivery_driver

  """
  delete data from the table: "delivery.operator"
  """
  delete_delivery_operator(
    """filter the rows which have to be deleted"""
    where: delivery_operator_bool_exp!
  ): delivery_operator_mutation_response

  """
  delete single row from the table: "delivery.operator"
  """
  delete_delivery_operator_by_pk(id: Int!): delivery_operator

  """
  delete data from the table: "delivery.order"
  """
  delete_delivery_order(
    """filter the rows which have to be deleted"""
    where: delivery_order_bool_exp!
  ): delivery_order_mutation_response

  """
  delete single row from the table: "delivery.order"
  """
  delete_delivery_order_by_pk(id: Int!): delivery_order

  """
  delete data from the table: "delivery.order_public"
  """
  delete_delivery_order_public(
    """filter the rows which have to be deleted"""
    where: delivery_order_public_bool_exp!
  ): delivery_order_public_mutation_response

  """
  delete data from the table: "direct_chat"
  """
  delete_direct_chat(
    """filter the rows which have to be deleted"""
    where: direct_chat_bool_exp!
  ): direct_chat_mutation_response

  """
  delete single row from the table: "direct_chat"
  """
  delete_direct_chat_by_pk(chat_id: Int!): direct_chat

  """
  delete data from the table: "language"
  """
  delete_language(
    """filter the rows which have to be deleted"""
    where: language_bool_exp!
  ): language_mutation_response

  """
  delete single row from the table: "language"
  """
  delete_language_by_pk(id: String!): language

  """
  delete data from the table: "laundry.category"
  """
  delete_laundry_category(
    """filter the rows which have to be deleted"""
    where: laundry_category_bool_exp!
  ): laundry_category_mutation_response

  """
  delete single row from the table: "laundry.category"
  """
  delete_laundry_category_by_pk(id: Int!): laundry_category

  """
  delete data from the table: "laundry.operator"
  """
  delete_laundry_operator(
    """filter the rows which have to be deleted"""
    where: laundry_operator_bool_exp!
  ): laundry_operator_mutation_response

  """
  delete single row from the table: "laundry.operator"
  """
  delete_laundry_operator_by_pk(id: Int!): laundry_operator

  """
  delete data from the table: "laundry.order"
  """
  delete_laundry_order(
    """filter the rows which have to be deleted"""
    where: laundry_order_bool_exp!
  ): laundry_order_mutation_response

  """
  delete single row from the table: "laundry.order"
  """
  delete_laundry_order_by_pk(id: Int!): laundry_order

  """
  delete data from the table: "laundry.order_category"
  """
  delete_laundry_order_category(
    """filter the rows which have to be deleted"""
    where: laundry_order_category_bool_exp!
  ): laundry_order_category_mutation_response

  """
  delete single row from the table: "laundry.order_category"
  """
  delete_laundry_order_category_by_pk(id: Int!): laundry_order_category

  """
  delete data from the table: "laundry.store"
  """
  delete_laundry_store(
    """filter the rows which have to be deleted"""
    where: laundry_store_bool_exp!
  ): laundry_store_mutation_response

  """
  delete single row from the table: "laundry.store"
  """
  delete_laundry_store_by_pk(id: Int!): laundry_store

  """
  delete data from the table: "mez_admin"
  """
  delete_mez_admin(
    """filter the rows which have to be deleted"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  delete single row from the table: "mez_admin"
  """
  delete_mez_admin_by_pk(user_id: Int!): mez_admin

  """
  delete data from the table: "mez_admin_chat"
  """
  delete_mez_admin_chat(
    """filter the rows which have to be deleted"""
    where: mez_admin_chat_bool_exp!
  ): mez_admin_chat_mutation_response

  """
  delete single row from the table: "mez_admin_chat"
  """
  delete_mez_admin_chat_by_pk(chat_id: Int!): mez_admin_chat

  """
  delete data from the table: "mez_json"
  """
  delete_mez_json(
    """filter the rows which have to be deleted"""
    where: mez_json_bool_exp!
  ): mez_json_mutation_response

  """
  delete single row from the table: "mez_json"
  """
  delete_mez_json_by_pk(json_object: jsonb!): mez_json

  """
  delete data from the table: "notification_info"
  """
  delete_notification_info(
    """filter the rows which have to be deleted"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  delete single row from the table: "notification_info"
  """
  delete_notification_info_by_pk(id: Int!): notification_info

  """
  delete data from the table: "restaurant.cart"
  """
  delete_restaurant_cart(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  delete single row from the table: "restaurant.cart"
  """
  delete_restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  delete data from the table: "restaurant.cart_item"
  """
  delete_restaurant_cart_item(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  delete single row from the table: "restaurant.cart_item"
  """
  delete_restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  delete data from the table: "restaurant.category"
  """
  delete_restaurant_category(
    """filter the rows which have to be deleted"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  delete single row from the table: "restaurant.category"
  """
  delete_restaurant_category_by_pk(id: Int!): restaurant_category

  """
  delete data from the table: "restaurant.choice"
  """
  delete_restaurant_choice(
    """filter the rows which have to be deleted"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  delete single row from the table: "restaurant.choice"
  """
  delete_restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  delete data from the table: "restaurant.item"
  """
  delete_restaurant_item(
    """filter the rows which have to be deleted"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  delete single row from the table: "restaurant.item"
  """
  delete_restaurant_item_by_pk(id: Int!): restaurant_item

  """
  delete data from the table: "restaurant.item_option_map"
  """
  delete_restaurant_item_option_map(
    """filter the rows which have to be deleted"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  delete single row from the table: "restaurant.item_option_map"
  """
  delete_restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  delete data from the table: "restaurant.operator"
  """
  delete_restaurant_operator(
    """filter the rows which have to be deleted"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  delete single row from the table: "restaurant.operator"
  """
  delete_restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  delete data from the table: "restaurant.option"
  """
  delete_restaurant_option(
    """filter the rows which have to be deleted"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  delete single row from the table: "restaurant.option"
  """
  delete_restaurant_option_by_pk(id: Int!): restaurant_option

  """
  delete data from the table: "restaurant.option_choice_map"
  """
  delete_restaurant_option_choice_map(
    """filter the rows which have to be deleted"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  delete single row from the table: "restaurant.option_choice_map"
  """
  delete_restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  delete data from the table: "restaurant.order"
  """
  delete_restaurant_order(
    """filter the rows which have to be deleted"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  delete single row from the table: "restaurant.order"
  """
  delete_restaurant_order_by_pk(id: Int!): restaurant_order

  """
  delete data from the table: "restaurant.order_item"
  """
  delete_restaurant_order_item(
    """filter the rows which have to be deleted"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  delete single row from the table: "restaurant.order_item"
  """
  delete_restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  delete data from the table: "restaurant.order_public"
  """
  delete_restaurant_order_public(
    """filter the rows which have to be deleted"""
    where: restaurant_order_public_bool_exp!
  ): restaurant_order_public_mutation_response

  """
  delete data from the table: "restaurant.restaurant"
  """
  delete_restaurant_restaurant(
    """filter the rows which have to be deleted"""
    where: restaurant_restaurant_bool_exp!
  ): restaurant_restaurant_mutation_response

  """
  delete single row from the table: "restaurant.restaurant"
  """
  delete_restaurant_restaurant_by_pk(id: Int!): restaurant_restaurant

  """
  delete data from the table: "review"
  """
  delete_review(
    """filter the rows which have to be deleted"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  delete single row from the table: "review"
  """
  delete_review_by_pk(id: Int!): review

  """
  delete data from the table: "service_provider_customer_chat"
  """
  delete_service_provider_customer_chat(
    """filter the rows which have to be deleted"""
    where: service_provider_customer_chat_bool_exp!
  ): service_provider_customer_chat_mutation_response

  """
  delete single row from the table: "service_provider_customer_chat"
  """
  delete_service_provider_customer_chat_by_pk(chat_id: Int!): service_provider_customer_chat

  """
  delete data from the table: "service_provider.delivery_partner"
  """
  delete_service_provider_delivery_partner(
    """filter the rows which have to be deleted"""
    where: service_provider_delivery_partner_bool_exp!
  ): service_provider_delivery_partner_mutation_response

  """
  delete single row from the table: "service_provider.delivery_partner"
  """
  delete_service_provider_delivery_partner_by_pk(id: Int!): service_provider_delivery_partner

  """
  delete data from the table: "service_provider.location"
  """
  delete_service_provider_location(
    """filter the rows which have to be deleted"""
    where: service_provider_location_bool_exp!
  ): service_provider_location_mutation_response

  """
  delete single row from the table: "service_provider.location"
  """
  delete_service_provider_location_by_pk(id: Int!): service_provider_location

  """
  delete data from the table: "service_provider.post"
  """
  delete_service_provider_post(
    """filter the rows which have to be deleted"""
    where: service_provider_post_bool_exp!
  ): service_provider_post_mutation_response

  """
  delete single row from the table: "service_provider.post"
  """
  delete_service_provider_post_by_pk(id: Int!): service_provider_post

  """
  delete data from the table: "service_provider.service_link"
  """
  delete_service_provider_service_link(
    """filter the rows which have to be deleted"""
    where: service_provider_service_link_bool_exp!
  ): service_provider_service_link_mutation_response

  """
  delete single row from the table: "service_provider.service_link"
  """
  delete_service_provider_service_link_by_pk(id: Int!): service_provider_service_link

  """
  delete data from the table: "service_provider.subscriber"
  """
  delete_service_provider_subscriber(
    """filter the rows which have to be deleted"""
    where: service_provider_subscriber_bool_exp!
  ): service_provider_subscriber_mutation_response

  """
  delete single row from the table: "service_provider.subscriber"
  """
  delete_service_provider_subscriber_by_pk(id: Int!): service_provider_subscriber

  """
  delete data from the table: "translation"
  """
  delete_translation(
    """filter the rows which have to be deleted"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  delete single row from the table: "translation"
  """
  delete_translation_by_pk(id: Int!): translation

  """
  delete data from the table: "translation_value"
  """
  delete_translation_value(
    """filter the rows which have to be deleted"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  delete single row from the table: "translation_value"
  """
  delete_translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: Int!): user

  """
  insert data into the table: "app_type"
  """
  insert_app_type(
    """the rows to be inserted"""
    objects: [app_type_insert_input!]!

    """upsert condition"""
    on_conflict: app_type_on_conflict
  ): app_type_mutation_response

  """
  insert a single row into the table: "app_type"
  """
  insert_app_type_one(
    """the row to be inserted"""
    object: app_type_insert_input!

    """upsert condition"""
    on_conflict: app_type_on_conflict
  ): app_type

  """
  insert data into the table: "chat"
  """
  insert_chat(
    """the rows to be inserted"""
    objects: [chat_insert_input!]!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  """
  insert a single row into the table: "chat"
  """
  insert_chat_one(
    """the row to be inserted"""
    object: chat_insert_input!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat

  """
  insert data into the table: "chat_participant"
  """
  insert_chat_participant(
    """the rows to be inserted"""
    objects: [chat_participant_insert_input!]!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant_mutation_response

  """
  insert a single row into the table: "chat_participant"
  """
  insert_chat_participant_one(
    """the row to be inserted"""
    object: chat_participant_insert_input!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant

  """
  insert data into the table: "customer.customer"
  """
  insert_customer_customer(
    """the rows to be inserted"""
    objects: [customer_customer_insert_input!]!

    """upsert condition"""
    on_conflict: customer_customer_on_conflict
  ): customer_customer_mutation_response

  """
  insert a single row into the table: "customer.customer"
  """
  insert_customer_customer_one(
    """the row to be inserted"""
    object: customer_customer_insert_input!

    """upsert condition"""
    on_conflict: customer_customer_on_conflict
  ): customer_customer

  """
  insert data into the table: "customer.favourited_item"
  """
  insert_customer_favourited_item(
    """the rows to be inserted"""
    objects: [customer_favourited_item_insert_input!]!

    """upsert condition"""
    on_conflict: customer_favourited_item_on_conflict
  ): customer_favourited_item_mutation_response

  """
  insert a single row into the table: "customer.favourited_item"
  """
  insert_customer_favourited_item_one(
    """the row to be inserted"""
    object: customer_favourited_item_insert_input!

    """upsert condition"""
    on_conflict: customer_favourited_item_on_conflict
  ): customer_favourited_item

  """
  insert data into the table: "customer.saved_location"
  """
  insert_customer_saved_location(
    """the rows to be inserted"""
    objects: [customer_saved_location_insert_input!]!

    """upsert condition"""
    on_conflict: customer_saved_location_on_conflict
  ): customer_saved_location_mutation_response

  """
  insert a single row into the table: "customer.saved_location"
  """
  insert_customer_saved_location_one(
    """the row to be inserted"""
    object: customer_saved_location_insert_input!

    """upsert condition"""
    on_conflict: customer_saved_location_on_conflict
  ): customer_saved_location

  """
  insert data into the table: "delivery.company"
  """
  insert_delivery_company(
    """the rows to be inserted"""
    objects: [delivery_company_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_company_on_conflict
  ): delivery_company_mutation_response

  """
  insert a single row into the table: "delivery.company"
  """
  insert_delivery_company_one(
    """the row to be inserted"""
    object: delivery_company_insert_input!

    """upsert condition"""
    on_conflict: delivery_company_on_conflict
  ): delivery_company

  """
  insert data into the table: "delivery.details"
  """
  insert_delivery_details(
    """the rows to be inserted"""
    objects: [delivery_details_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_details_on_conflict
  ): delivery_details_mutation_response

  """
  insert a single row into the table: "delivery.details"
  """
  insert_delivery_details_one(
    """the row to be inserted"""
    object: delivery_details_insert_input!

    """upsert condition"""
    on_conflict: delivery_details_on_conflict
  ): delivery_details

  """
  insert data into the table: "delivery.driver"
  """
  insert_delivery_driver(
    """the rows to be inserted"""
    objects: [delivery_driver_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_driver_on_conflict
  ): delivery_driver_mutation_response

  """
  insert a single row into the table: "delivery.driver"
  """
  insert_delivery_driver_one(
    """the row to be inserted"""
    object: delivery_driver_insert_input!

    """upsert condition"""
    on_conflict: delivery_driver_on_conflict
  ): delivery_driver

  """
  insert data into the table: "delivery.operator"
  """
  insert_delivery_operator(
    """the rows to be inserted"""
    objects: [delivery_operator_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_operator_on_conflict
  ): delivery_operator_mutation_response

  """
  insert a single row into the table: "delivery.operator"
  """
  insert_delivery_operator_one(
    """the row to be inserted"""
    object: delivery_operator_insert_input!

    """upsert condition"""
    on_conflict: delivery_operator_on_conflict
  ): delivery_operator

  """
  insert data into the table: "delivery.order"
  """
  insert_delivery_order(
    """the rows to be inserted"""
    objects: [delivery_order_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_order_on_conflict
  ): delivery_order_mutation_response

  """
  insert a single row into the table: "delivery.order"
  """
  insert_delivery_order_one(
    """the row to be inserted"""
    object: delivery_order_insert_input!

    """upsert condition"""
    on_conflict: delivery_order_on_conflict
  ): delivery_order

  """
  insert data into the table: "delivery.order_public"
  """
  insert_delivery_order_public(
    """the rows to be inserted"""
    objects: [delivery_order_public_insert_input!]!
  ): delivery_order_public_mutation_response

  """
  insert a single row into the table: "delivery.order_public"
  """
  insert_delivery_order_public_one(
    """the row to be inserted"""
    object: delivery_order_public_insert_input!
  ): delivery_order_public

  """
  insert data into the table: "direct_chat"
  """
  insert_direct_chat(
    """the rows to be inserted"""
    objects: [direct_chat_insert_input!]!

    """upsert condition"""
    on_conflict: direct_chat_on_conflict
  ): direct_chat_mutation_response

  """
  insert a single row into the table: "direct_chat"
  """
  insert_direct_chat_one(
    """the row to be inserted"""
    object: direct_chat_insert_input!

    """upsert condition"""
    on_conflict: direct_chat_on_conflict
  ): direct_chat

  """
  insert data into the table: "language"
  """
  insert_language(
    """the rows to be inserted"""
    objects: [language_insert_input!]!

    """upsert condition"""
    on_conflict: language_on_conflict
  ): language_mutation_response

  """
  insert a single row into the table: "language"
  """
  insert_language_one(
    """the row to be inserted"""
    object: language_insert_input!

    """upsert condition"""
    on_conflict: language_on_conflict
  ): language

  """
  insert data into the table: "laundry.category"
  """
  insert_laundry_category(
    """the rows to be inserted"""
    objects: [laundry_category_insert_input!]!

    """upsert condition"""
    on_conflict: laundry_category_on_conflict
  ): laundry_category_mutation_response

  """
  insert a single row into the table: "laundry.category"
  """
  insert_laundry_category_one(
    """the row to be inserted"""
    object: laundry_category_insert_input!

    """upsert condition"""
    on_conflict: laundry_category_on_conflict
  ): laundry_category

  """
  insert data into the table: "laundry.operator"
  """
  insert_laundry_operator(
    """the rows to be inserted"""
    objects: [laundry_operator_insert_input!]!

    """upsert condition"""
    on_conflict: laundry_operator_on_conflict
  ): laundry_operator_mutation_response

  """
  insert a single row into the table: "laundry.operator"
  """
  insert_laundry_operator_one(
    """the row to be inserted"""
    object: laundry_operator_insert_input!

    """upsert condition"""
    on_conflict: laundry_operator_on_conflict
  ): laundry_operator

  """
  insert data into the table: "laundry.order"
  """
  insert_laundry_order(
    """the rows to be inserted"""
    objects: [laundry_order_insert_input!]!

    """upsert condition"""
    on_conflict: laundry_order_on_conflict
  ): laundry_order_mutation_response

  """
  insert data into the table: "laundry.order_category"
  """
  insert_laundry_order_category(
    """the rows to be inserted"""
    objects: [laundry_order_category_insert_input!]!

    """upsert condition"""
    on_conflict: laundry_order_category_on_conflict
  ): laundry_order_category_mutation_response

  """
  insert a single row into the table: "laundry.order_category"
  """
  insert_laundry_order_category_one(
    """the row to be inserted"""
    object: laundry_order_category_insert_input!

    """upsert condition"""
    on_conflict: laundry_order_category_on_conflict
  ): laundry_order_category

  """
  insert a single row into the table: "laundry.order"
  """
  insert_laundry_order_one(
    """the row to be inserted"""
    object: laundry_order_insert_input!

    """upsert condition"""
    on_conflict: laundry_order_on_conflict
  ): laundry_order

  """
  insert data into the table: "laundry.store"
  """
  insert_laundry_store(
    """the rows to be inserted"""
    objects: [laundry_store_insert_input!]!

    """upsert condition"""
    on_conflict: laundry_store_on_conflict
  ): laundry_store_mutation_response

  """
  insert a single row into the table: "laundry.store"
  """
  insert_laundry_store_one(
    """the row to be inserted"""
    object: laundry_store_insert_input!

    """upsert condition"""
    on_conflict: laundry_store_on_conflict
  ): laundry_store

  """
  insert data into the table: "mez_admin"
  """
  insert_mez_admin(
    """the rows to be inserted"""
    objects: [mez_admin_insert_input!]!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin_mutation_response

  """
  insert data into the table: "mez_admin_chat"
  """
  insert_mez_admin_chat(
    """the rows to be inserted"""
    objects: [mez_admin_chat_insert_input!]!

    """upsert condition"""
    on_conflict: mez_admin_chat_on_conflict
  ): mez_admin_chat_mutation_response

  """
  insert a single row into the table: "mez_admin_chat"
  """
  insert_mez_admin_chat_one(
    """the row to be inserted"""
    object: mez_admin_chat_insert_input!

    """upsert condition"""
    on_conflict: mez_admin_chat_on_conflict
  ): mez_admin_chat

  """
  insert a single row into the table: "mez_admin"
  """
  insert_mez_admin_one(
    """the row to be inserted"""
    object: mez_admin_insert_input!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin

  """
  insert data into the table: "mez_json"
  """
  insert_mez_json(
    """the rows to be inserted"""
    objects: [mez_json_insert_input!]!

    """upsert condition"""
    on_conflict: mez_json_on_conflict
  ): mez_json_mutation_response

  """
  insert a single row into the table: "mez_json"
  """
  insert_mez_json_one(
    """the row to be inserted"""
    object: mez_json_insert_input!

    """upsert condition"""
    on_conflict: mez_json_on_conflict
  ): mez_json

  """
  insert data into the table: "notification_info"
  """
  insert_notification_info(
    """the rows to be inserted"""
    objects: [notification_info_insert_input!]!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info_mutation_response

  """
  insert a single row into the table: "notification_info"
  """
  insert_notification_info_one(
    """the row to be inserted"""
    object: notification_info_insert_input!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info

  """
  insert data into the table: "restaurant.cart"
  """
  insert_restaurant_cart(
    """the rows to be inserted"""
    objects: [restaurant_cart_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart_mutation_response

  """
  insert data into the table: "restaurant.cart_item"
  """
  insert_restaurant_cart_item(
    """the rows to be inserted"""
    objects: [restaurant_cart_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item_mutation_response

  """
  insert a single row into the table: "restaurant.cart_item"
  """
  insert_restaurant_cart_item_one(
    """the row to be inserted"""
    object: restaurant_cart_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item

  """
  insert a single row into the table: "restaurant.cart"
  """
  insert_restaurant_cart_one(
    """the row to be inserted"""
    object: restaurant_cart_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart

  """
  insert data into the table: "restaurant.category"
  """
  insert_restaurant_category(
    """the rows to be inserted"""
    objects: [restaurant_category_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category_mutation_response

  """
  insert a single row into the table: "restaurant.category"
  """
  insert_restaurant_category_one(
    """the row to be inserted"""
    object: restaurant_category_insert_input!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category

  """
  insert data into the table: "restaurant.choice"
  """
  insert_restaurant_choice(
    """the rows to be inserted"""
    objects: [restaurant_choice_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice_mutation_response

  """
  insert a single row into the table: "restaurant.choice"
  """
  insert_restaurant_choice_one(
    """the row to be inserted"""
    object: restaurant_choice_insert_input!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice

  """
  insert data into the table: "restaurant.item"
  """
  insert_restaurant_item(
    """the rows to be inserted"""
    objects: [restaurant_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item_mutation_response

  """
  insert a single row into the table: "restaurant.item"
  """
  insert_restaurant_item_one(
    """the row to be inserted"""
    object: restaurant_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item

  """
  insert data into the table: "restaurant.item_option_map"
  """
  insert_restaurant_item_option_map(
    """the rows to be inserted"""
    objects: [restaurant_item_option_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map_mutation_response

  """
  insert a single row into the table: "restaurant.item_option_map"
  """
  insert_restaurant_item_option_map_one(
    """the row to be inserted"""
    object: restaurant_item_option_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map

  """
  insert data into the table: "restaurant.operator"
  """
  insert_restaurant_operator(
    """the rows to be inserted"""
    objects: [restaurant_operator_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator_mutation_response

  """
  insert a single row into the table: "restaurant.operator"
  """
  insert_restaurant_operator_one(
    """the row to be inserted"""
    object: restaurant_operator_insert_input!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator

  """
  insert data into the table: "restaurant.option"
  """
  insert_restaurant_option(
    """the rows to be inserted"""
    objects: [restaurant_option_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option_mutation_response

  """
  insert data into the table: "restaurant.option_choice_map"
  """
  insert_restaurant_option_choice_map(
    """the rows to be inserted"""
    objects: [restaurant_option_choice_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map_mutation_response

  """
  insert a single row into the table: "restaurant.option_choice_map"
  """
  insert_restaurant_option_choice_map_one(
    """the row to be inserted"""
    object: restaurant_option_choice_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map

  """
  insert a single row into the table: "restaurant.option"
  """
  insert_restaurant_option_one(
    """the row to be inserted"""
    object: restaurant_option_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option

  """
  insert data into the table: "restaurant.order"
  """
  insert_restaurant_order(
    """the rows to be inserted"""
    objects: [restaurant_order_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order_mutation_response

  """
  insert data into the table: "restaurant.order_item"
  """
  insert_restaurant_order_item(
    """the rows to be inserted"""
    objects: [restaurant_order_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item_mutation_response

  """
  insert a single row into the table: "restaurant.order_item"
  """
  insert_restaurant_order_item_one(
    """the row to be inserted"""
    object: restaurant_order_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item

  """
  insert a single row into the table: "restaurant.order"
  """
  insert_restaurant_order_one(
    """the row to be inserted"""
    object: restaurant_order_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order

  """
  insert data into the table: "restaurant.order_public"
  """
  insert_restaurant_order_public(
    """the rows to be inserted"""
    objects: [restaurant_order_public_insert_input!]!
  ): restaurant_order_public_mutation_response

  """
  insert a single row into the table: "restaurant.order_public"
  """
  insert_restaurant_order_public_one(
    """the row to be inserted"""
    object: restaurant_order_public_insert_input!
  ): restaurant_order_public

  """
  insert data into the table: "restaurant.restaurant"
  """
  insert_restaurant_restaurant(
    """the rows to be inserted"""
    objects: [restaurant_restaurant_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_restaurant_on_conflict
  ): restaurant_restaurant_mutation_response

  """
  insert a single row into the table: "restaurant.restaurant"
  """
  insert_restaurant_restaurant_one(
    """the row to be inserted"""
    object: restaurant_restaurant_insert_input!

    """upsert condition"""
    on_conflict: restaurant_restaurant_on_conflict
  ): restaurant_restaurant

  """
  insert data into the table: "review"
  """
  insert_review(
    """the rows to be inserted"""
    objects: [review_insert_input!]!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review_mutation_response

  """
  insert a single row into the table: "review"
  """
  insert_review_one(
    """the row to be inserted"""
    object: review_insert_input!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review

  """
  insert data into the table: "service_provider_customer_chat"
  """
  insert_service_provider_customer_chat(
    """the rows to be inserted"""
    objects: [service_provider_customer_chat_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_customer_chat_on_conflict
  ): service_provider_customer_chat_mutation_response

  """
  insert a single row into the table: "service_provider_customer_chat"
  """
  insert_service_provider_customer_chat_one(
    """the row to be inserted"""
    object: service_provider_customer_chat_insert_input!

    """upsert condition"""
    on_conflict: service_provider_customer_chat_on_conflict
  ): service_provider_customer_chat

  """
  insert data into the table: "service_provider.delivery_partner"
  """
  insert_service_provider_delivery_partner(
    """the rows to be inserted"""
    objects: [service_provider_delivery_partner_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_delivery_partner_on_conflict
  ): service_provider_delivery_partner_mutation_response

  """
  insert a single row into the table: "service_provider.delivery_partner"
  """
  insert_service_provider_delivery_partner_one(
    """the row to be inserted"""
    object: service_provider_delivery_partner_insert_input!

    """upsert condition"""
    on_conflict: service_provider_delivery_partner_on_conflict
  ): service_provider_delivery_partner

  """
  insert data into the table: "service_provider.location"
  """
  insert_service_provider_location(
    """the rows to be inserted"""
    objects: [service_provider_location_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_location_on_conflict
  ): service_provider_location_mutation_response

  """
  insert a single row into the table: "service_provider.location"
  """
  insert_service_provider_location_one(
    """the row to be inserted"""
    object: service_provider_location_insert_input!

    """upsert condition"""
    on_conflict: service_provider_location_on_conflict
  ): service_provider_location

  """
  insert data into the table: "service_provider.post"
  """
  insert_service_provider_post(
    """the rows to be inserted"""
    objects: [service_provider_post_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_post_on_conflict
  ): service_provider_post_mutation_response

  """
  insert a single row into the table: "service_provider.post"
  """
  insert_service_provider_post_one(
    """the row to be inserted"""
    object: service_provider_post_insert_input!

    """upsert condition"""
    on_conflict: service_provider_post_on_conflict
  ): service_provider_post

  """
  insert data into the table: "service_provider.service_link"
  """
  insert_service_provider_service_link(
    """the rows to be inserted"""
    objects: [service_provider_service_link_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_service_link_on_conflict
  ): service_provider_service_link_mutation_response

  """
  insert a single row into the table: "service_provider.service_link"
  """
  insert_service_provider_service_link_one(
    """the row to be inserted"""
    object: service_provider_service_link_insert_input!

    """upsert condition"""
    on_conflict: service_provider_service_link_on_conflict
  ): service_provider_service_link

  """
  insert data into the table: "service_provider.subscriber"
  """
  insert_service_provider_subscriber(
    """the rows to be inserted"""
    objects: [service_provider_subscriber_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_subscriber_on_conflict
  ): service_provider_subscriber_mutation_response

  """
  insert a single row into the table: "service_provider.subscriber"
  """
  insert_service_provider_subscriber_one(
    """the row to be inserted"""
    object: service_provider_subscriber_insert_input!

    """upsert condition"""
    on_conflict: service_provider_subscriber_on_conflict
  ): service_provider_subscriber

  """
  insert data into the table: "translation"
  """
  insert_translation(
    """the rows to be inserted"""
    objects: [translation_insert_input!]!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation_mutation_response

  """
  insert a single row into the table: "translation"
  """
  insert_translation_one(
    """the row to be inserted"""
    object: translation_insert_input!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation

  """
  insert data into the table: "translation_value"
  """
  insert_translation_value(
    """the rows to be inserted"""
    objects: [translation_value_insert_input!]!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value_mutation_response

  """
  insert a single row into the table: "translation_value"
  """
  insert_translation_value_one(
    """the row to be inserted"""
    object: translation_value_insert_input!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "app_type"
  """
  update_app_type(
    """sets the columns of the filtered rows to the given values"""
    _set: app_type_set_input

    """filter the rows which have to be updated"""
    where: app_type_bool_exp!
  ): app_type_mutation_response

  """
  update single row of the table: "app_type"
  """
  update_app_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: app_type_set_input
    pk_columns: app_type_pk_columns_input!
  ): app_type

  """
  update multiples rows of table: "app_type"
  """
  update_app_type_many(
    """updates to execute, in order"""
    updates: [app_type_updates!]!
  ): [app_type_mutation_response]

  """
  update data of the table: "chat"
  """
  update_chat(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input

    """filter the rows which have to be updated"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  update single row of the table: "chat"
  """
  update_chat_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input
    pk_columns: chat_pk_columns_input!
  ): chat

  """
  update multiples rows of table: "chat"
  """
  update_chat_many(
    """updates to execute, in order"""
    updates: [chat_updates!]!
  ): [chat_mutation_response]

  """
  update data of the table: "chat_participant"
  """
  update_chat_participant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input

    """filter the rows which have to be updated"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  update single row of the table: "chat_participant"
  """
  update_chat_participant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input
    pk_columns: chat_participant_pk_columns_input!
  ): chat_participant

  """
  update multiples rows of table: "chat_participant"
  """
  update_chat_participant_many(
    """updates to execute, in order"""
    updates: [chat_participant_updates!]!
  ): [chat_participant_mutation_response]

  """
  update data of the table: "customer.customer"
  """
  update_customer_customer(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customer_customer_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customer_customer_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: customer_customer_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customer_customer_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_customer_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customer_customer_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_customer_set_input

    """filter the rows which have to be updated"""
    where: customer_customer_bool_exp!
  ): customer_customer_mutation_response

  """
  update single row of the table: "customer.customer"
  """
  update_customer_customer_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customer_customer_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customer_customer_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: customer_customer_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customer_customer_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_customer_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customer_customer_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_customer_set_input
    pk_columns: customer_customer_pk_columns_input!
  ): customer_customer

  """
  update multiples rows of table: "customer.customer"
  """
  update_customer_customer_many(
    """updates to execute, in order"""
    updates: [customer_customer_updates!]!
  ): [customer_customer_mutation_response]

  """
  update data of the table: "customer.favourited_item"
  """
  update_customer_favourited_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_favourited_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_favourited_item_set_input

    """filter the rows which have to be updated"""
    where: customer_favourited_item_bool_exp!
  ): customer_favourited_item_mutation_response

  """
  update single row of the table: "customer.favourited_item"
  """
  update_customer_favourited_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_favourited_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_favourited_item_set_input
    pk_columns: customer_favourited_item_pk_columns_input!
  ): customer_favourited_item

  """
  update multiples rows of table: "customer.favourited_item"
  """
  update_customer_favourited_item_many(
    """updates to execute, in order"""
    updates: [customer_favourited_item_updates!]!
  ): [customer_favourited_item_mutation_response]

  """
  update data of the table: "customer.saved_location"
  """
  update_customer_saved_location(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_saved_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_saved_location_set_input

    """filter the rows which have to be updated"""
    where: customer_saved_location_bool_exp!
  ): customer_saved_location_mutation_response

  """
  update single row of the table: "customer.saved_location"
  """
  update_customer_saved_location_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_saved_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_saved_location_set_input
    pk_columns: customer_saved_location_pk_columns_input!
  ): customer_saved_location

  """
  update multiples rows of table: "customer.saved_location"
  """
  update_customer_saved_location_many(
    """updates to execute, in order"""
    updates: [customer_saved_location_updates!]!
  ): [customer_saved_location_mutation_response]

  """
  update data of the table: "delivery.company"
  """
  update_delivery_company(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_company_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_company_set_input

    """filter the rows which have to be updated"""
    where: delivery_company_bool_exp!
  ): delivery_company_mutation_response

  """
  update single row of the table: "delivery.company"
  """
  update_delivery_company_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_company_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_company_set_input
    pk_columns: delivery_company_pk_columns_input!
  ): delivery_company

  """
  update multiples rows of table: "delivery.company"
  """
  update_delivery_company_many(
    """updates to execute, in order"""
    updates: [delivery_company_updates!]!
  ): [delivery_company_mutation_response]

  """
  update data of the table: "delivery.details"
  """
  update_delivery_details(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_details_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_details_set_input

    """filter the rows which have to be updated"""
    where: delivery_details_bool_exp!
  ): delivery_details_mutation_response

  """
  update single row of the table: "delivery.details"
  """
  update_delivery_details_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_details_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_details_set_input
    pk_columns: delivery_details_pk_columns_input!
  ): delivery_details

  """
  update multiples rows of table: "delivery.details"
  """
  update_delivery_details_many(
    """updates to execute, in order"""
    updates: [delivery_details_updates!]!
  ): [delivery_details_mutation_response]

  """
  update data of the table: "delivery.driver"
  """
  update_delivery_driver(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_driver_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_driver_set_input

    """filter the rows which have to be updated"""
    where: delivery_driver_bool_exp!
  ): delivery_driver_mutation_response

  """
  update single row of the table: "delivery.driver"
  """
  update_delivery_driver_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_driver_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_driver_set_input
    pk_columns: delivery_driver_pk_columns_input!
  ): delivery_driver

  """
  update multiples rows of table: "delivery.driver"
  """
  update_delivery_driver_many(
    """updates to execute, in order"""
    updates: [delivery_driver_updates!]!
  ): [delivery_driver_mutation_response]

  """
  update data of the table: "delivery.operator"
  """
  update_delivery_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_operator_set_input

    """filter the rows which have to be updated"""
    where: delivery_operator_bool_exp!
  ): delivery_operator_mutation_response

  """
  update single row of the table: "delivery.operator"
  """
  update_delivery_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_operator_set_input
    pk_columns: delivery_operator_pk_columns_input!
  ): delivery_operator

  """
  update multiples rows of table: "delivery.operator"
  """
  update_delivery_operator_many(
    """updates to execute, in order"""
    updates: [delivery_operator_updates!]!
  ): [delivery_operator_mutation_response]

  """
  update data of the table: "delivery.order"
  """
  update_delivery_order(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_set_input

    """filter the rows which have to be updated"""
    where: delivery_order_bool_exp!
  ): delivery_order_mutation_response

  """
  update single row of the table: "delivery.order"
  """
  update_delivery_order_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_set_input
    pk_columns: delivery_order_pk_columns_input!
  ): delivery_order

  """
  update multiples rows of table: "delivery.order"
  """
  update_delivery_order_many(
    """updates to execute, in order"""
    updates: [delivery_order_updates!]!
  ): [delivery_order_mutation_response]

  """
  update data of the table: "delivery.order_public"
  """
  update_delivery_order_public(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_public_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_public_set_input

    """filter the rows which have to be updated"""
    where: delivery_order_public_bool_exp!
  ): delivery_order_public_mutation_response

  """
  update multiples rows of table: "delivery.order_public"
  """
  update_delivery_order_public_many(
    """updates to execute, in order"""
    updates: [delivery_order_public_updates!]!
  ): [delivery_order_public_mutation_response]

  """
  update data of the table: "direct_chat"
  """
  update_direct_chat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: direct_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: direct_chat_set_input

    """filter the rows which have to be updated"""
    where: direct_chat_bool_exp!
  ): direct_chat_mutation_response

  """
  update single row of the table: "direct_chat"
  """
  update_direct_chat_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: direct_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: direct_chat_set_input
    pk_columns: direct_chat_pk_columns_input!
  ): direct_chat

  """
  update multiples rows of table: "direct_chat"
  """
  update_direct_chat_many(
    """updates to execute, in order"""
    updates: [direct_chat_updates!]!
  ): [direct_chat_mutation_response]

  """
  update data of the table: "language"
  """
  update_language(
    """sets the columns of the filtered rows to the given values"""
    _set: language_set_input

    """filter the rows which have to be updated"""
    where: language_bool_exp!
  ): language_mutation_response

  """
  update single row of the table: "language"
  """
  update_language_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: language_set_input
    pk_columns: language_pk_columns_input!
  ): language

  """
  update multiples rows of table: "language"
  """
  update_language_many(
    """updates to execute, in order"""
    updates: [language_updates!]!
  ): [language_mutation_response]

  """
  update data of the table: "laundry.category"
  """
  update_laundry_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_category_set_input

    """filter the rows which have to be updated"""
    where: laundry_category_bool_exp!
  ): laundry_category_mutation_response

  """
  update single row of the table: "laundry.category"
  """
  update_laundry_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_category_set_input
    pk_columns: laundry_category_pk_columns_input!
  ): laundry_category

  """
  update multiples rows of table: "laundry.category"
  """
  update_laundry_category_many(
    """updates to execute, in order"""
    updates: [laundry_category_updates!]!
  ): [laundry_category_mutation_response]

  """
  update data of the table: "laundry.operator"
  """
  update_laundry_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_operator_set_input

    """filter the rows which have to be updated"""
    where: laundry_operator_bool_exp!
  ): laundry_operator_mutation_response

  """
  update single row of the table: "laundry.operator"
  """
  update_laundry_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_operator_set_input
    pk_columns: laundry_operator_pk_columns_input!
  ): laundry_operator

  """
  update multiples rows of table: "laundry.operator"
  """
  update_laundry_operator_many(
    """updates to execute, in order"""
    updates: [laundry_operator_updates!]!
  ): [laundry_operator_mutation_response]

  """
  update data of the table: "laundry.order"
  """
  update_laundry_order(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: laundry_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: laundry_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: laundry_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: laundry_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: laundry_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_order_set_input

    """filter the rows which have to be updated"""
    where: laundry_order_bool_exp!
  ): laundry_order_mutation_response

  """
  update single row of the table: "laundry.order"
  """
  update_laundry_order_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: laundry_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: laundry_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: laundry_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: laundry_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: laundry_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_order_set_input
    pk_columns: laundry_order_pk_columns_input!
  ): laundry_order

  """
  update data of the table: "laundry.order_category"
  """
  update_laundry_order_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_order_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_order_category_set_input

    """filter the rows which have to be updated"""
    where: laundry_order_category_bool_exp!
  ): laundry_order_category_mutation_response

  """
  update single row of the table: "laundry.order_category"
  """
  update_laundry_order_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_order_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_order_category_set_input
    pk_columns: laundry_order_category_pk_columns_input!
  ): laundry_order_category

  """
  update multiples rows of table: "laundry.order_category"
  """
  update_laundry_order_category_many(
    """updates to execute, in order"""
    updates: [laundry_order_category_updates!]!
  ): [laundry_order_category_mutation_response]

  """
  update multiples rows of table: "laundry.order"
  """
  update_laundry_order_many(
    """updates to execute, in order"""
    updates: [laundry_order_updates!]!
  ): [laundry_order_mutation_response]

  """
  update data of the table: "laundry.store"
  """
  update_laundry_store(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: laundry_store_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: laundry_store_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: laundry_store_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: laundry_store_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_store_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: laundry_store_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_store_set_input

    """filter the rows which have to be updated"""
    where: laundry_store_bool_exp!
  ): laundry_store_mutation_response

  """
  update single row of the table: "laundry.store"
  """
  update_laundry_store_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: laundry_store_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: laundry_store_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: laundry_store_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: laundry_store_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: laundry_store_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: laundry_store_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: laundry_store_set_input
    pk_columns: laundry_store_pk_columns_input!
  ): laundry_store

  """
  update multiples rows of table: "laundry.store"
  """
  update_laundry_store_many(
    """updates to execute, in order"""
    updates: [laundry_store_updates!]!
  ): [laundry_store_mutation_response]

  """
  update data of the table: "mez_admin"
  """
  update_mez_admin(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input

    """filter the rows which have to be updated"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  update single row of the table: "mez_admin"
  """
  update_mez_admin_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input
    pk_columns: mez_admin_pk_columns_input!
  ): mez_admin

  """
  update data of the table: "mez_admin_chat"
  """
  update_mez_admin_chat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_chat_set_input

    """filter the rows which have to be updated"""
    where: mez_admin_chat_bool_exp!
  ): mez_admin_chat_mutation_response

  """
  update single row of the table: "mez_admin_chat"
  """
  update_mez_admin_chat_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_chat_set_input
    pk_columns: mez_admin_chat_pk_columns_input!
  ): mez_admin_chat

  """
  update multiples rows of table: "mez_admin_chat"
  """
  update_mez_admin_chat_many(
    """updates to execute, in order"""
    updates: [mez_admin_chat_updates!]!
  ): [mez_admin_chat_mutation_response]

  """
  update multiples rows of table: "mez_admin"
  """
  update_mez_admin_many(
    """updates to execute, in order"""
    updates: [mez_admin_updates!]!
  ): [mez_admin_mutation_response]

  """
  update data of the table: "mez_json"
  """
  update_mez_json(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: mez_json_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: mez_json_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: mez_json_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: mez_json_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: mez_json_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_json_set_input

    """filter the rows which have to be updated"""
    where: mez_json_bool_exp!
  ): mez_json_mutation_response

  """
  update single row of the table: "mez_json"
  """
  update_mez_json_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: mez_json_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: mez_json_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: mez_json_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: mez_json_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: mez_json_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_json_set_input
    pk_columns: mez_json_pk_columns_input!
  ): mez_json

  """
  update multiples rows of table: "mez_json"
  """
  update_mez_json_many(
    """updates to execute, in order"""
    updates: [mez_json_updates!]!
  ): [mez_json_mutation_response]

  """
  update data of the table: "notification_info"
  """
  update_notification_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input

    """filter the rows which have to be updated"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  update single row of the table: "notification_info"
  """
  update_notification_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input
    pk_columns: notification_info_pk_columns_input!
  ): notification_info

  """
  update multiples rows of table: "notification_info"
  """
  update_notification_info_many(
    """updates to execute, in order"""
    updates: [notification_info_updates!]!
  ): [notification_info_mutation_response]

  """
  update data of the table: "restaurant.cart"
  """
  update_restaurant_cart(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  update single row of the table: "restaurant.cart"
  """
  update_restaurant_cart_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input
    pk_columns: restaurant_cart_pk_columns_input!
  ): restaurant_cart

  """
  update data of the table: "restaurant.cart_item"
  """
  update_restaurant_cart_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  update single row of the table: "restaurant.cart_item"
  """
  update_restaurant_cart_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input
    pk_columns: restaurant_cart_item_pk_columns_input!
  ): restaurant_cart_item

  """
  update multiples rows of table: "restaurant.cart_item"
  """
  update_restaurant_cart_item_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_item_updates!]!
  ): [restaurant_cart_item_mutation_response]

  """
  update multiples rows of table: "restaurant.cart"
  """
  update_restaurant_cart_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_updates!]!
  ): [restaurant_cart_mutation_response]

  """
  update data of the table: "restaurant.category"
  """
  update_restaurant_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input

    """filter the rows which have to be updated"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  update single row of the table: "restaurant.category"
  """
  update_restaurant_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input
    pk_columns: restaurant_category_pk_columns_input!
  ): restaurant_category

  """
  update multiples rows of table: "restaurant.category"
  """
  update_restaurant_category_many(
    """updates to execute, in order"""
    updates: [restaurant_category_updates!]!
  ): [restaurant_category_mutation_response]

  """
  update data of the table: "restaurant.choice"
  """
  update_restaurant_choice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input

    """filter the rows which have to be updated"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  update single row of the table: "restaurant.choice"
  """
  update_restaurant_choice_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input
    pk_columns: restaurant_choice_pk_columns_input!
  ): restaurant_choice

  """
  update multiples rows of table: "restaurant.choice"
  """
  update_restaurant_choice_many(
    """updates to execute, in order"""
    updates: [restaurant_choice_updates!]!
  ): [restaurant_choice_mutation_response]

  """
  update data of the table: "restaurant.item"
  """
  update_restaurant_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  update single row of the table: "restaurant.item"
  """
  update_restaurant_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input
    pk_columns: restaurant_item_pk_columns_input!
  ): restaurant_item

  """
  update multiples rows of table: "restaurant.item"
  """
  update_restaurant_item_many(
    """updates to execute, in order"""
    updates: [restaurant_item_updates!]!
  ): [restaurant_item_mutation_response]

  """
  update data of the table: "restaurant.item_option_map"
  """
  update_restaurant_item_option_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  update single row of the table: "restaurant.item_option_map"
  """
  update_restaurant_item_option_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input
    pk_columns: restaurant_item_option_map_pk_columns_input!
  ): restaurant_item_option_map

  """
  update multiples rows of table: "restaurant.item_option_map"
  """
  update_restaurant_item_option_map_many(
    """updates to execute, in order"""
    updates: [restaurant_item_option_map_updates!]!
  ): [restaurant_item_option_map_mutation_response]

  """
  update data of the table: "restaurant.operator"
  """
  update_restaurant_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input

    """filter the rows which have to be updated"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  update single row of the table: "restaurant.operator"
  """
  update_restaurant_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input
    pk_columns: restaurant_operator_pk_columns_input!
  ): restaurant_operator

  """
  update multiples rows of table: "restaurant.operator"
  """
  update_restaurant_operator_many(
    """updates to execute, in order"""
    updates: [restaurant_operator_updates!]!
  ): [restaurant_operator_mutation_response]

  """
  update data of the table: "restaurant.option"
  """
  update_restaurant_option(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  update single row of the table: "restaurant.option"
  """
  update_restaurant_option_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input
    pk_columns: restaurant_option_pk_columns_input!
  ): restaurant_option

  """
  update data of the table: "restaurant.option_choice_map"
  """
  update_restaurant_option_choice_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  update single row of the table: "restaurant.option_choice_map"
  """
  update_restaurant_option_choice_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input
    pk_columns: restaurant_option_choice_map_pk_columns_input!
  ): restaurant_option_choice_map

  """
  update multiples rows of table: "restaurant.option_choice_map"
  """
  update_restaurant_option_choice_map_many(
    """updates to execute, in order"""
    updates: [restaurant_option_choice_map_updates!]!
  ): [restaurant_option_choice_map_mutation_response]

  """
  update multiples rows of table: "restaurant.option"
  """
  update_restaurant_option_many(
    """updates to execute, in order"""
    updates: [restaurant_option_updates!]!
  ): [restaurant_option_mutation_response]

  """
  update data of the table: "restaurant.order"
  """
  update_restaurant_order(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  update single row of the table: "restaurant.order"
  """
  update_restaurant_order_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input
    pk_columns: restaurant_order_pk_columns_input!
  ): restaurant_order

  """
  update data of the table: "restaurant.order_item"
  """
  update_restaurant_order_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  update single row of the table: "restaurant.order_item"
  """
  update_restaurant_order_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input
    pk_columns: restaurant_order_item_pk_columns_input!
  ): restaurant_order_item

  """
  update multiples rows of table: "restaurant.order_item"
  """
  update_restaurant_order_item_many(
    """updates to execute, in order"""
    updates: [restaurant_order_item_updates!]!
  ): [restaurant_order_item_mutation_response]

  """
  update multiples rows of table: "restaurant.order"
  """
  update_restaurant_order_many(
    """updates to execute, in order"""
    updates: [restaurant_order_updates!]!
  ): [restaurant_order_mutation_response]

  """
  update data of the table: "restaurant.order_public"
  """
  update_restaurant_order_public(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_public_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_public_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_public_bool_exp!
  ): restaurant_order_public_mutation_response

  """
  update multiples rows of table: "restaurant.order_public"
  """
  update_restaurant_order_public_many(
    """updates to execute, in order"""
    updates: [restaurant_order_public_updates!]!
  ): [restaurant_order_public_mutation_response]

  """
  update data of the table: "restaurant.restaurant"
  """
  update_restaurant_restaurant(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_restaurant_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_restaurant_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_restaurant_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_restaurant_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_restaurant_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_restaurant_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_restaurant_set_input

    """filter the rows which have to be updated"""
    where: restaurant_restaurant_bool_exp!
  ): restaurant_restaurant_mutation_response

  """
  update single row of the table: "restaurant.restaurant"
  """
  update_restaurant_restaurant_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_restaurant_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_restaurant_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_restaurant_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_restaurant_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_restaurant_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_restaurant_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_restaurant_set_input
    pk_columns: restaurant_restaurant_pk_columns_input!
  ): restaurant_restaurant

  """
  update multiples rows of table: "restaurant.restaurant"
  """
  update_restaurant_restaurant_many(
    """updates to execute, in order"""
    updates: [restaurant_restaurant_updates!]!
  ): [restaurant_restaurant_mutation_response]

  """
  update data of the table: "review"
  """
  update_review(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input

    """filter the rows which have to be updated"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  update single row of the table: "review"
  """
  update_review_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  """
  update multiples rows of table: "review"
  """
  update_review_many(
    """updates to execute, in order"""
    updates: [review_updates!]!
  ): [review_mutation_response]

  """
  update data of the table: "service_provider_customer_chat"
  """
  update_service_provider_customer_chat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_customer_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_customer_chat_set_input

    """filter the rows which have to be updated"""
    where: service_provider_customer_chat_bool_exp!
  ): service_provider_customer_chat_mutation_response

  """
  update single row of the table: "service_provider_customer_chat"
  """
  update_service_provider_customer_chat_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_customer_chat_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_customer_chat_set_input
    pk_columns: service_provider_customer_chat_pk_columns_input!
  ): service_provider_customer_chat

  """
  update multiples rows of table: "service_provider_customer_chat"
  """
  update_service_provider_customer_chat_many(
    """updates to execute, in order"""
    updates: [service_provider_customer_chat_updates!]!
  ): [service_provider_customer_chat_mutation_response]

  """
  update data of the table: "service_provider.delivery_partner"
  """
  update_service_provider_delivery_partner(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_delivery_partner_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_delivery_partner_set_input

    """filter the rows which have to be updated"""
    where: service_provider_delivery_partner_bool_exp!
  ): service_provider_delivery_partner_mutation_response

  """
  update single row of the table: "service_provider.delivery_partner"
  """
  update_service_provider_delivery_partner_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_delivery_partner_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_delivery_partner_set_input
    pk_columns: service_provider_delivery_partner_pk_columns_input!
  ): service_provider_delivery_partner

  """
  update multiples rows of table: "service_provider.delivery_partner"
  """
  update_service_provider_delivery_partner_many(
    """updates to execute, in order"""
    updates: [service_provider_delivery_partner_updates!]!
  ): [service_provider_delivery_partner_mutation_response]

  """
  update data of the table: "service_provider.location"
  """
  update_service_provider_location(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_location_set_input

    """filter the rows which have to be updated"""
    where: service_provider_location_bool_exp!
  ): service_provider_location_mutation_response

  """
  update single row of the table: "service_provider.location"
  """
  update_service_provider_location_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_location_set_input
    pk_columns: service_provider_location_pk_columns_input!
  ): service_provider_location

  """
  update multiples rows of table: "service_provider.location"
  """
  update_service_provider_location_many(
    """updates to execute, in order"""
    updates: [service_provider_location_updates!]!
  ): [service_provider_location_mutation_response]

  """
  update data of the table: "service_provider.post"
  """
  update_service_provider_post(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: service_provider_post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: service_provider_post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: service_provider_post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: service_provider_post_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_post_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: service_provider_post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_post_set_input

    """filter the rows which have to be updated"""
    where: service_provider_post_bool_exp!
  ): service_provider_post_mutation_response

  """
  update single row of the table: "service_provider.post"
  """
  update_service_provider_post_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: service_provider_post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: service_provider_post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: service_provider_post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: service_provider_post_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_post_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: service_provider_post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_post_set_input
    pk_columns: service_provider_post_pk_columns_input!
  ): service_provider_post

  """
  update multiples rows of table: "service_provider.post"
  """
  update_service_provider_post_many(
    """updates to execute, in order"""
    updates: [service_provider_post_updates!]!
  ): [service_provider_post_mutation_response]

  """
  update data of the table: "service_provider.service_link"
  """
  update_service_provider_service_link(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_service_link_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_service_link_set_input

    """filter the rows which have to be updated"""
    where: service_provider_service_link_bool_exp!
  ): service_provider_service_link_mutation_response

  """
  update single row of the table: "service_provider.service_link"
  """
  update_service_provider_service_link_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_service_link_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_service_link_set_input
    pk_columns: service_provider_service_link_pk_columns_input!
  ): service_provider_service_link

  """
  update multiples rows of table: "service_provider.service_link"
  """
  update_service_provider_service_link_many(
    """updates to execute, in order"""
    updates: [service_provider_service_link_updates!]!
  ): [service_provider_service_link_mutation_response]

  """
  update data of the table: "service_provider.subscriber"
  """
  update_service_provider_subscriber(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_subscriber_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_subscriber_set_input

    """filter the rows which have to be updated"""
    where: service_provider_subscriber_bool_exp!
  ): service_provider_subscriber_mutation_response

  """
  update single row of the table: "service_provider.subscriber"
  """
  update_service_provider_subscriber_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_subscriber_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_subscriber_set_input
    pk_columns: service_provider_subscriber_pk_columns_input!
  ): service_provider_subscriber

  """
  update multiples rows of table: "service_provider.subscriber"
  """
  update_service_provider_subscriber_many(
    """updates to execute, in order"""
    updates: [service_provider_subscriber_updates!]!
  ): [service_provider_subscriber_mutation_response]

  """
  update data of the table: "translation"
  """
  update_translation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input

    """filter the rows which have to be updated"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  update single row of the table: "translation"
  """
  update_translation_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input
    pk_columns: translation_pk_columns_input!
  ): translation

  """
  update multiples rows of table: "translation"
  """
  update_translation_many(
    """updates to execute, in order"""
    updates: [translation_updates!]!
  ): [translation_mutation_response]

  """
  update data of the table: "translation_value"
  """
  update_translation_value(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input

    """filter the rows which have to be updated"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  update single row of the table: "translation_value"
  """
  update_translation_value_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input
    pk_columns: translation_value_pk_columns_input!
  ): translation_value

  """
  update multiples rows of table: "translation_value"
  """
  update_translation_value_many(
    """updates to execute, in order"""
    updates: [translation_value_updates!]!
  ): [translation_value_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

"""
columns and relationships of "notification_info"
"""
type notification_info {
  app_type_id: String!
  id: Int!
  token: String!
  turn_off_notifications: Boolean!
  user_id: Int!
}

"""
aggregated selection of "notification_info"
"""
type notification_info_aggregate {
  aggregate: notification_info_aggregate_fields
  nodes: [notification_info!]!
}

"""
aggregate fields of "notification_info"
"""
type notification_info_aggregate_fields {
  avg: notification_info_avg_fields
  count(columns: [notification_info_select_column!], distinct: Boolean): Int!
  max: notification_info_max_fields
  min: notification_info_min_fields
  stddev: notification_info_stddev_fields
  stddev_pop: notification_info_stddev_pop_fields
  stddev_samp: notification_info_stddev_samp_fields
  sum: notification_info_sum_fields
  var_pop: notification_info_var_pop_fields
  var_samp: notification_info_var_samp_fields
  variance: notification_info_variance_fields
}

"""aggregate avg on columns"""
type notification_info_avg_fields {
  id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "notification_info". All fields are combined with a logical 'AND'.
"""
input notification_info_bool_exp {
  _and: [notification_info_bool_exp!]
  _not: notification_info_bool_exp
  _or: [notification_info_bool_exp!]
  app_type_id: String_comparison_exp
  id: Int_comparison_exp
  token: String_comparison_exp
  turn_off_notifications: Boolean_comparison_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "notification_info"
"""
enum notification_info_constraint {
  """
  unique or primary key constraint on columns "app_type_id", "user_id"
  """
  notification_info_app_type_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  notification_info_pkey

  """
  unique or primary key constraint on columns "app_type_id", "user_id"
  """
  notification_info_user_id_app_type_id_key
}

"""
input type for incrementing numeric columns in table "notification_info"
"""
input notification_info_inc_input {
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "notification_info"
"""
input notification_info_insert_input {
  app_type_id: String
  id: Int
  token: String
  turn_off_notifications: Boolean
  user_id: Int
}

"""aggregate max on columns"""
type notification_info_max_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate min on columns"""
type notification_info_min_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""
response of any mutation on the table "notification_info"
"""
type notification_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification_info!]!
}

"""
input type for inserting object relation for remote table "notification_info"
"""
input notification_info_obj_rel_insert_input {
  data: notification_info_insert_input!

  """upsert condition"""
  on_conflict: notification_info_on_conflict
}

"""
on_conflict condition type for table "notification_info"
"""
input notification_info_on_conflict {
  constraint: notification_info_constraint!
  update_columns: [notification_info_update_column!]! = []
  where: notification_info_bool_exp
}

"""Ordering options when selecting data from "notification_info"."""
input notification_info_order_by {
  app_type_id: order_by
  id: order_by
  token: order_by
  turn_off_notifications: order_by
  user_id: order_by
}

"""primary key columns input for table: notification_info"""
input notification_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "notification_info"
"""
enum notification_info_select_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  turn_off_notifications

  """column name"""
  user_id
}

"""
input type for updating data in table "notification_info"
"""
input notification_info_set_input {
  app_type_id: String
  id: Int
  token: String
  turn_off_notifications: Boolean
  user_id: Int
}

"""aggregate stddev on columns"""
type notification_info_stddev_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type notification_info_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type notification_info_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
Streaming cursor of the table "notification_info"
"""
input notification_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_info_stream_cursor_value_input {
  app_type_id: String
  id: Int
  token: String
  turn_off_notifications: Boolean
  user_id: Int
}

"""aggregate sum on columns"""
type notification_info_sum_fields {
  id: Int
  user_id: Int
}

"""
update columns of table "notification_info"
"""
enum notification_info_update_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  turn_off_notifications

  """column name"""
  user_id
}

input notification_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: notification_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: notification_info_set_input

  """filter the rows which have to be updated"""
  where: notification_info_bool_exp!
}

"""aggregate var_pop on columns"""
type notification_info_var_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type notification_info_var_samp_fields {
  id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type notification_info_variance_fields {
  id: Float
  user_id: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "app_type"
  """
  app_type(
    """distinct select on columns"""
    distinct_on: [app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_type_order_by!]

    """filter the rows returned"""
    where: app_type_bool_exp
  ): [app_type!]!

  """
  fetch aggregated fields from the table: "app_type"
  """
  app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_type_order_by!]

    """filter the rows returned"""
    where: app_type_bool_exp
  ): app_type_aggregate!

  """fetch data from the table: "app_type" using primary key columns"""
  app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): app_type

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table: "customer.customer"
  """
  customer_customer(
    """distinct select on columns"""
    distinct_on: [customer_customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_customer_order_by!]

    """filter the rows returned"""
    where: customer_customer_bool_exp
  ): [customer_customer!]!

  """
  fetch aggregated fields from the table: "customer.customer"
  """
  customer_customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_customer_order_by!]

    """filter the rows returned"""
    where: customer_customer_bool_exp
  ): customer_customer_aggregate!

  """
  fetch data from the table: "customer.customer" using primary key columns
  """
  customer_customer_by_pk(user_id: Int!): customer_customer

  """
  fetch data from the table: "customer.favourited_item"
  """
  customer_favourited_item(
    """distinct select on columns"""
    distinct_on: [customer_favourited_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_favourited_item_order_by!]

    """filter the rows returned"""
    where: customer_favourited_item_bool_exp
  ): [customer_favourited_item!]!

  """
  fetch aggregated fields from the table: "customer.favourited_item"
  """
  customer_favourited_item_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_favourited_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_favourited_item_order_by!]

    """filter the rows returned"""
    where: customer_favourited_item_bool_exp
  ): customer_favourited_item_aggregate!

  """
  fetch data from the table: "customer.favourited_item" using primary key columns
  """
  customer_favourited_item_by_pk(id: Int!): customer_favourited_item

  """
  fetch data from the table: "customer.saved_location"
  """
  customer_saved_location(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): [customer_saved_location!]!

  """
  fetch aggregated fields from the table: "customer.saved_location"
  """
  customer_saved_location_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): customer_saved_location_aggregate!

  """
  fetch data from the table: "customer.saved_location" using primary key columns
  """
  customer_saved_location_by_pk(id: Int!): customer_saved_location

  """An array relationship"""
  delivery_company(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """An aggregate relationship"""
  delivery_company_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery.company" using primary key columns
  """
  delivery_company_by_pk(id: Int!): delivery_company

  """
  fetch data from the table: "delivery.details"
  """
  delivery_details(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): [delivery_details!]!

  """
  fetch aggregated fields from the table: "delivery.details"
  """
  delivery_details_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): delivery_details_aggregate!

  """
  fetch data from the table: "delivery.details" using primary key columns
  """
  delivery_details_by_pk(id: Int!): delivery_details

  """
  fetch data from the table: "delivery.driver"
  """
  delivery_driver(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  fetch aggregated fields from the table: "delivery.driver"
  """
  delivery_driver_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """fetch data from the table: "delivery.driver" using primary key columns"""
  delivery_driver_by_pk(id: Int!): delivery_driver

  """
  execute function "delivery.get_delivery_companies" which returns "delivery.company"
  """
  delivery_get_delivery_companies(
    """
    input parameters for function "delivery_get_delivery_companies"
    """
    args: delivery_get_delivery_companies_args!

    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  execute function "delivery.get_delivery_companies" and query aggregates on result of table type "delivery.company"
  """
  delivery_get_delivery_companies_aggregate(
    """
    input parameters for function "delivery_get_delivery_companies_aggregate"
    """
    args: delivery_get_delivery_companies_args!

    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery.operator"
  """
  delivery_operator(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch aggregated fields from the table: "delivery.operator"
  """
  delivery_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """
  fetch data from the table: "delivery.operator" using primary key columns
  """
  delivery_operator_by_pk(id: Int!): delivery_operator

  """
  fetch data from the table: "delivery.order"
  """
  delivery_order(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch aggregated fields from the table: "delivery.order"
  """
  delivery_order_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """fetch data from the table: "delivery.order" using primary key columns"""
  delivery_order_by_pk(id: Int!): delivery_order

  """
  fetch data from the table: "delivery.order_public"
  """
  delivery_order_public(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch aggregated fields from the table: "delivery.order_public"
  """
  delivery_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): delivery_order_public_aggregate!

  """
  fetch data from the table: "direct_chat"
  """
  direct_chat(
    """distinct select on columns"""
    distinct_on: [direct_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direct_chat_order_by!]

    """filter the rows returned"""
    where: direct_chat_bool_exp
  ): [direct_chat!]!

  """
  fetch aggregated fields from the table: "direct_chat"
  """
  direct_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [direct_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direct_chat_order_by!]

    """filter the rows returned"""
    where: direct_chat_bool_exp
  ): direct_chat_aggregate!

  """fetch data from the table: "direct_chat" using primary key columns"""
  direct_chat_by_pk(chat_id: Int!): direct_chat

  """
  fetch data from the table: "language"
  """
  language(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): language_aggregate!

  """fetch data from the table: "language" using primary key columns"""
  language_by_pk(id: String!): language

  """
  fetch data from the table: "laundry.category"
  """
  laundry_category(
    """distinct select on columns"""
    distinct_on: [laundry_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_category_order_by!]

    """filter the rows returned"""
    where: laundry_category_bool_exp
  ): [laundry_category!]!

  """
  fetch aggregated fields from the table: "laundry.category"
  """
  laundry_category_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_category_order_by!]

    """filter the rows returned"""
    where: laundry_category_bool_exp
  ): laundry_category_aggregate!

  """
  fetch data from the table: "laundry.category" using primary key columns
  """
  laundry_category_by_pk(id: Int!): laundry_category

  """
  fetch data from the table: "laundry.operator"
  """
  laundry_operator(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): [laundry_operator!]!

  """
  fetch aggregated fields from the table: "laundry.operator"
  """
  laundry_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): laundry_operator_aggregate!

  """
  fetch data from the table: "laundry.operator" using primary key columns
  """
  laundry_operator_by_pk(id: Int!): laundry_operator

  """
  fetch data from the table: "laundry.order"
  """
  laundry_order(
    """distinct select on columns"""
    distinct_on: [laundry_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_order_by!]

    """filter the rows returned"""
    where: laundry_order_bool_exp
  ): [laundry_order!]!

  """
  fetch aggregated fields from the table: "laundry.order"
  """
  laundry_order_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_order_by!]

    """filter the rows returned"""
    where: laundry_order_bool_exp
  ): laundry_order_aggregate!

  """fetch data from the table: "laundry.order" using primary key columns"""
  laundry_order_by_pk(id: Int!): laundry_order

  """
  fetch data from the table: "laundry.order_category"
  """
  laundry_order_category(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): [laundry_order_category!]!

  """
  fetch aggregated fields from the table: "laundry.order_category"
  """
  laundry_order_category_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): laundry_order_category_aggregate!

  """
  fetch data from the table: "laundry.order_category" using primary key columns
  """
  laundry_order_category_by_pk(id: Int!): laundry_order_category

  """
  fetch data from the table: "laundry.store"
  """
  laundry_store(
    """distinct select on columns"""
    distinct_on: [laundry_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_store_order_by!]

    """filter the rows returned"""
    where: laundry_store_bool_exp
  ): [laundry_store!]!

  """
  fetch aggregated fields from the table: "laundry.store"
  """
  laundry_store_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_store_order_by!]

    """filter the rows returned"""
    where: laundry_store_bool_exp
  ): laundry_store_aggregate!

  """fetch data from the table: "laundry.store" using primary key columns"""
  laundry_store_by_pk(id: Int!): laundry_store

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table: "mez_admin_chat"
  """
  mez_admin_chat(
    """distinct select on columns"""
    distinct_on: [mez_admin_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_chat_order_by!]

    """filter the rows returned"""
    where: mez_admin_chat_bool_exp
  ): [mez_admin_chat!]!

  """
  fetch aggregated fields from the table: "mez_admin_chat"
  """
  mez_admin_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_chat_order_by!]

    """filter the rows returned"""
    where: mez_admin_chat_bool_exp
  ): mez_admin_chat_aggregate!

  """fetch data from the table: "mez_admin_chat" using primary key columns"""
  mez_admin_chat_by_pk(chat_id: Int!): mez_admin_chat

  """
  fetch data from the table: "mez_json"
  """
  mez_json(
    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): [mez_json!]!

  """
  fetch aggregated fields from the table: "mez_json"
  """
  mez_json_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """fetch data from the table: "mez_json" using primary key columns"""
  mez_json_by_pk(json_object: jsonb!): mez_json

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table: "restaurant.cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant.cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant.cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant.cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant.cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant.cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table: "restaurant.category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant.category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant.category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table: "restaurant.choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant.choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant.choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  execute function "restaurant.get_restaurants" which returns "restaurant.restaurant"
  """
  restaurant_get_restaurants(
    """
    input parameters for function "restaurant_get_restaurants"
    """
    args: restaurant_get_restaurants_args!

    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """
  execute function "restaurant.get_restaurants" and query aggregates on result of table type "restaurant.restaurant"
  """
  restaurant_get_restaurants_aggregate(
    """
    input parameters for function "restaurant_get_restaurants_aggregate"
    """
    args: restaurant_get_restaurants_args!

    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): restaurant_restaurant_aggregate!

  """
  fetch data from the table: "restaurant.item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant.item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant.item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant.item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant.item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant.item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  fetch data from the table: "restaurant.operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant.operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant.operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table: "restaurant.option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant.option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant.option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant.option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant.option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant.option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  fetch data from the table: "restaurant.order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant.order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant.order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant.order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant.order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant.order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table: "restaurant.order_public"
  """
  restaurant_order_public(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch aggregated fields from the table: "restaurant.order_public"
  """
  restaurant_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): restaurant_order_public_aggregate!

  """
  execute function "restaurant.orders_by_date" which returns "mez_json"
  """
  restaurant_orders_by_date(
    """
    input parameters for function "restaurant_orders_by_date"
    """
    args: restaurant_orders_by_date_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json

  """
  execute function "restaurant.orders_by_date" and query aggregates on result of table type "mez_json"
  """
  restaurant_orders_by_date_aggregate(
    """
    input parameters for function "restaurant_orders_by_date_aggregate"
    """
    args: restaurant_orders_by_date_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """
  execute function "restaurant.orders_by_month" which returns "mez_json"
  """
  restaurant_orders_by_month(
    """
    input parameters for function "restaurant_orders_by_month"
    """
    args: restaurant_orders_by_month_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json

  """
  execute function "restaurant.orders_by_month" and query aggregates on result of table type "mez_json"
  """
  restaurant_orders_by_month_aggregate(
    """
    input parameters for function "restaurant_orders_by_month_aggregate"
    """
    args: restaurant_orders_by_month_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """
  fetch data from the table: "restaurant.restaurant"
  """
  restaurant_restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant.restaurant"
  """
  restaurant_restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): restaurant_restaurant_aggregate!

  """
  fetch data from the table: "restaurant.restaurant" using primary key columns
  """
  restaurant_restaurant_by_pk(id: Int!): restaurant_restaurant

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table: "service_provider_customer_chat"
  """
  service_provider_customer_chat(
    """distinct select on columns"""
    distinct_on: [service_provider_customer_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_customer_chat_order_by!]

    """filter the rows returned"""
    where: service_provider_customer_chat_bool_exp
  ): [service_provider_customer_chat!]!

  """
  fetch aggregated fields from the table: "service_provider_customer_chat"
  """
  service_provider_customer_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_customer_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_customer_chat_order_by!]

    """filter the rows returned"""
    where: service_provider_customer_chat_bool_exp
  ): service_provider_customer_chat_aggregate!

  """
  fetch data from the table: "service_provider_customer_chat" using primary key columns
  """
  service_provider_customer_chat_by_pk(chat_id: Int!): service_provider_customer_chat

  """
  fetch data from the table: "service_provider.delivery_partner"
  """
  service_provider_delivery_partner(
    """distinct select on columns"""
    distinct_on: [service_provider_delivery_partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_delivery_partner_order_by!]

    """filter the rows returned"""
    where: service_provider_delivery_partner_bool_exp
  ): [service_provider_delivery_partner!]!

  """
  fetch aggregated fields from the table: "service_provider.delivery_partner"
  """
  service_provider_delivery_partner_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_delivery_partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_delivery_partner_order_by!]

    """filter the rows returned"""
    where: service_provider_delivery_partner_bool_exp
  ): service_provider_delivery_partner_aggregate!

  """
  fetch data from the table: "service_provider.delivery_partner" using primary key columns
  """
  service_provider_delivery_partner_by_pk(id: Int!): service_provider_delivery_partner

  """
  fetch data from the table: "service_provider.location"
  """
  service_provider_location(
    """distinct select on columns"""
    distinct_on: [service_provider_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_location_order_by!]

    """filter the rows returned"""
    where: service_provider_location_bool_exp
  ): [service_provider_location!]!

  """
  fetch aggregated fields from the table: "service_provider.location"
  """
  service_provider_location_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_location_order_by!]

    """filter the rows returned"""
    where: service_provider_location_bool_exp
  ): service_provider_location_aggregate!

  """
  fetch data from the table: "service_provider.location" using primary key columns
  """
  service_provider_location_by_pk(id: Int!): service_provider_location

  """
  fetch data from the table: "service_provider.post"
  """
  service_provider_post(
    """distinct select on columns"""
    distinct_on: [service_provider_post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_post_order_by!]

    """filter the rows returned"""
    where: service_provider_post_bool_exp
  ): [service_provider_post!]!

  """
  fetch aggregated fields from the table: "service_provider.post"
  """
  service_provider_post_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_post_order_by!]

    """filter the rows returned"""
    where: service_provider_post_bool_exp
  ): service_provider_post_aggregate!

  """
  fetch data from the table: "service_provider.post" using primary key columns
  """
  service_provider_post_by_pk(id: Int!): service_provider_post

  """
  fetch data from the table: "service_provider.service_link"
  """
  service_provider_service_link(
    """distinct select on columns"""
    distinct_on: [service_provider_service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_service_link_order_by!]

    """filter the rows returned"""
    where: service_provider_service_link_bool_exp
  ): [service_provider_service_link!]!

  """
  fetch aggregated fields from the table: "service_provider.service_link"
  """
  service_provider_service_link_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_service_link_order_by!]

    """filter the rows returned"""
    where: service_provider_service_link_bool_exp
  ): service_provider_service_link_aggregate!

  """
  fetch data from the table: "service_provider.service_link" using primary key columns
  """
  service_provider_service_link_by_pk(id: Int!): service_provider_service_link

  """
  fetch data from the table: "service_provider.subscriber"
  """
  service_provider_subscriber(
    """distinct select on columns"""
    distinct_on: [service_provider_subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_subscriber_order_by!]

    """filter the rows returned"""
    where: service_provider_subscriber_bool_exp
  ): [service_provider_subscriber!]!

  """
  fetch aggregated fields from the table: "service_provider.subscriber"
  """
  service_provider_subscriber_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_subscriber_order_by!]

    """filter the rows returned"""
    where: service_provider_subscriber_bool_exp
  ): service_provider_subscriber_aggregate!

  """
  fetch data from the table: "service_provider.subscriber" using primary key columns
  """
  service_provider_subscriber_by_pk(id: Int!): service_provider_subscriber

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user
}

"""
columns and relationships of "restaurant.cart"
"""
type restaurant_cart {
  """
  A computed field, executes function "cost"
  """
  cost: money

  """An object relationship"""
  customer: customer_customer!
  customer_id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """An object relationship"""
  restaurant: restaurant_restaurant
  restaurant_id: Int
}

"""
aggregated selection of "restaurant.cart"
"""
type restaurant_cart_aggregate {
  aggregate: restaurant_cart_aggregate_fields
  nodes: [restaurant_cart!]!
}

"""
aggregate fields of "restaurant.cart"
"""
type restaurant_cart_aggregate_fields {
  avg: restaurant_cart_avg_fields
  count(columns: [restaurant_cart_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_max_fields
  min: restaurant_cart_min_fields
  stddev: restaurant_cart_stddev_fields
  stddev_pop: restaurant_cart_stddev_pop_fields
  stddev_samp: restaurant_cart_stddev_samp_fields
  sum: restaurant_cart_sum_fields
  var_pop: restaurant_cart_var_pop_fields
  var_samp: restaurant_cart_var_samp_fields
  variance: restaurant_cart_variance_fields
}

"""aggregate avg on columns"""
type restaurant_cart_avg_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant.cart". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_bool_exp {
  _and: [restaurant_cart_bool_exp!]
  _not: restaurant_cart_bool_exp
  _or: [restaurant_cart_bool_exp!]
  cost: money_comparison_exp
  customer: customer_customer_bool_exp
  customer_id: Int_comparison_exp
  items: restaurant_cart_item_bool_exp
  items_aggregate: restaurant_cart_item_aggregate_bool_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.cart"
"""
enum restaurant_cart_constraint {
  """
  unique or primary key constraint on columns "customer_id"
  """
  restaurant_cart_pkey1
}

"""
input type for incrementing numeric columns in table "restaurant.cart"
"""
input restaurant_cart_inc_input {
  customer_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.cart"
"""
input restaurant_cart_insert_input {
  customer: customer_customer_obj_rel_insert_input
  customer_id: Int
  items: restaurant_cart_item_arr_rel_insert_input
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""
columns and relationships of "restaurant.cart_item"
"""
type restaurant_cart_item {
  cost_per_one: money!
  customer_id: Int!
  id: Int!
  note: String
  quantity: Int!

  """An object relationship"""
  restaurant_cart: restaurant_cart!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!

  """{<option-id>:[<choice-id>]"""
  selected_options(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "restaurant.cart_item"
"""
type restaurant_cart_item_aggregate {
  aggregate: restaurant_cart_item_aggregate_fields
  nodes: [restaurant_cart_item!]!
}

input restaurant_cart_item_aggregate_bool_exp {
  count: restaurant_cart_item_aggregate_bool_exp_count
}

input restaurant_cart_item_aggregate_bool_exp_count {
  arguments: [restaurant_cart_item_select_column!]
  distinct: Boolean
  filter: restaurant_cart_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.cart_item"
"""
type restaurant_cart_item_aggregate_fields {
  avg: restaurant_cart_item_avg_fields
  count(columns: [restaurant_cart_item_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_item_max_fields
  min: restaurant_cart_item_min_fields
  stddev: restaurant_cart_item_stddev_fields
  stddev_pop: restaurant_cart_item_stddev_pop_fields
  stddev_samp: restaurant_cart_item_stddev_samp_fields
  sum: restaurant_cart_item_sum_fields
  var_pop: restaurant_cart_item_var_pop_fields
  var_samp: restaurant_cart_item_var_samp_fields
  variance: restaurant_cart_item_variance_fields
}

"""
order by aggregate values of table "restaurant.cart_item"
"""
input restaurant_cart_item_aggregate_order_by {
  avg: restaurant_cart_item_avg_order_by
  count: order_by
  max: restaurant_cart_item_max_order_by
  min: restaurant_cart_item_min_order_by
  stddev: restaurant_cart_item_stddev_order_by
  stddev_pop: restaurant_cart_item_stddev_pop_order_by
  stddev_samp: restaurant_cart_item_stddev_samp_order_by
  sum: restaurant_cart_item_sum_order_by
  var_pop: restaurant_cart_item_var_pop_order_by
  var_samp: restaurant_cart_item_var_samp_order_by
  variance: restaurant_cart_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.cart_item"
"""
input restaurant_cart_item_arr_rel_insert_input {
  data: [restaurant_cart_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_cart_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_cart_item_avg_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by avg() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_avg_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.cart_item". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_item_bool_exp {
  _and: [restaurant_cart_item_bool_exp!]
  _not: restaurant_cart_item_bool_exp
  _or: [restaurant_cart_item_bool_exp!]
  cost_per_one: money_comparison_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  quantity: Int_comparison_exp
  restaurant_cart: restaurant_cart_bool_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  selected_options: json_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.cart_item"
"""
enum restaurant_cart_item_constraint {
  """
  unique or primary key constraint on columns "restaurant_item_id", "customer_id"
  """
  restaurant_cart_item_customer_id_restaurant_item_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_cart_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.cart_item"
"""
input restaurant_cart_item_inc_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
input type for inserting data into table "restaurant.cart_item"
"""
input restaurant_cart_item_insert_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_cart: restaurant_cart_obj_rel_insert_input
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate max on columns"""
type restaurant_cart_item_max_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by max() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_max_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate min on columns"""
type restaurant_cart_item_min_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by min() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_min_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
response of any mutation on the table "restaurant.cart_item"
"""
type restaurant_cart_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart_item!]!
}

"""
on_conflict condition type for table "restaurant.cart_item"
"""
input restaurant_cart_item_on_conflict {
  constraint: restaurant_cart_item_constraint!
  update_columns: [restaurant_cart_item_update_column!]! = []
  where: restaurant_cart_item_bool_exp
}

"""Ordering options when selecting data from "restaurant.cart_item"."""
input restaurant_cart_item_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_cart: restaurant_cart_order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  selected_options: order_by
}

"""primary key columns input for table: restaurant.cart_item"""
input restaurant_cart_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.cart_item"
"""
enum restaurant_cart_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

"""
input type for updating data in table "restaurant.cart_item"
"""
input restaurant_cart_item_set_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate stddev on columns"""
type restaurant_cart_item_stddev_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_stddev_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_item_stddev_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_stddev_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_item_stddev_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_stddev_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Streaming cursor of the table "restaurant_cart_item"
"""
input restaurant_cart_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_item_stream_cursor_value_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate sum on columns"""
type restaurant_cart_item_sum_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
order by sum() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_sum_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
update columns of table "restaurant.cart_item"
"""
enum restaurant_cart_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

input restaurant_cart_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_item_set_input

  """filter the rows which have to be updated"""
  where: restaurant_cart_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_item_var_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_pop() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_var_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_cart_item_var_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_samp() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_var_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate variance on columns"""
type restaurant_cart_item_variance_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by variance() on columns of table "restaurant.cart_item"
"""
input restaurant_cart_item_variance_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate max on columns"""
type restaurant_cart_max_fields {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate min on columns"""
type restaurant_cart_min_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
response of any mutation on the table "restaurant.cart"
"""
type restaurant_cart_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart!]!
}

"""
input type for inserting object relation for remote table "restaurant.cart"
"""
input restaurant_cart_obj_rel_insert_input {
  data: restaurant_cart_insert_input!

  """upsert condition"""
  on_conflict: restaurant_cart_on_conflict
}

"""
on_conflict condition type for table "restaurant.cart"
"""
input restaurant_cart_on_conflict {
  constraint: restaurant_cart_constraint!
  update_columns: [restaurant_cart_update_column!]! = []
  where: restaurant_cart_bool_exp
}

"""Ordering options when selecting data from "restaurant.cart"."""
input restaurant_cart_order_by {
  cost: order_by
  customer: customer_customer_order_by
  customer_id: order_by
  items_aggregate: restaurant_cart_item_aggregate_order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant.cart"""
input restaurant_cart_pk_columns_input {
  customer_id: Int!
}

"""
select columns of table "restaurant.cart"
"""
enum restaurant_cart_select_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant.cart"
"""
input restaurant_cart_set_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_cart_stddev_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_stddev_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_stddev_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Streaming cursor of the table "restaurant_cart"
"""
input restaurant_cart_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_stream_cursor_value_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_cart_sum_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
update columns of table "restaurant.cart"
"""
enum restaurant_cart_update_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

input restaurant_cart_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_set_input

  """filter the rows which have to be updated"""
  where: restaurant_cart_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_var_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_cart_var_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate variance on columns"""
type restaurant_cart_variance_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
columns and relationships of "restaurant.category"
"""
type restaurant_category {
  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """An object relationship"""
  name: translation!
  name_id: Int!
  position: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant!
  restaurant_id: Int!
  schedule_id: Int
}

"""
aggregated selection of "restaurant.category"
"""
type restaurant_category_aggregate {
  aggregate: restaurant_category_aggregate_fields
  nodes: [restaurant_category!]!
}

input restaurant_category_aggregate_bool_exp {
  count: restaurant_category_aggregate_bool_exp_count
}

input restaurant_category_aggregate_bool_exp_count {
  arguments: [restaurant_category_select_column!]
  distinct: Boolean
  filter: restaurant_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.category"
"""
type restaurant_category_aggregate_fields {
  avg: restaurant_category_avg_fields
  count(columns: [restaurant_category_select_column!], distinct: Boolean): Int!
  max: restaurant_category_max_fields
  min: restaurant_category_min_fields
  stddev: restaurant_category_stddev_fields
  stddev_pop: restaurant_category_stddev_pop_fields
  stddev_samp: restaurant_category_stddev_samp_fields
  sum: restaurant_category_sum_fields
  var_pop: restaurant_category_var_pop_fields
  var_samp: restaurant_category_var_samp_fields
  variance: restaurant_category_variance_fields
}

"""
order by aggregate values of table "restaurant.category"
"""
input restaurant_category_aggregate_order_by {
  avg: restaurant_category_avg_order_by
  count: order_by
  max: restaurant_category_max_order_by
  min: restaurant_category_min_order_by
  stddev: restaurant_category_stddev_order_by
  stddev_pop: restaurant_category_stddev_pop_order_by
  stddev_samp: restaurant_category_stddev_samp_order_by
  sum: restaurant_category_sum_order_by
  var_pop: restaurant_category_var_pop_order_by
  var_samp: restaurant_category_var_samp_order_by
  variance: restaurant_category_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.category"
"""
input restaurant_category_arr_rel_insert_input {
  data: [restaurant_category_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""aggregate avg on columns"""
type restaurant_category_avg_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by avg() on columns of table "restaurant.category"
"""
input restaurant_category_avg_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.category". All fields are combined with a logical 'AND'.
"""
input restaurant_category_bool_exp {
  _and: [restaurant_category_bool_exp!]
  _not: restaurant_category_bool_exp
  _or: [restaurant_category_bool_exp!]
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_bool_exp
  items_aggregate: restaurant_item_aggregate_bool_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  position: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  schedule_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.category"
"""
enum restaurant_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_category_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.category"
"""
input restaurant_category_inc_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
input type for inserting data into table "restaurant.category"
"""
input restaurant_category_insert_input {
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  items: restaurant_item_arr_rel_insert_input
  name: translation_obj_rel_insert_input
  name_id: Int
  position: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate max on columns"""
type restaurant_category_max_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by max() on columns of table "restaurant.category"
"""
input restaurant_category_max_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate min on columns"""
type restaurant_category_min_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by min() on columns of table "restaurant.category"
"""
input restaurant_category_min_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
response of any mutation on the table "restaurant.category"
"""
type restaurant_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_category!]!
}

"""
input type for inserting object relation for remote table "restaurant.category"
"""
input restaurant_category_obj_rel_insert_input {
  data: restaurant_category_insert_input!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""
on_conflict condition type for table "restaurant.category"
"""
input restaurant_category_on_conflict {
  constraint: restaurant_category_constraint!
  update_columns: [restaurant_category_update_column!]! = []
  where: restaurant_category_bool_exp
}

"""Ordering options when selecting data from "restaurant.category"."""
input restaurant_category_order_by {
  description: translation_order_by
  description_id: order_by
  id: order_by
  items_aggregate: restaurant_item_aggregate_order_by
  name: translation_order_by
  name_id: order_by
  position: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""primary key columns input for table: restaurant.category"""
input restaurant_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.category"
"""
enum restaurant_category_select_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

"""
input type for updating data in table "restaurant.category"
"""
input restaurant_category_set_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate stddev on columns"""
type restaurant_category_stddev_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev() on columns of table "restaurant.category"
"""
input restaurant_category_stddev_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_category_stddev_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.category"
"""
input restaurant_category_stddev_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_category_stddev_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.category"
"""
input restaurant_category_stddev_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Streaming cursor of the table "restaurant_category"
"""
input restaurant_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_category_stream_cursor_value_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate sum on columns"""
type restaurant_category_sum_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by sum() on columns of table "restaurant.category"
"""
input restaurant_category_sum_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
update columns of table "restaurant.category"
"""
enum restaurant_category_update_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

input restaurant_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_category_set_input

  """filter the rows which have to be updated"""
  where: restaurant_category_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_category_var_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_pop() on columns of table "restaurant.category"
"""
input restaurant_category_var_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_category_var_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_samp() on columns of table "restaurant.category"
"""
input restaurant_category_var_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate variance on columns"""
type restaurant_category_variance_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by variance() on columns of table "restaurant.category"
"""
input restaurant_category_variance_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
columns and relationships of "restaurant.choice"
"""
type restaurant_choice {
  available: Boolean!
  cost: money!
  id: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """An object relationship"""
  restaurant: restaurant_restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant.choice"
"""
type restaurant_choice_aggregate {
  aggregate: restaurant_choice_aggregate_fields
  nodes: [restaurant_choice!]!
}

input restaurant_choice_aggregate_bool_exp {
  bool_and: restaurant_choice_aggregate_bool_exp_bool_and
  bool_or: restaurant_choice_aggregate_bool_exp_bool_or
  count: restaurant_choice_aggregate_bool_exp_count
}

input restaurant_choice_aggregate_bool_exp_bool_and {
  arguments: restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_choice_aggregate_bool_exp_bool_or {
  arguments: restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_choice_aggregate_bool_exp_count {
  arguments: [restaurant_choice_select_column!]
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.choice"
"""
type restaurant_choice_aggregate_fields {
  avg: restaurant_choice_avg_fields
  count(columns: [restaurant_choice_select_column!], distinct: Boolean): Int!
  max: restaurant_choice_max_fields
  min: restaurant_choice_min_fields
  stddev: restaurant_choice_stddev_fields
  stddev_pop: restaurant_choice_stddev_pop_fields
  stddev_samp: restaurant_choice_stddev_samp_fields
  sum: restaurant_choice_sum_fields
  var_pop: restaurant_choice_var_pop_fields
  var_samp: restaurant_choice_var_samp_fields
  variance: restaurant_choice_variance_fields
}

"""
order by aggregate values of table "restaurant.choice"
"""
input restaurant_choice_aggregate_order_by {
  avg: restaurant_choice_avg_order_by
  count: order_by
  max: restaurant_choice_max_order_by
  min: restaurant_choice_min_order_by
  stddev: restaurant_choice_stddev_order_by
  stddev_pop: restaurant_choice_stddev_pop_order_by
  stddev_samp: restaurant_choice_stddev_samp_order_by
  sum: restaurant_choice_sum_order_by
  var_pop: restaurant_choice_var_pop_order_by
  var_samp: restaurant_choice_var_samp_order_by
  variance: restaurant_choice_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.choice"
"""
input restaurant_choice_arr_rel_insert_input {
  data: [restaurant_choice_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_choice_on_conflict
}

"""aggregate avg on columns"""
type restaurant_choice_avg_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant.choice"
"""
input restaurant_choice_avg_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.choice". All fields are combined with a logical 'AND'.
"""
input restaurant_choice_bool_exp {
  _and: [restaurant_choice_bool_exp!]
  _not: restaurant_choice_bool_exp
  _or: [restaurant_choice_bool_exp!]
  available: Boolean_comparison_exp
  cost: money_comparison_exp
  id: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_option_choice_map_bool_exp
  options_aggregate: restaurant_option_choice_map_aggregate_bool_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.choice"
"""
enum restaurant_choice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_choice_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.choice"
"""
input restaurant_choice_inc_input {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.choice"
"""
input restaurant_choice_insert_input {
  available: Boolean
  cost: money
  id: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_option_choice_map_arr_rel_insert_input
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_choice_max_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant.choice"
"""
input restaurant_choice_max_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_choice_min_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant.choice"
"""
input restaurant_choice_min_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant.choice"
"""
type restaurant_choice_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_choice!]!
}

"""
on_conflict condition type for table "restaurant.choice"
"""
input restaurant_choice_on_conflict {
  constraint: restaurant_choice_constraint!
  update_columns: [restaurant_choice_update_column!]! = []
  where: restaurant_choice_bool_exp
}

"""Ordering options when selecting data from "restaurant.choice"."""
input restaurant_choice_order_by {
  available: order_by
  cost: order_by
  id: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_option_choice_map_aggregate_order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant.choice"""
input restaurant_choice_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.choice"
"""
enum restaurant_choice_select_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  restaurant_id
}

"""
select "restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant.choice"
"""
enum restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  available
}

"""
select "restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant.choice"
"""
enum restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  available
}

"""
input type for updating data in table "restaurant.choice"
"""
input restaurant_choice_set_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_choice_stddev_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant.choice"
"""
input restaurant_choice_stddev_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_choice_stddev_pop_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.choice"
"""
input restaurant_choice_stddev_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_choice_stddev_samp_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.choice"
"""
input restaurant_choice_stddev_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_choice"
"""
input restaurant_choice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_choice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_choice_stream_cursor_value_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_choice_sum_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant.choice"
"""
input restaurant_choice_sum_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant.choice"
"""
enum restaurant_choice_update_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  restaurant_id
}

input restaurant_choice_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_choice_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_choice_set_input

  """filter the rows which have to be updated"""
  where: restaurant_choice_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_choice_var_pop_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant.choice"
"""
input restaurant_choice_var_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_choice_var_samp_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant.choice"
"""
input restaurant_choice_var_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_choice_variance_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant.choice"
"""
input restaurant_choice_variance_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

input restaurant_get_restaurants_args {
  location: geography
}

"""
columns and relationships of "restaurant.item"
"""
type restaurant_item {
  archived: Boolean!
  available: Boolean!

  """An object relationship"""
  category: restaurant_category
  category_id: Int
  cost: money!

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!
  image: String

  """daily, special"""
  item_type: String!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  position: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant
  restaurant_id: Int!
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
aggregated selection of "restaurant.item"
"""
type restaurant_item_aggregate {
  aggregate: restaurant_item_aggregate_fields
  nodes: [restaurant_item!]!
}

input restaurant_item_aggregate_bool_exp {
  bool_and: restaurant_item_aggregate_bool_exp_bool_and
  bool_or: restaurant_item_aggregate_bool_exp_bool_or
  count: restaurant_item_aggregate_bool_exp_count
}

input restaurant_item_aggregate_bool_exp_bool_and {
  arguments: restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_item_aggregate_bool_exp_bool_or {
  arguments: restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_item_aggregate_bool_exp_count {
  arguments: [restaurant_item_select_column!]
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.item"
"""
type restaurant_item_aggregate_fields {
  avg: restaurant_item_avg_fields
  count(columns: [restaurant_item_select_column!], distinct: Boolean): Int!
  max: restaurant_item_max_fields
  min: restaurant_item_min_fields
  stddev: restaurant_item_stddev_fields
  stddev_pop: restaurant_item_stddev_pop_fields
  stddev_samp: restaurant_item_stddev_samp_fields
  sum: restaurant_item_sum_fields
  var_pop: restaurant_item_var_pop_fields
  var_samp: restaurant_item_var_samp_fields
  variance: restaurant_item_variance_fields
}

"""
order by aggregate values of table "restaurant.item"
"""
input restaurant_item_aggregate_order_by {
  avg: restaurant_item_avg_order_by
  count: order_by
  max: restaurant_item_max_order_by
  min: restaurant_item_min_order_by
  stddev: restaurant_item_stddev_order_by
  stddev_pop: restaurant_item_stddev_pop_order_by
  stddev_samp: restaurant_item_stddev_samp_order_by
  sum: restaurant_item_sum_order_by
  var_pop: restaurant_item_var_pop_order_by
  var_samp: restaurant_item_var_samp_order_by
  variance: restaurant_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.item"
"""
input restaurant_item_arr_rel_insert_input {
  data: [restaurant_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_avg_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant.item"
"""
input restaurant_item_avg_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.item". All fields are combined with a logical 'AND'.
"""
input restaurant_item_bool_exp {
  _and: [restaurant_item_bool_exp!]
  _not: restaurant_item_bool_exp
  _or: [restaurant_item_bool_exp!]
  archived: Boolean_comparison_exp
  available: Boolean_comparison_exp
  category: restaurant_category_bool_exp
  category_id: Int_comparison_exp
  cost: money_comparison_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  item_type: String_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_item_option_map_bool_exp
  options_aggregate: restaurant_item_option_map_aggregate_bool_exp
  position: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  special_period_end: timestamptz_comparison_exp
  special_period_start: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.item"
"""
enum restaurant_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.item"
"""
input restaurant_item_inc_input {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.item"
"""
input restaurant_item_insert_input {
  archived: Boolean
  available: Boolean
  category: restaurant_category_obj_rel_insert_input
  category_id: Int
  cost: money
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_item_option_map_arr_rel_insert_input
  position: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate max on columns"""
type restaurant_item_max_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by max() on columns of table "restaurant.item"
"""
input restaurant_item_max_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  image: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""aggregate min on columns"""
type restaurant_item_min_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by min() on columns of table "restaurant.item"
"""
input restaurant_item_min_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  image: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""
response of any mutation on the table "restaurant.item"
"""
type restaurant_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item!]!
}

"""
input type for inserting object relation for remote table "restaurant.item"
"""
input restaurant_item_obj_rel_insert_input {
  data: restaurant_item_insert_input!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""
on_conflict condition type for table "restaurant.item"
"""
input restaurant_item_on_conflict {
  constraint: restaurant_item_constraint!
  update_columns: [restaurant_item_update_column!]! = []
  where: restaurant_item_bool_exp
}

"""
columns and relationships of "restaurant.item_option_map"
"""
type restaurant_item_option_map {
  id: Int!
  item_id: Int!

  """An array relationship"""
  item_options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """An aggregate relationship"""
  item_options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!
  option_id: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant.item_option_map"
"""
type restaurant_item_option_map_aggregate {
  aggregate: restaurant_item_option_map_aggregate_fields
  nodes: [restaurant_item_option_map!]!
}

input restaurant_item_option_map_aggregate_bool_exp {
  count: restaurant_item_option_map_aggregate_bool_exp_count
}

input restaurant_item_option_map_aggregate_bool_exp_count {
  arguments: [restaurant_item_option_map_select_column!]
  distinct: Boolean
  filter: restaurant_item_option_map_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.item_option_map"
"""
type restaurant_item_option_map_aggregate_fields {
  avg: restaurant_item_option_map_avg_fields
  count(columns: [restaurant_item_option_map_select_column!], distinct: Boolean): Int!
  max: restaurant_item_option_map_max_fields
  min: restaurant_item_option_map_min_fields
  stddev: restaurant_item_option_map_stddev_fields
  stddev_pop: restaurant_item_option_map_stddev_pop_fields
  stddev_samp: restaurant_item_option_map_stddev_samp_fields
  sum: restaurant_item_option_map_sum_fields
  var_pop: restaurant_item_option_map_var_pop_fields
  var_samp: restaurant_item_option_map_var_samp_fields
  variance: restaurant_item_option_map_variance_fields
}

"""
order by aggregate values of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_aggregate_order_by {
  avg: restaurant_item_option_map_avg_order_by
  count: order_by
  max: restaurant_item_option_map_max_order_by
  min: restaurant_item_option_map_min_order_by
  stddev: restaurant_item_option_map_stddev_order_by
  stddev_pop: restaurant_item_option_map_stddev_pop_order_by
  stddev_samp: restaurant_item_option_map_stddev_samp_order_by
  sum: restaurant_item_option_map_sum_order_by
  var_pop: restaurant_item_option_map_var_pop_order_by
  var_samp: restaurant_item_option_map_var_samp_order_by
  variance: restaurant_item_option_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.item_option_map"
"""
input restaurant_item_option_map_arr_rel_insert_input {
  data: [restaurant_item_option_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_option_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_option_map_avg_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_avg_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.item_option_map". All fields are combined with a logical 'AND'.
"""
input restaurant_item_option_map_bool_exp {
  _and: [restaurant_item_option_map_bool_exp!]
  _not: restaurant_item_option_map_bool_exp
  _or: [restaurant_item_option_map_bool_exp!]
  id: Int_comparison_exp
  item_id: Int_comparison_exp
  item_options: restaurant_option_bool_exp
  item_options_aggregate: restaurant_option_aggregate_bool_exp
  option_id: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.item_option_map"
"""
enum restaurant_item_option_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "item_id"
  """
  restaurant_item_option_map_item_id_option_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_item_option_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.item_option_map"
"""
input restaurant_item_option_map_inc_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.item_option_map"
"""
input restaurant_item_option_map_insert_input {
  id: Int
  item_id: Int
  item_options: restaurant_option_arr_rel_insert_input
  option_id: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_item_option_map_max_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_max_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_item_option_map_min_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_min_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant.item_option_map"
"""
type restaurant_item_option_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item_option_map!]!
}

"""
on_conflict condition type for table "restaurant.item_option_map"
"""
input restaurant_item_option_map_on_conflict {
  constraint: restaurant_item_option_map_constraint!
  update_columns: [restaurant_item_option_map_update_column!]! = []
  where: restaurant_item_option_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant.item_option_map".
"""
input restaurant_item_option_map_order_by {
  id: order_by
  item_id: order_by
  item_options_aggregate: restaurant_option_aggregate_order_by
  option_id: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant.item_option_map"""
input restaurant_item_option_map_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.item_option_map"
"""
enum restaurant_item_option_map_select_column {
  """column name"""
  id

  """column name"""
  item_id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant.item_option_map"
"""
input restaurant_item_option_map_set_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_item_option_map_stddev_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_stddev_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_option_map_stddev_pop_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_option_map_stddev_samp_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_option_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_option_map_stream_cursor_value_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_item_option_map_sum_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_sum_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant.item_option_map"
"""
enum restaurant_item_option_map_update_column {
  """column name"""
  id

  """column name"""
  item_id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

input restaurant_item_option_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_option_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_option_map_set_input

  """filter the rows which have to be updated"""
  where: restaurant_item_option_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_option_map_var_pop_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_var_pop_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_option_map_var_samp_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_var_samp_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_option_map_variance_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant.item_option_map"
"""
input restaurant_item_option_map_variance_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""Ordering options when selecting data from "restaurant.item"."""
input restaurant_item_order_by {
  archived: order_by
  available: order_by
  category: restaurant_category_order_by
  category_id: order_by
  cost: order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  image: order_by
  item_type: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_item_option_map_aggregate_order_by
  position: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""primary key columns input for table: restaurant.item"""
input restaurant_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.item"
"""
enum restaurant_item_select_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

"""
select "restaurant_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant.item"
"""
enum restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived

  """column name"""
  available
}

"""
select "restaurant_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant.item"
"""
enum restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived

  """column name"""
  available
}

"""
input type for updating data in table "restaurant.item"
"""
input restaurant_item_set_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate stddev on columns"""
type restaurant_item_stddev_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant.item"
"""
input restaurant_item_stddev_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_stddev_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.item"
"""
input restaurant_item_stddev_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_stddev_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.item"
"""
input restaurant_item_stddev_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_item"
"""
input restaurant_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_stream_cursor_value_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate sum on columns"""
type restaurant_item_sum_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant.item"
"""
input restaurant_item_sum_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant.item"
"""
enum restaurant_item_update_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

input restaurant_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_set_input

  """filter the rows which have to be updated"""
  where: restaurant_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_var_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant.item"
"""
input restaurant_item_var_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_var_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant.item"
"""
input restaurant_item_var_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_variance_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant.item"
"""
input restaurant_item_variance_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
columns and relationships of "restaurant.operator"
"""
type restaurant_operator {
  app_type_id: String!
  app_version: String
  current_gps: geography
  delivery_driver_type: String!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  online: Boolean!
  owner: Boolean!

  """An object relationship"""
  restaurant: restaurant_restaurant
  restaurant_id: Int!

  """awaiting_approval,authorized,banned"""
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "restaurant.operator"
"""
type restaurant_operator_aggregate {
  aggregate: restaurant_operator_aggregate_fields
  nodes: [restaurant_operator!]!
}

input restaurant_operator_aggregate_bool_exp {
  bool_and: restaurant_operator_aggregate_bool_exp_bool_and
  bool_or: restaurant_operator_aggregate_bool_exp_bool_or
  count: restaurant_operator_aggregate_bool_exp_count
}

input restaurant_operator_aggregate_bool_exp_bool_and {
  arguments: restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_operator_aggregate_bool_exp_bool_or {
  arguments: restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_operator_aggregate_bool_exp_count {
  arguments: [restaurant_operator_select_column!]
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.operator"
"""
type restaurant_operator_aggregate_fields {
  avg: restaurant_operator_avg_fields
  count(columns: [restaurant_operator_select_column!], distinct: Boolean): Int!
  max: restaurant_operator_max_fields
  min: restaurant_operator_min_fields
  stddev: restaurant_operator_stddev_fields
  stddev_pop: restaurant_operator_stddev_pop_fields
  stddev_samp: restaurant_operator_stddev_samp_fields
  sum: restaurant_operator_sum_fields
  var_pop: restaurant_operator_var_pop_fields
  var_samp: restaurant_operator_var_samp_fields
  variance: restaurant_operator_variance_fields
}

"""
order by aggregate values of table "restaurant.operator"
"""
input restaurant_operator_aggregate_order_by {
  avg: restaurant_operator_avg_order_by
  count: order_by
  max: restaurant_operator_max_order_by
  min: restaurant_operator_min_order_by
  stddev: restaurant_operator_stddev_order_by
  stddev_pop: restaurant_operator_stddev_pop_order_by
  stddev_samp: restaurant_operator_stddev_samp_order_by
  sum: restaurant_operator_sum_order_by
  var_pop: restaurant_operator_var_pop_order_by
  var_samp: restaurant_operator_var_samp_order_by
  variance: restaurant_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.operator"
"""
input restaurant_operator_arr_rel_insert_input {
  data: [restaurant_operator_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_operator_on_conflict
}

"""aggregate avg on columns"""
type restaurant_operator_avg_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "restaurant.operator"
"""
input restaurant_operator_avg_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.operator". All fields are combined with a logical 'AND'.
"""
input restaurant_operator_bool_exp {
  _and: [restaurant_operator_bool_exp!]
  _not: restaurant_operator_bool_exp
  _or: [restaurant_operator_bool_exp!]
  app_type_id: String_comparison_exp
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  online: Boolean_comparison_exp
  owner: Boolean_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.operator"
"""
enum restaurant_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_operator_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  restaurant_operator_user_id_key
}

"""
input type for incrementing numeric columns in table "restaurant.operator"
"""
input restaurant_operator_inc_input {
  id: Int
  restaurant_id: Int
  user_id: Int
}

"""
input type for inserting data into table "restaurant.operator"
"""
input restaurant_operator_insert_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  online: Boolean
  owner: Boolean
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type restaurant_operator_max_fields {
  app_type_id: String
  app_version: String
  delivery_driver_type: String
  id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by max() on columns of table "restaurant.operator"
"""
input restaurant_operator_max_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type restaurant_operator_min_fields {
  app_type_id: String
  app_version: String
  delivery_driver_type: String
  id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by min() on columns of table "restaurant.operator"
"""
input restaurant_operator_min_order_by {
  app_type_id: order_by
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "restaurant.operator"
"""
type restaurant_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_operator!]!
}

"""
input type for inserting object relation for remote table "restaurant.operator"
"""
input restaurant_operator_obj_rel_insert_input {
  data: restaurant_operator_insert_input!

  """upsert condition"""
  on_conflict: restaurant_operator_on_conflict
}

"""
on_conflict condition type for table "restaurant.operator"
"""
input restaurant_operator_on_conflict {
  constraint: restaurant_operator_constraint!
  update_columns: [restaurant_operator_update_column!]! = []
  where: restaurant_operator_bool_exp
}

"""Ordering options when selecting data from "restaurant.operator"."""
input restaurant_operator_order_by {
  app_type_id: order_by
  app_version: order_by
  current_gps: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_info: notification_info_order_by
  online: order_by
  owner: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: restaurant.operator"""
input restaurant_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.operator"
"""
enum restaurant_operator_select_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant.operator"
"""
enum restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  online

  """column name"""
  owner
}

"""
select "restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant.operator"
"""
enum restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  online

  """column name"""
  owner
}

"""
input type for updating data in table "restaurant.operator"
"""
input restaurant_operator_set_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  online: Boolean
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type restaurant_operator_stddev_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "restaurant.operator"
"""
input restaurant_operator_stddev_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_operator_stddev_pop_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.operator"
"""
input restaurant_operator_stddev_pop_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_operator_stddev_samp_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.operator"
"""
input restaurant_operator_stddev_samp_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "restaurant_operator"
"""
input restaurant_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_operator_stream_cursor_value_input {
  app_type_id: String
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  online: Boolean
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type restaurant_operator_sum_fields {
  id: Int
  restaurant_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "restaurant.operator"
"""
input restaurant_operator_sum_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
update columns of table "restaurant.operator"
"""
enum restaurant_operator_update_column {
  """column name"""
  app_type_id

  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  online

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

input restaurant_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_operator_set_input

  """filter the rows which have to be updated"""
  where: restaurant_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_operator_var_pop_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "restaurant.operator"
"""
input restaurant_operator_var_pop_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_operator_var_samp_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "restaurant.operator"
"""
input restaurant_operator_var_samp_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type restaurant_operator_variance_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "restaurant.operator"
"""
input restaurant_operator_variance_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
columns and relationships of "restaurant.option"
"""
type restaurant_option {
  """An array relationship"""
  choices(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!
  cost_per_extra: money!
  free_choice: Int!
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  maximum_choice: Int!
  minimum_choice: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!
  option_type: String!
  position: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant.option"
"""
type restaurant_option_aggregate {
  aggregate: restaurant_option_aggregate_fields
  nodes: [restaurant_option!]!
}

input restaurant_option_aggregate_bool_exp {
  count: restaurant_option_aggregate_bool_exp_count
}

input restaurant_option_aggregate_bool_exp_count {
  arguments: [restaurant_option_select_column!]
  distinct: Boolean
  filter: restaurant_option_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.option"
"""
type restaurant_option_aggregate_fields {
  avg: restaurant_option_avg_fields
  count(columns: [restaurant_option_select_column!], distinct: Boolean): Int!
  max: restaurant_option_max_fields
  min: restaurant_option_min_fields
  stddev: restaurant_option_stddev_fields
  stddev_pop: restaurant_option_stddev_pop_fields
  stddev_samp: restaurant_option_stddev_samp_fields
  sum: restaurant_option_sum_fields
  var_pop: restaurant_option_var_pop_fields
  var_samp: restaurant_option_var_samp_fields
  variance: restaurant_option_variance_fields
}

"""
order by aggregate values of table "restaurant.option"
"""
input restaurant_option_aggregate_order_by {
  avg: restaurant_option_avg_order_by
  count: order_by
  max: restaurant_option_max_order_by
  min: restaurant_option_min_order_by
  stddev: restaurant_option_stddev_order_by
  stddev_pop: restaurant_option_stddev_pop_order_by
  stddev_samp: restaurant_option_stddev_samp_order_by
  sum: restaurant_option_sum_order_by
  var_pop: restaurant_option_var_pop_order_by
  var_samp: restaurant_option_var_samp_order_by
  variance: restaurant_option_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.option"
"""
input restaurant_option_arr_rel_insert_input {
  data: [restaurant_option_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_avg_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant.option"
"""
input restaurant_option_avg_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.option". All fields are combined with a logical 'AND'.
"""
input restaurant_option_bool_exp {
  _and: [restaurant_option_bool_exp!]
  _not: restaurant_option_bool_exp
  _or: [restaurant_option_bool_exp!]
  choices: restaurant_option_choice_map_bool_exp
  choices_aggregate: restaurant_option_choice_map_aggregate_bool_exp
  cost_per_extra: money_comparison_exp
  free_choice: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_option_map_bool_exp
  items_aggregate: restaurant_item_option_map_aggregate_bool_exp
  maximum_choice: Int_comparison_exp
  minimum_choice: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  option_type: String_comparison_exp
  position: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
columns and relationships of "restaurant.option_choice_map"
"""
type restaurant_option_choice_map {
  choice_id: Int!
  id: Int!

  """An array relationship"""
  option_choices(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """An aggregate relationship"""
  option_choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!
  option_id: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant.option_choice_map"
"""
type restaurant_option_choice_map_aggregate {
  aggregate: restaurant_option_choice_map_aggregate_fields
  nodes: [restaurant_option_choice_map!]!
}

input restaurant_option_choice_map_aggregate_bool_exp {
  count: restaurant_option_choice_map_aggregate_bool_exp_count
}

input restaurant_option_choice_map_aggregate_bool_exp_count {
  arguments: [restaurant_option_choice_map_select_column!]
  distinct: Boolean
  filter: restaurant_option_choice_map_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.option_choice_map"
"""
type restaurant_option_choice_map_aggregate_fields {
  avg: restaurant_option_choice_map_avg_fields
  count(columns: [restaurant_option_choice_map_select_column!], distinct: Boolean): Int!
  max: restaurant_option_choice_map_max_fields
  min: restaurant_option_choice_map_min_fields
  stddev: restaurant_option_choice_map_stddev_fields
  stddev_pop: restaurant_option_choice_map_stddev_pop_fields
  stddev_samp: restaurant_option_choice_map_stddev_samp_fields
  sum: restaurant_option_choice_map_sum_fields
  var_pop: restaurant_option_choice_map_var_pop_fields
  var_samp: restaurant_option_choice_map_var_samp_fields
  variance: restaurant_option_choice_map_variance_fields
}

"""
order by aggregate values of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_aggregate_order_by {
  avg: restaurant_option_choice_map_avg_order_by
  count: order_by
  max: restaurant_option_choice_map_max_order_by
  min: restaurant_option_choice_map_min_order_by
  stddev: restaurant_option_choice_map_stddev_order_by
  stddev_pop: restaurant_option_choice_map_stddev_pop_order_by
  stddev_samp: restaurant_option_choice_map_stddev_samp_order_by
  sum: restaurant_option_choice_map_sum_order_by
  var_pop: restaurant_option_choice_map_var_pop_order_by
  var_samp: restaurant_option_choice_map_var_samp_order_by
  variance: restaurant_option_choice_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_arr_rel_insert_input {
  data: [restaurant_option_choice_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_choice_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_choice_map_avg_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_avg_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.option_choice_map".
All fields are combined with a logical 'AND'.
"""
input restaurant_option_choice_map_bool_exp {
  _and: [restaurant_option_choice_map_bool_exp!]
  _not: restaurant_option_choice_map_bool_exp
  _or: [restaurant_option_choice_map_bool_exp!]
  choice_id: Int_comparison_exp
  id: Int_comparison_exp
  option_choices: restaurant_choice_bool_exp
  option_choices_aggregate: restaurant_choice_aggregate_bool_exp
  option_id: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.option_choice_map"
"""
enum restaurant_option_choice_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "choice_id"
  """
  restaurant_option_choice_map_option_id_choice_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_option_choice_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_inc_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_insert_input {
  choice_id: Int
  id: Int
  option_choices: restaurant_choice_arr_rel_insert_input
  option_id: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_option_choice_map_max_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_max_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_option_choice_map_min_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_min_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant.option_choice_map"
"""
type restaurant_option_choice_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option_choice_map!]!
}

"""
on_conflict condition type for table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_on_conflict {
  constraint: restaurant_option_choice_map_constraint!
  update_columns: [restaurant_option_choice_map_update_column!]! = []
  where: restaurant_option_choice_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant.option_choice_map".
"""
input restaurant_option_choice_map_order_by {
  choice_id: order_by
  id: order_by
  option_choices_aggregate: restaurant_choice_aggregate_order_by
  option_id: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant.option_choice_map"""
input restaurant_option_choice_map_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.option_choice_map"
"""
enum restaurant_option_choice_map_select_column {
  """column name"""
  choice_id

  """column name"""
  id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_set_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_option_choice_map_stddev_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_stddev_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_choice_map_stddev_pop_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_stddev_pop_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_choice_map_stddev_samp_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_stddev_samp_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_choice_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_choice_map_stream_cursor_value_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_option_choice_map_sum_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_sum_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant.option_choice_map"
"""
enum restaurant_option_choice_map_update_column {
  """column name"""
  choice_id

  """column name"""
  id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

input restaurant_option_choice_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_choice_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_choice_map_set_input

  """filter the rows which have to be updated"""
  where: restaurant_option_choice_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_choice_map_var_pop_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_var_pop_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_choice_map_var_samp_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_var_samp_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_option_choice_map_variance_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant.option_choice_map"
"""
input restaurant_option_choice_map_variance_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
unique or primary key constraints on table "restaurant.option"
"""
enum restaurant_option_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_option_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.option"
"""
input restaurant_option_inc_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant.option"
"""
input restaurant_option_insert_input {
  choices: restaurant_option_choice_map_arr_rel_insert_input
  cost_per_extra: money
  free_choice: Int
  id: Int
  items: restaurant_item_option_map_arr_rel_insert_input
  maximum_choice: Int
  minimum_choice: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  option_type: String
  position: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_option_max_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant.option"
"""
input restaurant_option_max_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_option_min_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant.option"
"""
input restaurant_option_min_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant.option"
"""
type restaurant_option_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option!]!
}

"""
on_conflict condition type for table "restaurant.option"
"""
input restaurant_option_on_conflict {
  constraint: restaurant_option_constraint!
  update_columns: [restaurant_option_update_column!]! = []
  where: restaurant_option_bool_exp
}

"""Ordering options when selecting data from "restaurant.option"."""
input restaurant_option_order_by {
  choices_aggregate: restaurant_option_choice_map_aggregate_order_by
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  items_aggregate: restaurant_item_option_map_aggregate_order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name: translation_order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant.option"""
input restaurant_option_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.option"
"""
enum restaurant_option_select_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant.option"
"""
input restaurant_option_set_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_option_stddev_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant.option"
"""
input restaurant_option_stddev_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_stddev_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.option"
"""
input restaurant_option_stddev_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_stddev_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.option"
"""
input restaurant_option_stddev_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_option"
"""
input restaurant_option_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_stream_cursor_value_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_option_sum_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant.option"
"""
input restaurant_option_sum_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant.option"
"""
enum restaurant_option_update_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position

  """column name"""
  restaurant_id
}

input restaurant_option_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_set_input

  """filter the rows which have to be updated"""
  where: restaurant_option_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_var_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant.option"
"""
input restaurant_option_var_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_var_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant.option"
"""
input restaurant_option_var_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_option_variance_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant.option"
"""
input restaurant_option_variance_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
columns and relationships of "restaurant.order"
"""
type restaurant_order {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz

  """An object relationship"""
  chat: chat
  chat_id: Int

  """An object relationship"""
  customer: customer_customer!
  customer_app_type: String!
  customer_id: Int!

  """An object relationship"""
  delivery: delivery_order
  delivery_cost: money!
  delivery_id: Int
  delivery_type: String!
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int!

  """
  A computed field, executes function "in_process"
  """
  in_process: Boolean

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  A computed field, executes function "itemscost"
  """
  items_cost: money
  notes: String
  order_time: timestamptz!
  payment_type: String!
  refund_amount: money!

  """An object relationship"""
  restaurant: restaurant_restaurant!
  restaurant_id: Int!

  """An object relationship"""
  review: review
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String!
  stripe_fees: money!

  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
  tax: money!
  to_location_address: String
  to_location_gps: geography

  """
  A computed field, executes function "totalcost"
  """
  total_cost: money
}

"""
aggregated selection of "restaurant.order"
"""
type restaurant_order_aggregate {
  aggregate: restaurant_order_aggregate_fields
  nodes: [restaurant_order!]!
}

input restaurant_order_aggregate_bool_exp {
  count: restaurant_order_aggregate_bool_exp_count
}

input restaurant_order_aggregate_bool_exp_count {
  arguments: [restaurant_order_select_column!]
  distinct: Boolean
  filter: restaurant_order_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.order"
"""
type restaurant_order_aggregate_fields {
  avg: restaurant_order_avg_fields
  count(columns: [restaurant_order_select_column!], distinct: Boolean): Int!
  max: restaurant_order_max_fields
  min: restaurant_order_min_fields
  stddev: restaurant_order_stddev_fields
  stddev_pop: restaurant_order_stddev_pop_fields
  stddev_samp: restaurant_order_stddev_samp_fields
  sum: restaurant_order_sum_fields
  var_pop: restaurant_order_var_pop_fields
  var_samp: restaurant_order_var_samp_fields
  variance: restaurant_order_variance_fields
}

"""
order by aggregate values of table "restaurant.order"
"""
input restaurant_order_aggregate_order_by {
  avg: restaurant_order_avg_order_by
  count: order_by
  max: restaurant_order_max_order_by
  min: restaurant_order_min_order_by
  stddev: restaurant_order_stddev_order_by
  stddev_pop: restaurant_order_stddev_pop_order_by
  stddev_samp: restaurant_order_stddev_samp_order_by
  sum: restaurant_order_sum_order_by
  var_pop: restaurant_order_var_pop_order_by
  var_samp: restaurant_order_var_samp_order_by
  variance: restaurant_order_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input restaurant_order_append_input {
  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: jsonb
}

"""
input type for inserting array relation for remote table "restaurant.order"
"""
input restaurant_order_arr_rel_insert_input {
  data: [restaurant_order_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_avg_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by avg() on columns of table "restaurant.order"
"""
input restaurant_order_avg_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.order". All fields are combined with a logical 'AND'.
"""
input restaurant_order_bool_exp {
  _and: [restaurant_order_bool_exp!]
  _not: restaurant_order_bool_exp
  _or: [restaurant_order_bool_exp!]
  actual_food_ready_time: timestamptz_comparison_exp
  cancellation_time: timestamptz_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  customer: customer_customer_bool_exp
  customer_app_type: String_comparison_exp
  customer_id: Int_comparison_exp
  delivery: delivery_order_bool_exp
  delivery_cost: money_comparison_exp
  delivery_id: Int_comparison_exp
  delivery_type: String_comparison_exp
  estimated_food_ready_time: timestamptz_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  in_process: Boolean_comparison_exp
  items: restaurant_order_item_bool_exp
  items_aggregate: restaurant_order_item_aggregate_bool_exp
  items_cost: money_comparison_exp
  notes: String_comparison_exp
  order_time: timestamptz_comparison_exp
  payment_type: String_comparison_exp
  refund_amount: money_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  review: review_bool_exp
  review_id: Int_comparison_exp
  scheduled_time: timestamptz_comparison_exp
  status: String_comparison_exp
  stripe_fees: money_comparison_exp
  stripe_info: jsonb_comparison_exp
  tax: money_comparison_exp
  to_location_address: String_comparison_exp
  to_location_gps: geography_comparison_exp
  total_cost: money_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.order"
"""
enum restaurant_order_constraint {
  """
  unique or primary key constraint on columns "delivery_id"
  """
  restaurant_order_delivery_id_key

  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_order_firebase_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input restaurant_order_delete_at_path_input {
  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input restaurant_order_delete_elem_input {
  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input restaurant_order_delete_key_input {
  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "restaurant.order"
"""
input restaurant_order_inc_input {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  stripe_fees: money
  tax: money
}

"""
input type for inserting data into table "restaurant.order"
"""
input restaurant_order_insert_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat: chat_obj_rel_insert_input
  chat_id: Int
  customer: customer_customer_obj_rel_insert_input
  customer_app_type: String
  customer_id: Int
  delivery: delivery_order_obj_rel_insert_input
  delivery_cost: money
  delivery_id: Int
  delivery_type: String
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  items: restaurant_order_item_arr_rel_insert_input
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  restaurant: restaurant_restaurant_obj_rel_insert_input
  restaurant_id: Int
  review: review_obj_rel_insert_input
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money

  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""in_json:[name(en,es), selected_options]"""
type restaurant_order_item {
  cost_per_one: money!
  id: Int!
  in_json(
    """JSON select path"""
    path: String
  ): json!
  notes: String

  """An object relationship"""
  order: restaurant_order!
  quantity: Int!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!
  restaurant_order_id: Int!
  review_id: Int
  unavailable: Boolean!
}

"""
aggregated selection of "restaurant.order_item"
"""
type restaurant_order_item_aggregate {
  aggregate: restaurant_order_item_aggregate_fields
  nodes: [restaurant_order_item!]!
}

input restaurant_order_item_aggregate_bool_exp {
  bool_and: restaurant_order_item_aggregate_bool_exp_bool_and
  bool_or: restaurant_order_item_aggregate_bool_exp_bool_or
  count: restaurant_order_item_aggregate_bool_exp_count
}

input restaurant_order_item_aggregate_bool_exp_bool_and {
  arguments: restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_order_item_aggregate_bool_exp_bool_or {
  arguments: restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_order_item_aggregate_bool_exp_count {
  arguments: [restaurant_order_item_select_column!]
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.order_item"
"""
type restaurant_order_item_aggregate_fields {
  avg: restaurant_order_item_avg_fields
  count(columns: [restaurant_order_item_select_column!], distinct: Boolean): Int!
  max: restaurant_order_item_max_fields
  min: restaurant_order_item_min_fields
  stddev: restaurant_order_item_stddev_fields
  stddev_pop: restaurant_order_item_stddev_pop_fields
  stddev_samp: restaurant_order_item_stddev_samp_fields
  sum: restaurant_order_item_sum_fields
  var_pop: restaurant_order_item_var_pop_fields
  var_samp: restaurant_order_item_var_samp_fields
  variance: restaurant_order_item_variance_fields
}

"""
order by aggregate values of table "restaurant.order_item"
"""
input restaurant_order_item_aggregate_order_by {
  avg: restaurant_order_item_avg_order_by
  count: order_by
  max: restaurant_order_item_max_order_by
  min: restaurant_order_item_min_order_by
  stddev: restaurant_order_item_stddev_order_by
  stddev_pop: restaurant_order_item_stddev_pop_order_by
  stddev_samp: restaurant_order_item_stddev_samp_order_by
  sum: restaurant_order_item_sum_order_by
  var_pop: restaurant_order_item_var_pop_order_by
  var_samp: restaurant_order_item_var_samp_order_by
  variance: restaurant_order_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant.order_item"
"""
input restaurant_order_item_arr_rel_insert_input {
  data: [restaurant_order_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_item_avg_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by avg() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_avg_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.order_item". All fields are combined with a logical 'AND'.
"""
input restaurant_order_item_bool_exp {
  _and: [restaurant_order_item_bool_exp!]
  _not: restaurant_order_item_bool_exp
  _or: [restaurant_order_item_bool_exp!]
  cost_per_one: money_comparison_exp
  id: Int_comparison_exp
  in_json: json_comparison_exp
  notes: String_comparison_exp
  order: restaurant_order_bool_exp
  quantity: Int_comparison_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  restaurant_order_id: Int_comparison_exp
  review_id: Int_comparison_exp
  unavailable: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.order_item"
"""
enum restaurant_order_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant.order_item"
"""
input restaurant_order_item_inc_input {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
input type for inserting data into table "restaurant.order_item"
"""
input restaurant_order_item_insert_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  order: restaurant_order_obj_rel_insert_input
  quantity: Int
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate max on columns"""
type restaurant_order_item_max_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by max() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_max_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate min on columns"""
type restaurant_order_item_min_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by min() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_min_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
response of any mutation on the table "restaurant.order_item"
"""
type restaurant_order_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order_item!]!
}

"""
on_conflict condition type for table "restaurant.order_item"
"""
input restaurant_order_item_on_conflict {
  constraint: restaurant_order_item_constraint!
  update_columns: [restaurant_order_item_update_column!]! = []
  where: restaurant_order_item_bool_exp
}

"""Ordering options when selecting data from "restaurant.order_item"."""
input restaurant_order_item_order_by {
  cost_per_one: order_by
  id: order_by
  in_json: order_by
  notes: order_by
  order: restaurant_order_order_by
  quantity: order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
  unavailable: order_by
}

"""primary key columns input for table: restaurant.order_item"""
input restaurant_order_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant.order_item"
"""
enum restaurant_order_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

"""
select "restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant.order_item"
"""
enum restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  unavailable
}

"""
select "restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant.order_item"
"""
enum restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  unavailable
}

"""
input type for updating data in table "restaurant.order_item"
"""
input restaurant_order_item_set_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate stddev on columns"""
type restaurant_order_item_stddev_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_stddev_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_item_stddev_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_stddev_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_item_stddev_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_stddev_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Streaming cursor of the table "restaurant_order_item"
"""
input restaurant_order_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_item_stream_cursor_value_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate sum on columns"""
type restaurant_order_item_sum_fields {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by sum() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_sum_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
update columns of table "restaurant.order_item"
"""
enum restaurant_order_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

input restaurant_order_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_item_set_input

  """filter the rows which have to be updated"""
  where: restaurant_order_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_item_var_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_pop() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_var_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_item_var_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_samp() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_var_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate variance on columns"""
type restaurant_order_item_variance_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by variance() on columns of table "restaurant.order_item"
"""
input restaurant_order_item_variance_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate max on columns"""
type restaurant_order_max_fields {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  delivery_type: String
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  tax: money
  to_location_address: String
}

"""
order by max() on columns of table "restaurant.order"
"""
input restaurant_order_max_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  delivery_type: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  scheduled_time: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_fees: order_by
  tax: order_by
  to_location_address: order_by
}

"""aggregate min on columns"""
type restaurant_order_min_fields {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  delivery_type: String
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  tax: money
  to_location_address: String
}

"""
order by min() on columns of table "restaurant.order"
"""
input restaurant_order_min_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  delivery_type: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  scheduled_time: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_fees: order_by
  tax: order_by
  to_location_address: order_by
}

"""
response of any mutation on the table "restaurant.order"
"""
type restaurant_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order!]!
}

"""
input type for inserting object relation for remote table "restaurant.order"
"""
input restaurant_order_obj_rel_insert_input {
  data: restaurant_order_insert_input!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""
on_conflict condition type for table "restaurant.order"
"""
input restaurant_order_on_conflict {
  constraint: restaurant_order_constraint!
  update_columns: [restaurant_order_update_column!]! = []
  where: restaurant_order_bool_exp
}

"""Ordering options when selecting data from "restaurant.order"."""
input restaurant_order_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat: chat_order_by
  chat_id: order_by
  customer: customer_customer_order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery: delivery_order_order_by
  delivery_cost: order_by
  delivery_id: order_by
  delivery_type: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  in_process: order_by
  items_aggregate: restaurant_order_item_aggregate_order_by
  items_cost: order_by
  notes: order_by
  order_time: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant: restaurant_restaurant_order_by
  restaurant_id: order_by
  review: review_order_by
  review_id: order_by
  scheduled_time: order_by
  status: order_by
  stripe_fees: order_by
  stripe_info: order_by
  tax: order_by
  to_location_address: order_by
  to_location_gps: order_by
  total_cost: order_by
}

"""primary key columns input for table: restaurant.order"""
input restaurant_order_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input restaurant_order_prepend_input {
  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: jsonb
}

"""
columns and relationships of "restaurant.order_public"
"""
type restaurant_order_public {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int

  """An array relationship"""
  restaurant_operators(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """An aggregate relationship"""
  restaurant_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!
  review_id: Int
  status: String
}

"""
aggregated selection of "restaurant.order_public"
"""
type restaurant_order_public_aggregate {
  aggregate: restaurant_order_public_aggregate_fields
  nodes: [restaurant_order_public!]!
}

"""
aggregate fields of "restaurant.order_public"
"""
type restaurant_order_public_aggregate_fields {
  avg: restaurant_order_public_avg_fields
  count(columns: [restaurant_order_public_select_column!], distinct: Boolean): Int!
  max: restaurant_order_public_max_fields
  min: restaurant_order_public_min_fields
  stddev: restaurant_order_public_stddev_fields
  stddev_pop: restaurant_order_public_stddev_pop_fields
  stddev_samp: restaurant_order_public_stddev_samp_fields
  sum: restaurant_order_public_sum_fields
  var_pop: restaurant_order_public_var_pop_fields
  var_samp: restaurant_order_public_var_samp_fields
  variance: restaurant_order_public_variance_fields
}

"""aggregate avg on columns"""
type restaurant_order_public_avg_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant.order_public". All fields are combined with a logical 'AND'.
"""
input restaurant_order_public_bool_exp {
  _and: [restaurant_order_public_bool_exp!]
  _not: restaurant_order_public_bool_exp
  _or: [restaurant_order_public_bool_exp!]
  actual_food_ready_time: timestamptz_comparison_exp
  customer_id: Int_comparison_exp
  estimated_food_ready_time: timestamptz_comparison_exp
  order_time: timestamptz_comparison_exp
  restaurant_id: Int_comparison_exp
  restaurant_operators: restaurant_operator_bool_exp
  restaurant_operators_aggregate: restaurant_operator_aggregate_bool_exp
  review_id: Int_comparison_exp
  status: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "restaurant.order_public"
"""
input restaurant_order_public_inc_input {
  customer_id: Int
  restaurant_id: Int
  review_id: Int
}

"""
input type for inserting data into table "restaurant.order_public"
"""
input restaurant_order_public_insert_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  restaurant_operators: restaurant_operator_arr_rel_insert_input
  review_id: Int
  status: String
}

"""aggregate max on columns"""
type restaurant_order_public_max_fields {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate min on columns"""
type restaurant_order_public_min_fields {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""
response of any mutation on the table "restaurant.order_public"
"""
type restaurant_order_public_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order_public!]!
}

"""Ordering options when selecting data from "restaurant.order_public"."""
input restaurant_order_public_order_by {
  actual_food_ready_time: order_by
  customer_id: order_by
  estimated_food_ready_time: order_by
  order_time: order_by
  restaurant_id: order_by
  restaurant_operators_aggregate: restaurant_operator_aggregate_order_by
  review_id: order_by
  status: order_by
}

"""
select columns of table "restaurant.order_public"
"""
enum restaurant_order_public_select_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  customer_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  order_time

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  status
}

"""
input type for updating data in table "restaurant.order_public"
"""
input restaurant_order_public_set_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate stddev on columns"""
type restaurant_order_public_stddev_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_order_public_stddev_pop_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_order_public_stddev_samp_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
Streaming cursor of the table "restaurant_order_public"
"""
input restaurant_order_public_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_public_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_public_stream_cursor_value_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate sum on columns"""
type restaurant_order_public_sum_fields {
  customer_id: Int
  restaurant_id: Int
  review_id: Int
}

input restaurant_order_public_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_public_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_public_set_input

  """filter the rows which have to be updated"""
  where: restaurant_order_public_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_public_var_pop_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_order_public_var_samp_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate variance on columns"""
type restaurant_order_public_variance_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
select columns of table "restaurant.order"
"""
enum restaurant_order_select_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  delivery_type

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

"""
input type for updating data in table "restaurant.order"
"""
input restaurant_order_set_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  delivery_type: String
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money

  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""aggregate stddev on columns"""
type restaurant_order_stddev_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev() on columns of table "restaurant.order"
"""
input restaurant_order_stddev_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_stddev_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev_pop() on columns of table "restaurant.order"
"""
input restaurant_order_stddev_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_stddev_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev_samp() on columns of table "restaurant.order"
"""
input restaurant_order_stddev_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
Streaming cursor of the table "restaurant_order"
"""
input restaurant_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_stream_cursor_value_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  delivery_type: String
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money

  """
  { id: string, stripeFees: number, amountCharged: number, amountRefunded:
  number, chargeFeesOnCustomer: boolean |null; brand?: string, expMonth?:
  number, expYear?: number, last4?: string, status: (authorized, captured,
  cancelled), serviceProviderAccount: string }
  """
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""aggregate sum on columns"""
type restaurant_order_sum_fields {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  stripe_fees: money
  tax: money
}

"""
order by sum() on columns of table "restaurant.order"
"""
input restaurant_order_sum_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
update columns of table "restaurant.order"
"""
enum restaurant_order_update_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  delivery_type

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

input restaurant_order_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: restaurant_order_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: restaurant_order_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: restaurant_order_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: restaurant_order_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: restaurant_order_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_set_input

  """filter the rows which have to be updated"""
  where: restaurant_order_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_var_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by var_pop() on columns of table "restaurant.order"
"""
input restaurant_order_var_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_var_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by var_samp() on columns of table "restaurant.order"
"""
input restaurant_order_var_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate variance on columns"""
type restaurant_order_variance_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by variance() on columns of table "restaurant.order"
"""
input restaurant_order_variance_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

input restaurant_orders_by_date_args {
  res_id: Int
}

input restaurant_orders_by_month_args {
  res_id: Int
}

"""
columns and relationships of "restaurant.restaurant"
"""
type restaurant_restaurant {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments(
    """JSON select path"""
    path: String
  ): jsonb
  approved: Boolean!

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!
  creation_time: timestamptz!

  """pickup on or off"""
  customer_pickup: Boolean!

  """delivery on or off"""
  delivery: Boolean!

  """An object relationship"""
  delivery_details: delivery_details
  delivery_details_id: Int

  """
  A computed field, executes function "restaurant_delivery_details"
  """
  delivery_details_of_deliverer(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): [delivery_details!]

  """An array relationship"""
  delivery_drivers(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """An aggregate relationship"""
  delivery_drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """An object relationship"""
  delivery_partner: service_provider_delivery_partner

  """An object relationship"""
  description: translation
  description_id: Int
  firebase_id: String
  id: Int!
  image: String!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!
  language_id: String!

  """An object relationship"""
  location: service_provider_location!
  location_id: Int!
  name: String!

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String!

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """An aggregate relationship"""
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!
  phone_number: String

  """An array relationship"""
  restaurant_operators(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """An aggregate relationship"""
  restaurant_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """An array relationship"""
  reviews(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """An aggregate relationship"""
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!
  schedule(
    """JSON select path"""
    path: String
  ): jsonb
  self_delivery: Boolean!
  service_provider_type: String!

  """
  A computed field, executes function "special_items"
  """
  specials(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "restaurant.restaurant"
"""
type restaurant_restaurant_aggregate {
  aggregate: restaurant_restaurant_aggregate_fields
  nodes: [restaurant_restaurant!]!
}

input restaurant_restaurant_aggregate_bool_exp {
  bool_and: restaurant_restaurant_aggregate_bool_exp_bool_and
  bool_or: restaurant_restaurant_aggregate_bool_exp_bool_or
  count: restaurant_restaurant_aggregate_bool_exp_count
}

input restaurant_restaurant_aggregate_bool_exp_bool_and {
  arguments: restaurant_restaurant_select_column_restaurant_restaurant_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_restaurant_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_restaurant_aggregate_bool_exp_bool_or {
  arguments: restaurant_restaurant_select_column_restaurant_restaurant_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_restaurant_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_restaurant_aggregate_bool_exp_count {
  arguments: [restaurant_restaurant_select_column!]
  distinct: Boolean
  filter: restaurant_restaurant_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant.restaurant"
"""
type restaurant_restaurant_aggregate_fields {
  avg: restaurant_restaurant_avg_fields
  count(columns: [restaurant_restaurant_select_column!], distinct: Boolean): Int!
  max: restaurant_restaurant_max_fields
  min: restaurant_restaurant_min_fields
  stddev: restaurant_restaurant_stddev_fields
  stddev_pop: restaurant_restaurant_stddev_pop_fields
  stddev_samp: restaurant_restaurant_stddev_samp_fields
  sum: restaurant_restaurant_sum_fields
  var_pop: restaurant_restaurant_var_pop_fields
  var_samp: restaurant_restaurant_var_samp_fields
  variance: restaurant_restaurant_variance_fields
}

"""
order by aggregate values of table "restaurant.restaurant"
"""
input restaurant_restaurant_aggregate_order_by {
  avg: restaurant_restaurant_avg_order_by
  count: order_by
  max: restaurant_restaurant_max_order_by
  min: restaurant_restaurant_min_order_by
  stddev: restaurant_restaurant_stddev_order_by
  stddev_pop: restaurant_restaurant_stddev_pop_order_by
  stddev_samp: restaurant_restaurant_stddev_samp_order_by
  sum: restaurant_restaurant_sum_order_by
  var_pop: restaurant_restaurant_var_pop_order_by
  var_samp: restaurant_restaurant_var_samp_order_by
  variance: restaurant_restaurant_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input restaurant_restaurant_append_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: jsonb
  schedule: jsonb

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: jsonb
}

"""
input type for inserting array relation for remote table "restaurant.restaurant"
"""
input restaurant_restaurant_arr_rel_insert_input {
  data: [restaurant_restaurant_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_restaurant_on_conflict
}

"""aggregate avg on columns"""
type restaurant_restaurant_avg_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by avg() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_avg_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant.restaurant". All fields are combined with a logical 'AND'.
"""
input restaurant_restaurant_bool_exp {
  _and: [restaurant_restaurant_bool_exp!]
  _not: restaurant_restaurant_bool_exp
  _or: [restaurant_restaurant_bool_exp!]
  accepted_payments: jsonb_comparison_exp
  approved: Boolean_comparison_exp
  categories: restaurant_category_bool_exp
  categories_aggregate: restaurant_category_aggregate_bool_exp
  creation_time: timestamptz_comparison_exp
  customer_pickup: Boolean_comparison_exp
  delivery: Boolean_comparison_exp
  delivery_details: delivery_details_bool_exp
  delivery_details_id: Int_comparison_exp
  delivery_details_of_deliverer: delivery_details_bool_exp
  delivery_drivers: delivery_driver_bool_exp
  delivery_drivers_aggregate: delivery_driver_aggregate_bool_exp
  delivery_partner: service_provider_delivery_partner_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  items: restaurant_item_bool_exp
  items_aggregate: restaurant_item_aggregate_bool_exp
  language_id: String_comparison_exp
  location: service_provider_location_bool_exp
  location_id: Int_comparison_exp
  name: String_comparison_exp
  open_status: String_comparison_exp
  orders: restaurant_order_bool_exp
  orders_aggregate: restaurant_order_aggregate_bool_exp
  phone_number: String_comparison_exp
  restaurant_operators: restaurant_operator_bool_exp
  restaurant_operators_aggregate: restaurant_operator_aggregate_bool_exp
  reviews: review_bool_exp
  reviews_aggregate: review_aggregate_bool_exp
  schedule: jsonb_comparison_exp
  self_delivery: Boolean_comparison_exp
  service_provider_type: String_comparison_exp
  specials: restaurant_item_bool_exp
  stripe_info: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "restaurant.restaurant"
"""
enum restaurant_restaurant_constraint {
  """
  unique or primary key constraint on columns "delivery_details_id"
  """
  restaurant_delivery_details_id_key

  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_firebase_id_key

  """
  unique or primary key constraint on columns "location_id"
  """
  restaurant_location_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input restaurant_restaurant_delete_at_path_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: [String!]
  schedule: [String!]

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input restaurant_restaurant_delete_elem_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: Int
  schedule: Int

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input restaurant_restaurant_delete_key_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: String
  schedule: String

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "restaurant.restaurant"
"""
input restaurant_restaurant_inc_input {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int
}

"""
input type for inserting data into table "restaurant.restaurant"
"""
input restaurant_restaurant_insert_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: jsonb
  approved: Boolean
  categories: restaurant_category_arr_rel_insert_input
  creation_time: timestamptz

  """pickup on or off"""
  customer_pickup: Boolean

  """delivery on or off"""
  delivery: Boolean
  delivery_details: delivery_details_obj_rel_insert_input
  delivery_details_id: Int
  delivery_drivers: delivery_driver_arr_rel_insert_input
  delivery_partner: service_provider_delivery_partner_obj_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  items: restaurant_item_arr_rel_insert_input
  language_id: String
  location: service_provider_location_obj_rel_insert_input
  location_id: Int
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  orders: restaurant_order_arr_rel_insert_input
  phone_number: String
  restaurant_operators: restaurant_operator_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: jsonb
}

"""aggregate max on columns"""
type restaurant_restaurant_max_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  phone_number: String
  service_provider_type: String
}

"""
order by max() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_max_order_by {
  creation_time: order_by
  delivery_details_id: order_by
  description_id: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  location_id: order_by
  name: order_by

  """open, closed_temporarily, closed_indefinitely"""
  open_status: order_by
  phone_number: order_by
  service_provider_type: order_by
}

"""aggregate min on columns"""
type restaurant_restaurant_min_fields {
  creation_time: timestamptz
  delivery_details_id: Int
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  phone_number: String
  service_provider_type: String
}

"""
order by min() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_min_order_by {
  creation_time: order_by
  delivery_details_id: order_by
  description_id: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  location_id: order_by
  name: order_by

  """open, closed_temporarily, closed_indefinitely"""
  open_status: order_by
  phone_number: order_by
  service_provider_type: order_by
}

"""
response of any mutation on the table "restaurant.restaurant"
"""
type restaurant_restaurant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_restaurant!]!
}

"""
input type for inserting object relation for remote table "restaurant.restaurant"
"""
input restaurant_restaurant_obj_rel_insert_input {
  data: restaurant_restaurant_insert_input!

  """upsert condition"""
  on_conflict: restaurant_restaurant_on_conflict
}

"""
on_conflict condition type for table "restaurant.restaurant"
"""
input restaurant_restaurant_on_conflict {
  constraint: restaurant_restaurant_constraint!
  update_columns: [restaurant_restaurant_update_column!]! = []
  where: restaurant_restaurant_bool_exp
}

"""Ordering options when selecting data from "restaurant.restaurant"."""
input restaurant_restaurant_order_by {
  accepted_payments: order_by
  approved: order_by
  categories_aggregate: restaurant_category_aggregate_order_by
  creation_time: order_by
  customer_pickup: order_by
  delivery: order_by
  delivery_details: delivery_details_order_by
  delivery_details_id: order_by
  delivery_details_of_deliverer_aggregate: delivery_details_aggregate_order_by
  delivery_drivers_aggregate: delivery_driver_aggregate_order_by
  delivery_partner: service_provider_delivery_partner_order_by
  description: translation_order_by
  description_id: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  items_aggregate: restaurant_item_aggregate_order_by
  language_id: order_by
  location: service_provider_location_order_by
  location_id: order_by
  name: order_by
  open_status: order_by
  orders_aggregate: restaurant_order_aggregate_order_by
  phone_number: order_by
  restaurant_operators_aggregate: restaurant_operator_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  schedule: order_by
  self_delivery: order_by
  service_provider_type: order_by
  specials_aggregate: restaurant_item_aggregate_order_by
  stripe_info: order_by
}

"""primary key columns input for table: restaurant.restaurant"""
input restaurant_restaurant_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input restaurant_restaurant_prepend_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: jsonb
  schedule: jsonb

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: jsonb
}

"""
select columns of table "restaurant.restaurant"
"""
enum restaurant_restaurant_select_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  phone_number

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

"""
select "restaurant_restaurant_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant.restaurant"
"""
enum restaurant_restaurant_select_column_restaurant_restaurant_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  approved

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  self_delivery
}

"""
select "restaurant_restaurant_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant.restaurant"
"""
enum restaurant_restaurant_select_column_restaurant_restaurant_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  approved

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  self_delivery
}

"""
input type for updating data in table "restaurant.restaurant"
"""
input restaurant_restaurant_set_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: jsonb
  approved: Boolean
  creation_time: timestamptz

  """pickup on or off"""
  customer_pickup: Boolean

  """delivery on or off"""
  delivery: Boolean
  delivery_details_id: Int
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  phone_number: String
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: jsonb
}

"""aggregate stddev on columns"""
type restaurant_restaurant_stddev_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_stddev_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_restaurant_stddev_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_stddev_pop_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_restaurant_stddev_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_stddev_samp_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
Streaming cursor of the table "restaurant_restaurant"
"""
input restaurant_restaurant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_restaurant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_restaurant_stream_cursor_value_input {
  """Record of PaymentType(cash, card, bank transfer) and boolean"""
  accepted_payments: jsonb
  approved: Boolean
  creation_time: timestamptz

  """pickup on or off"""
  customer_pickup: Boolean

  """delivery on or off"""
  delivery: Boolean
  delivery_details_id: Int
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_id: Int
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  phone_number: String
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String

  """
  { id: string; status: string; chargeFeesOnCustomer: boolean | null;
  chargesEnabled: boolean; payoutsEnabled: boolean; detailsSubmitted: boolean;
  requirements: string[] | null; email: string | null }
  """
  stripe_info: jsonb
}

"""aggregate sum on columns"""
type restaurant_restaurant_sum_fields {
  delivery_details_id: Int
  description_id: Int
  id: Int
  location_id: Int
}

"""
order by sum() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_sum_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
update columns of table "restaurant.restaurant"
"""
enum restaurant_restaurant_update_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  creation_time

  """column name"""
  customer_pickup

  """column name"""
  delivery

  """column name"""
  delivery_details_id

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_id

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  phone_number

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

input restaurant_restaurant_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: restaurant_restaurant_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: restaurant_restaurant_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: restaurant_restaurant_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: restaurant_restaurant_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_restaurant_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: restaurant_restaurant_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_restaurant_set_input

  """filter the rows which have to be updated"""
  where: restaurant_restaurant_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_restaurant_var_pop_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by var_pop() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_var_pop_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_restaurant_var_samp_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by var_samp() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_var_samp_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""aggregate variance on columns"""
type restaurant_restaurant_variance_fields {
  delivery_details_id: Float
  description_id: Float
  id: Float
  location_id: Float
}

"""
order by variance() on columns of table "restaurant.restaurant"
"""
input restaurant_restaurant_variance_order_by {
  delivery_details_id: order_by
  description_id: order_by
  id: order_by
  location_id: order_by
}

"""
columns and relationships of "review"
"""
type review {
  created_at: timestamptz!

  """An object relationship"""
  customer: customer_customer
  from_entity_id: Int!
  from_entity_type: String!
  id: Int!
  note: String
  rating: Int!
  to_entity_id: Int!
  to_entity_type: String!
}

"""
aggregated selection of "review"
"""
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

input review_aggregate_bool_exp {
  count: review_aggregate_bool_exp_count
}

input review_aggregate_bool_exp_count {
  arguments: [review_select_column!]
  distinct: Boolean
  filter: review_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "review"
"""
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int!
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

"""
order by aggregate values of table "review"
"""
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

"""
input type for inserting array relation for remote table "review"
"""
input review_arr_rel_insert_input {
  data: [review_insert_input!]!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""aggregate avg on columns"""
type review_avg_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by avg() on columns of table "review"
"""
input review_avg_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
"""
input review_bool_exp {
  _and: [review_bool_exp!]
  _not: review_bool_exp
  _or: [review_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer: customer_customer_bool_exp
  from_entity_id: Int_comparison_exp
  from_entity_type: String_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  rating: Int_comparison_exp
  to_entity_id: Int_comparison_exp
  to_entity_type: String_comparison_exp
}

"""
unique or primary key constraints on table "review"
"""
enum review_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  review_pkey
}

"""
input type for incrementing numeric columns in table "review"
"""
input review_inc_input {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
input type for inserting data into table "review"
"""
input review_insert_input {
  created_at: timestamptz
  customer: customer_customer_obj_rel_insert_input
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate max on columns"""
type review_max_fields {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""
order by max() on columns of table "review"
"""
input review_max_order_by {
  created_at: order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""aggregate min on columns"""
type review_min_fields {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""
order by min() on columns of table "review"
"""
input review_min_order_by {
  created_at: order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""
response of any mutation on the table "review"
"""
type review_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [review!]!
}

"""
input type for inserting object relation for remote table "review"
"""
input review_obj_rel_insert_input {
  data: review_insert_input!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""
on_conflict condition type for table "review"
"""
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]! = []
  where: review_bool_exp
}

"""Ordering options when selecting data from "review"."""
input review_order_by {
  created_at: order_by
  customer: customer_customer_order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""primary key columns input for table: review"""
input review_pk_columns_input {
  id: Int!
}

"""
select columns of table "review"
"""
enum review_select_column {
  """column name"""
  created_at

  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

"""
input type for updating data in table "review"
"""
input review_set_input {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate stddev on columns"""
type review_stddev_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev() on columns of table "review"
"""
input review_stddev_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate stddev_pop on columns"""
type review_stddev_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev_pop() on columns of table "review"
"""
input review_stddev_pop_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate stddev_samp on columns"""
type review_stddev_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev_samp() on columns of table "review"
"""
input review_stddev_samp_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
Streaming cursor of the table "review"
"""
input review_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: review_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input review_stream_cursor_value_input {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate sum on columns"""
type review_sum_fields {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
order by sum() on columns of table "review"
"""
input review_sum_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
update columns of table "review"
"""
enum review_update_column {
  """column name"""
  created_at

  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

input review_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: review_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: review_set_input

  """filter the rows which have to be updated"""
  where: review_bool_exp!
}

"""aggregate var_pop on columns"""
type review_var_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by var_pop() on columns of table "review"
"""
input review_var_pop_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate var_samp on columns"""
type review_var_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by var_samp() on columns of table "review"
"""
input review_var_samp_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate variance on columns"""
type review_variance_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by variance() on columns of table "review"
"""
input review_variance_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
columns and relationships of "service_provider_customer_chat"
"""
type service_provider_customer_chat {
  """An object relationship"""
  chat: chat
  chat_id: Int!

  """An object relationship"""
  customer: customer_customer
  customer_id: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "service_provider_customer_chat"
"""
type service_provider_customer_chat_aggregate {
  aggregate: service_provider_customer_chat_aggregate_fields
  nodes: [service_provider_customer_chat!]!
}

"""
aggregate fields of "service_provider_customer_chat"
"""
type service_provider_customer_chat_aggregate_fields {
  avg: service_provider_customer_chat_avg_fields
  count(columns: [service_provider_customer_chat_select_column!], distinct: Boolean): Int!
  max: service_provider_customer_chat_max_fields
  min: service_provider_customer_chat_min_fields
  stddev: service_provider_customer_chat_stddev_fields
  stddev_pop: service_provider_customer_chat_stddev_pop_fields
  stddev_samp: service_provider_customer_chat_stddev_samp_fields
  sum: service_provider_customer_chat_sum_fields
  var_pop: service_provider_customer_chat_var_pop_fields
  var_samp: service_provider_customer_chat_var_samp_fields
  variance: service_provider_customer_chat_variance_fields
}

"""aggregate avg on columns"""
type service_provider_customer_chat_avg_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table
"service_provider_customer_chat". All fields are combined with a logical 'AND'.
"""
input service_provider_customer_chat_bool_exp {
  _and: [service_provider_customer_chat_bool_exp!]
  _not: service_provider_customer_chat_bool_exp
  _or: [service_provider_customer_chat_bool_exp!]
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  customer: customer_customer_bool_exp
  customer_id: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "service_provider_customer_chat"
"""
enum service_provider_customer_chat_constraint {
  """
  unique or primary key constraint on columns "service_provider_type", "service_provider_id", "customer_id"
  """
  service_provider_customer_cha_customer_id_service_provider__key

  """
  unique or primary key constraint on columns "chat_id"
  """
  service_provider_customer_chat_pkey
}

"""
input type for incrementing numeric columns in table "service_provider_customer_chat"
"""
input service_provider_customer_chat_inc_input {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_provider_customer_chat"
"""
input service_provider_customer_chat_insert_input {
  chat: chat_obj_rel_insert_input
  chat_id: Int
  customer: customer_customer_obj_rel_insert_input
  customer_id: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type service_provider_customer_chat_max_fields {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_provider_customer_chat_min_fields {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_provider_customer_chat"
"""
type service_provider_customer_chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_customer_chat!]!
}

"""
on_conflict condition type for table "service_provider_customer_chat"
"""
input service_provider_customer_chat_on_conflict {
  constraint: service_provider_customer_chat_constraint!
  update_columns: [service_provider_customer_chat_update_column!]! = []
  where: service_provider_customer_chat_bool_exp
}

"""
Ordering options when selecting data from "service_provider_customer_chat".
"""
input service_provider_customer_chat_order_by {
  chat: chat_order_by
  chat_id: order_by
  customer: customer_customer_order_by
  customer_id: order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: service_provider_customer_chat"""
input service_provider_customer_chat_pk_columns_input {
  chat_id: Int!
}

"""
select columns of table "service_provider_customer_chat"
"""
enum service_provider_customer_chat_select_column {
  """column name"""
  chat_id

  """column name"""
  customer_id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_provider_customer_chat"
"""
input service_provider_customer_chat_set_input {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_provider_customer_chat_stddev_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_customer_chat_stddev_pop_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_customer_chat_stddev_samp_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_provider_customer_chat"
"""
input service_provider_customer_chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_customer_chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_customer_chat_stream_cursor_value_input {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_provider_customer_chat_sum_fields {
  chat_id: Int
  customer_id: Int
  service_provider_id: Int
}

"""
update columns of table "service_provider_customer_chat"
"""
enum service_provider_customer_chat_update_column {
  """column name"""
  chat_id

  """column name"""
  customer_id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_provider_customer_chat_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_customer_chat_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_customer_chat_set_input

  """filter the rows which have to be updated"""
  where: service_provider_customer_chat_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_customer_chat_var_pop_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_customer_chat_var_samp_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_provider_customer_chat_variance_fields {
  chat_id: Float
  customer_id: Float
  service_provider_id: Float
}

"""
columns and relationships of "service_provider.delivery_partner"
"""
type service_provider_delivery_partner {
  delivery_company_id: Int!
  id: Int!

  """An object relationship"""
  laundry: laundry_store

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "service_provider.delivery_partner"
"""
type service_provider_delivery_partner_aggregate {
  aggregate: service_provider_delivery_partner_aggregate_fields
  nodes: [service_provider_delivery_partner!]!
}

"""
aggregate fields of "service_provider.delivery_partner"
"""
type service_provider_delivery_partner_aggregate_fields {
  avg: service_provider_delivery_partner_avg_fields
  count(columns: [service_provider_delivery_partner_select_column!], distinct: Boolean): Int!
  max: service_provider_delivery_partner_max_fields
  min: service_provider_delivery_partner_min_fields
  stddev: service_provider_delivery_partner_stddev_fields
  stddev_pop: service_provider_delivery_partner_stddev_pop_fields
  stddev_samp: service_provider_delivery_partner_stddev_samp_fields
  sum: service_provider_delivery_partner_sum_fields
  var_pop: service_provider_delivery_partner_var_pop_fields
  var_samp: service_provider_delivery_partner_var_samp_fields
  variance: service_provider_delivery_partner_variance_fields
}

"""aggregate avg on columns"""
type service_provider_delivery_partner_avg_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table
"service_provider.delivery_partner". All fields are combined with a logical 'AND'.
"""
input service_provider_delivery_partner_bool_exp {
  _and: [service_provider_delivery_partner_bool_exp!]
  _not: service_provider_delivery_partner_bool_exp
  _or: [service_provider_delivery_partner_bool_exp!]
  delivery_company_id: Int_comparison_exp
  id: Int_comparison_exp
  laundry: laundry_store_bool_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "service_provider.delivery_partner"
"""
enum service_provider_delivery_partner_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_partner_pkey

  """
  unique or primary key constraint on columns "service_provider_type", "service_provider_id"
  """
  delivery_partner_service_provider_id_service_provider_type_key
}

"""
input type for incrementing numeric columns in table "service_provider.delivery_partner"
"""
input service_provider_delivery_partner_inc_input {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_provider.delivery_partner"
"""
input service_provider_delivery_partner_insert_input {
  delivery_company_id: Int
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type service_provider_delivery_partner_max_fields {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_provider_delivery_partner_min_fields {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_provider.delivery_partner"
"""
type service_provider_delivery_partner_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_delivery_partner!]!
}

"""
input type for inserting object relation for remote table "service_provider.delivery_partner"
"""
input service_provider_delivery_partner_obj_rel_insert_input {
  data: service_provider_delivery_partner_insert_input!

  """upsert condition"""
  on_conflict: service_provider_delivery_partner_on_conflict
}

"""
on_conflict condition type for table "service_provider.delivery_partner"
"""
input service_provider_delivery_partner_on_conflict {
  constraint: service_provider_delivery_partner_constraint!
  update_columns: [service_provider_delivery_partner_update_column!]! = []
  where: service_provider_delivery_partner_bool_exp
}

"""
Ordering options when selecting data from "service_provider.delivery_partner".
"""
input service_provider_delivery_partner_order_by {
  delivery_company_id: order_by
  id: order_by
  laundry: laundry_store_order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: service_provider.delivery_partner"""
input service_provider_delivery_partner_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider.delivery_partner"
"""
enum service_provider_delivery_partner_select_column {
  """column name"""
  delivery_company_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_provider.delivery_partner"
"""
input service_provider_delivery_partner_set_input {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_provider_delivery_partner_stddev_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_delivery_partner_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_delivery_partner_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_provider_delivery_partner"
"""
input service_provider_delivery_partner_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_delivery_partner_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_delivery_partner_stream_cursor_value_input {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_provider_delivery_partner_sum_fields {
  delivery_company_id: Int
  id: Int
  service_provider_id: Int
}

"""
update columns of table "service_provider.delivery_partner"
"""
enum service_provider_delivery_partner_update_column {
  """column name"""
  delivery_company_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_provider_delivery_partner_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_delivery_partner_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_delivery_partner_set_input

  """filter the rows which have to be updated"""
  where: service_provider_delivery_partner_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_delivery_partner_var_pop_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_delivery_partner_var_samp_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_provider_delivery_partner_variance_fields {
  delivery_company_id: Float
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "service_provider.location"
"""
type service_provider_location {
  address: String!

  """An object relationship"""
  delivery_company: delivery_company
  gps: geography!
  id: Int!

  """An object relationship"""
  laundry: laundry_store

  """An object relationship"""
  restaurant: restaurant_restaurant
}

"""
aggregated selection of "service_provider.location"
"""
type service_provider_location_aggregate {
  aggregate: service_provider_location_aggregate_fields
  nodes: [service_provider_location!]!
}

"""
aggregate fields of "service_provider.location"
"""
type service_provider_location_aggregate_fields {
  avg: service_provider_location_avg_fields
  count(columns: [service_provider_location_select_column!], distinct: Boolean): Int!
  max: service_provider_location_max_fields
  min: service_provider_location_min_fields
  stddev: service_provider_location_stddev_fields
  stddev_pop: service_provider_location_stddev_pop_fields
  stddev_samp: service_provider_location_stddev_samp_fields
  sum: service_provider_location_sum_fields
  var_pop: service_provider_location_var_pop_fields
  var_samp: service_provider_location_var_samp_fields
  variance: service_provider_location_variance_fields
}

"""aggregate avg on columns"""
type service_provider_location_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "service_provider.location". All fields are combined with a logical 'AND'.
"""
input service_provider_location_bool_exp {
  _and: [service_provider_location_bool_exp!]
  _not: service_provider_location_bool_exp
  _or: [service_provider_location_bool_exp!]
  address: String_comparison_exp
  delivery_company: delivery_company_bool_exp
  gps: geography_comparison_exp
  id: Int_comparison_exp
  laundry: laundry_store_bool_exp
  restaurant: restaurant_restaurant_bool_exp
}

"""
unique or primary key constraints on table "service_provider.location"
"""
enum service_provider_location_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  location_pkey
}

"""
input type for incrementing numeric columns in table "service_provider.location"
"""
input service_provider_location_inc_input {
  id: Int
}

"""
input type for inserting data into table "service_provider.location"
"""
input service_provider_location_insert_input {
  address: String
  delivery_company: delivery_company_obj_rel_insert_input
  gps: geography
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  restaurant: restaurant_restaurant_obj_rel_insert_input
}

"""aggregate max on columns"""
type service_provider_location_max_fields {
  address: String
  id: Int
}

"""aggregate min on columns"""
type service_provider_location_min_fields {
  address: String
  id: Int
}

"""
response of any mutation on the table "service_provider.location"
"""
type service_provider_location_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_location!]!
}

"""
input type for inserting object relation for remote table "service_provider.location"
"""
input service_provider_location_obj_rel_insert_input {
  data: service_provider_location_insert_input!

  """upsert condition"""
  on_conflict: service_provider_location_on_conflict
}

"""
on_conflict condition type for table "service_provider.location"
"""
input service_provider_location_on_conflict {
  constraint: service_provider_location_constraint!
  update_columns: [service_provider_location_update_column!]! = []
  where: service_provider_location_bool_exp
}

"""Ordering options when selecting data from "service_provider.location"."""
input service_provider_location_order_by {
  address: order_by
  delivery_company: delivery_company_order_by
  gps: order_by
  id: order_by
  laundry: laundry_store_order_by
  restaurant: restaurant_restaurant_order_by
}

"""primary key columns input for table: service_provider.location"""
input service_provider_location_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider.location"
"""
enum service_provider_location_select_column {
  """column name"""
  address

  """column name"""
  gps

  """column name"""
  id
}

"""
input type for updating data in table "service_provider.location"
"""
input service_provider_location_set_input {
  address: String
  gps: geography
  id: Int
}

"""aggregate stddev on columns"""
type service_provider_location_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_location_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_location_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "service_provider_location"
"""
input service_provider_location_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_location_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_location_stream_cursor_value_input {
  address: String
  gps: geography
  id: Int
}

"""aggregate sum on columns"""
type service_provider_location_sum_fields {
  id: Int
}

"""
update columns of table "service_provider.location"
"""
enum service_provider_location_update_column {
  """column name"""
  address

  """column name"""
  gps

  """column name"""
  id
}

input service_provider_location_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_location_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_location_set_input

  """filter the rows which have to be updated"""
  where: service_provider_location_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_location_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type service_provider_location_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type service_provider_location_variance_fields {
  id: Float
}

"""
columns and relationships of "service_provider.post"
"""
type service_provider_post {
  """Array of { message, date, Array of customerIds }"""
  comments(
    """JSON select path"""
    path: String
  ): jsonb
  id: Int!
  image: String

  """Array of customerIds"""
  likes(
    """JSON select path"""
    path: String
  ): jsonb
  message: String!
  posted_on: timestamptz!

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "service_provider.post"
"""
type service_provider_post_aggregate {
  aggregate: service_provider_post_aggregate_fields
  nodes: [service_provider_post!]!
}

"""
aggregate fields of "service_provider.post"
"""
type service_provider_post_aggregate_fields {
  avg: service_provider_post_avg_fields
  count(columns: [service_provider_post_select_column!], distinct: Boolean): Int!
  max: service_provider_post_max_fields
  min: service_provider_post_min_fields
  stddev: service_provider_post_stddev_fields
  stddev_pop: service_provider_post_stddev_pop_fields
  stddev_samp: service_provider_post_stddev_samp_fields
  sum: service_provider_post_sum_fields
  var_pop: service_provider_post_var_pop_fields
  var_samp: service_provider_post_var_samp_fields
  variance: service_provider_post_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input service_provider_post_append_input {
  """Array of { message, date, Array of customerIds }"""
  comments: jsonb

  """Array of customerIds"""
  likes: jsonb
}

"""aggregate avg on columns"""
type service_provider_post_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "service_provider.post". All fields are combined with a logical 'AND'.
"""
input service_provider_post_bool_exp {
  _and: [service_provider_post_bool_exp!]
  _not: service_provider_post_bool_exp
  _or: [service_provider_post_bool_exp!]
  comments: jsonb_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  likes: jsonb_comparison_exp
  message: String_comparison_exp
  posted_on: timestamptz_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "service_provider.post"
"""
enum service_provider_post_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input service_provider_post_delete_at_path_input {
  """Array of { message, date, Array of customerIds }"""
  comments: [String!]

  """Array of customerIds"""
  likes: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input service_provider_post_delete_elem_input {
  """Array of { message, date, Array of customerIds }"""
  comments: Int

  """Array of customerIds"""
  likes: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input service_provider_post_delete_key_input {
  """Array of { message, date, Array of customerIds }"""
  comments: String

  """Array of customerIds"""
  likes: String
}

"""
input type for incrementing numeric columns in table "service_provider.post"
"""
input service_provider_post_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_provider.post"
"""
input service_provider_post_insert_input {
  """Array of { message, date, Array of customerIds }"""
  comments: jsonb
  id: Int
  image: String

  """Array of customerIds"""
  likes: jsonb
  message: String
  posted_on: timestamptz
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type service_provider_post_max_fields {
  id: Int
  image: String
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_provider_post_min_fields {
  id: Int
  image: String
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_provider.post"
"""
type service_provider_post_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_post!]!
}

"""
on_conflict condition type for table "service_provider.post"
"""
input service_provider_post_on_conflict {
  constraint: service_provider_post_constraint!
  update_columns: [service_provider_post_update_column!]! = []
  where: service_provider_post_bool_exp
}

"""Ordering options when selecting data from "service_provider.post"."""
input service_provider_post_order_by {
  comments: order_by
  id: order_by
  image: order_by
  likes: order_by
  message: order_by
  posted_on: order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: service_provider.post"""
input service_provider_post_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input service_provider_post_prepend_input {
  """Array of { message, date, Array of customerIds }"""
  comments: jsonb

  """Array of customerIds"""
  likes: jsonb
}

"""
select columns of table "service_provider.post"
"""
enum service_provider_post_select_column {
  """column name"""
  comments

  """column name"""
  id

  """column name"""
  image

  """column name"""
  likes

  """column name"""
  message

  """column name"""
  posted_on

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_provider.post"
"""
input service_provider_post_set_input {
  """Array of { message, date, Array of customerIds }"""
  comments: jsonb
  id: Int
  image: String

  """Array of customerIds"""
  likes: jsonb
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_provider_post_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_post_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_post_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_provider_post"
"""
input service_provider_post_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_post_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_post_stream_cursor_value_input {
  """Array of { message, date, Array of customerIds }"""
  comments: jsonb
  id: Int
  image: String

  """Array of customerIds"""
  likes: jsonb
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_provider_post_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "service_provider.post"
"""
enum service_provider_post_update_column {
  """column name"""
  comments

  """column name"""
  id

  """column name"""
  image

  """column name"""
  likes

  """column name"""
  message

  """column name"""
  posted_on

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_provider_post_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: service_provider_post_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: service_provider_post_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: service_provider_post_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: service_provider_post_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_post_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: service_provider_post_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_post_set_input

  """filter the rows which have to be updated"""
  where: service_provider_post_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_post_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_post_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_provider_post_variance_fields {
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "service_provider.service_link"
"""
type service_provider_service_link {
  customer_deep_link: String
  customer_qr_image_link: String

  """An object relationship"""
  delivery_company: delivery_company
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int!
  operator_deep_link: String
  operator_qr_image_link: String

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "service_provider.service_link"
"""
type service_provider_service_link_aggregate {
  aggregate: service_provider_service_link_aggregate_fields
  nodes: [service_provider_service_link!]!
}

"""
aggregate fields of "service_provider.service_link"
"""
type service_provider_service_link_aggregate_fields {
  avg: service_provider_service_link_avg_fields
  count(columns: [service_provider_service_link_select_column!], distinct: Boolean): Int!
  max: service_provider_service_link_max_fields
  min: service_provider_service_link_min_fields
  stddev: service_provider_service_link_stddev_fields
  stddev_pop: service_provider_service_link_stddev_pop_fields
  stddev_samp: service_provider_service_link_stddev_samp_fields
  sum: service_provider_service_link_sum_fields
  var_pop: service_provider_service_link_var_pop_fields
  var_samp: service_provider_service_link_var_samp_fields
  variance: service_provider_service_link_variance_fields
}

"""aggregate avg on columns"""
type service_provider_service_link_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table
"service_provider.service_link". All fields are combined with a logical 'AND'.
"""
input service_provider_service_link_bool_exp {
  _and: [service_provider_service_link_bool_exp!]
  _not: service_provider_service_link_bool_exp
  _or: [service_provider_service_link_bool_exp!]
  customer_deep_link: String_comparison_exp
  customer_qr_image_link: String_comparison_exp
  delivery_company: delivery_company_bool_exp
  driver_deep_link: String_comparison_exp
  driver_qr_image_link: String_comparison_exp
  id: Int_comparison_exp
  operator_deep_link: String_comparison_exp
  operator_qr_image_link: String_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "service_provider.service_link"
"""
enum service_provider_service_link_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_links_pkey

  """
  unique or primary key constraint on columns "service_provider_id"
  """
  service_links_provider_id_key
}

"""
input type for incrementing numeric columns in table "service_provider.service_link"
"""
input service_provider_service_link_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_provider.service_link"
"""
input service_provider_service_link_insert_input {
  customer_deep_link: String
  customer_qr_image_link: String
  delivery_company: delivery_company_obj_rel_insert_input
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type service_provider_service_link_max_fields {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_provider_service_link_min_fields {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_provider.service_link"
"""
type service_provider_service_link_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_service_link!]!
}

"""
on_conflict condition type for table "service_provider.service_link"
"""
input service_provider_service_link_on_conflict {
  constraint: service_provider_service_link_constraint!
  update_columns: [service_provider_service_link_update_column!]! = []
  where: service_provider_service_link_bool_exp
}

"""
Ordering options when selecting data from "service_provider.service_link".
"""
input service_provider_service_link_order_by {
  customer_deep_link: order_by
  customer_qr_image_link: order_by
  delivery_company: delivery_company_order_by
  driver_deep_link: order_by
  driver_qr_image_link: order_by
  id: order_by
  operator_deep_link: order_by
  operator_qr_image_link: order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: service_provider.service_link"""
input service_provider_service_link_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider.service_link"
"""
enum service_provider_service_link_select_column {
  """column name"""
  customer_deep_link

  """column name"""
  customer_qr_image_link

  """column name"""
  driver_deep_link

  """column name"""
  driver_qr_image_link

  """column name"""
  id

  """column name"""
  operator_deep_link

  """column name"""
  operator_qr_image_link

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_provider.service_link"
"""
input service_provider_service_link_set_input {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_provider_service_link_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_service_link_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_service_link_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_provider_service_link"
"""
input service_provider_service_link_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_service_link_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_service_link_stream_cursor_value_input {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_provider_service_link_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "service_provider.service_link"
"""
enum service_provider_service_link_update_column {
  """column name"""
  customer_deep_link

  """column name"""
  customer_qr_image_link

  """column name"""
  driver_deep_link

  """column name"""
  driver_qr_image_link

  """column name"""
  id

  """column name"""
  operator_deep_link

  """column name"""
  operator_qr_image_link

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_provider_service_link_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_service_link_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_service_link_set_input

  """filter the rows which have to be updated"""
  where: service_provider_service_link_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_service_link_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_service_link_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_provider_service_link_variance_fields {
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "service_provider.subscriber"
"""
type service_provider_subscriber {
  """An object relationship"""
  customer: customer_customer
  customer_id: Int!
  id: Int!

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!

  """An object relationship"""
  user: user
}

"""
aggregated selection of "service_provider.subscriber"
"""
type service_provider_subscriber_aggregate {
  aggregate: service_provider_subscriber_aggregate_fields
  nodes: [service_provider_subscriber!]!
}

"""
aggregate fields of "service_provider.subscriber"
"""
type service_provider_subscriber_aggregate_fields {
  avg: service_provider_subscriber_avg_fields
  count(columns: [service_provider_subscriber_select_column!], distinct: Boolean): Int!
  max: service_provider_subscriber_max_fields
  min: service_provider_subscriber_min_fields
  stddev: service_provider_subscriber_stddev_fields
  stddev_pop: service_provider_subscriber_stddev_pop_fields
  stddev_samp: service_provider_subscriber_stddev_samp_fields
  sum: service_provider_subscriber_sum_fields
  var_pop: service_provider_subscriber_var_pop_fields
  var_samp: service_provider_subscriber_var_samp_fields
  variance: service_provider_subscriber_variance_fields
}

"""aggregate avg on columns"""
type service_provider_subscriber_avg_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "service_provider.subscriber".
All fields are combined with a logical 'AND'.
"""
input service_provider_subscriber_bool_exp {
  _and: [service_provider_subscriber_bool_exp!]
  _not: service_provider_subscriber_bool_exp
  _or: [service_provider_subscriber_bool_exp!]
  customer: customer_customer_bool_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "service_provider.subscriber"
"""
enum service_provider_subscriber_constraint {
  """
  unique or primary key constraint on columns "service_provider_type", "service_provider_id", "customer_id"
  """
  subscriber_customer_id_service_provider_type_service_provid_key

  """
  unique or primary key constraint on columns "id"
  """
  subscriber_pkey
}

"""
input type for incrementing numeric columns in table "service_provider.subscriber"
"""
input service_provider_subscriber_inc_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_provider.subscriber"
"""
input service_provider_subscriber_insert_input {
  customer: customer_customer_obj_rel_insert_input
  customer_id: Int
  id: Int
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type service_provider_subscriber_max_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_provider_subscriber_min_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_provider.subscriber"
"""
type service_provider_subscriber_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_subscriber!]!
}

"""
on_conflict condition type for table "service_provider.subscriber"
"""
input service_provider_subscriber_on_conflict {
  constraint: service_provider_subscriber_constraint!
  update_columns: [service_provider_subscriber_update_column!]! = []
  where: service_provider_subscriber_bool_exp
}

"""
Ordering options when selecting data from "service_provider.subscriber".
"""
input service_provider_subscriber_order_by {
  customer: customer_customer_order_by
  customer_id: order_by
  id: order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
  user: user_order_by
}

"""primary key columns input for table: service_provider.subscriber"""
input service_provider_subscriber_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider.subscriber"
"""
enum service_provider_subscriber_select_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_provider.subscriber"
"""
input service_provider_subscriber_set_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_provider_subscriber_stddev_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_subscriber_stddev_pop_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_subscriber_stddev_samp_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_provider_subscriber"
"""
input service_provider_subscriber_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_subscriber_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_subscriber_stream_cursor_value_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_provider_subscriber_sum_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
}

"""
update columns of table "service_provider.subscriber"
"""
enum service_provider_subscriber_update_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_provider_subscriber_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_subscriber_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_subscriber_set_input

  """filter the rows which have to be updated"""
  where: service_provider_subscriber_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_subscriber_var_pop_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_subscriber_var_samp_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_provider_subscriber_variance_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "app_type"
  """
  app_type(
    """distinct select on columns"""
    distinct_on: [app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_type_order_by!]

    """filter the rows returned"""
    where: app_type_bool_exp
  ): [app_type!]!

  """
  fetch aggregated fields from the table: "app_type"
  """
  app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_type_order_by!]

    """filter the rows returned"""
    where: app_type_bool_exp
  ): app_type_aggregate!

  """fetch data from the table: "app_type" using primary key columns"""
  app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): app_type

  """
  fetch data from the table in a streaming manner: "app_type"
  """
  app_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [app_type_stream_cursor_input]!

    """filter the rows returned"""
    where: app_type_bool_exp
  ): [app_type!]!

  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table in a streaming manner: "chat_participant"
  """
  chat_participant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_participant_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch data from the table in a streaming manner: "chat"
  """
  chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch data from the table: "customer.customer"
  """
  customer_customer(
    """distinct select on columns"""
    distinct_on: [customer_customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_customer_order_by!]

    """filter the rows returned"""
    where: customer_customer_bool_exp
  ): [customer_customer!]!

  """
  fetch aggregated fields from the table: "customer.customer"
  """
  customer_customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_customer_order_by!]

    """filter the rows returned"""
    where: customer_customer_bool_exp
  ): customer_customer_aggregate!

  """
  fetch data from the table: "customer.customer" using primary key columns
  """
  customer_customer_by_pk(user_id: Int!): customer_customer

  """
  fetch data from the table in a streaming manner: "customer.customer"
  """
  customer_customer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_customer_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_customer_bool_exp
  ): [customer_customer!]!

  """
  fetch data from the table: "customer.favourited_item"
  """
  customer_favourited_item(
    """distinct select on columns"""
    distinct_on: [customer_favourited_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_favourited_item_order_by!]

    """filter the rows returned"""
    where: customer_favourited_item_bool_exp
  ): [customer_favourited_item!]!

  """
  fetch aggregated fields from the table: "customer.favourited_item"
  """
  customer_favourited_item_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_favourited_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_favourited_item_order_by!]

    """filter the rows returned"""
    where: customer_favourited_item_bool_exp
  ): customer_favourited_item_aggregate!

  """
  fetch data from the table: "customer.favourited_item" using primary key columns
  """
  customer_favourited_item_by_pk(id: Int!): customer_favourited_item

  """
  fetch data from the table in a streaming manner: "customer.favourited_item"
  """
  customer_favourited_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_favourited_item_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_favourited_item_bool_exp
  ): [customer_favourited_item!]!

  """
  fetch data from the table: "customer.saved_location"
  """
  customer_saved_location(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): [customer_saved_location!]!

  """
  fetch aggregated fields from the table: "customer.saved_location"
  """
  customer_saved_location_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_saved_location_order_by!]

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): customer_saved_location_aggregate!

  """
  fetch data from the table: "customer.saved_location" using primary key columns
  """
  customer_saved_location_by_pk(id: Int!): customer_saved_location

  """
  fetch data from the table in a streaming manner: "customer.saved_location"
  """
  customer_saved_location_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_saved_location_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_saved_location_bool_exp
  ): [customer_saved_location!]!

  """An array relationship"""
  delivery_company(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """An aggregate relationship"""
  delivery_company_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery.company" using primary key columns
  """
  delivery_company_by_pk(id: Int!): delivery_company

  """
  fetch data from the table in a streaming manner: "delivery.company"
  """
  delivery_company_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_company_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  fetch data from the table: "delivery.details"
  """
  delivery_details(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): [delivery_details!]!

  """
  fetch aggregated fields from the table: "delivery.details"
  """
  delivery_details_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_details_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_details_order_by!]

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): delivery_details_aggregate!

  """
  fetch data from the table: "delivery.details" using primary key columns
  """
  delivery_details_by_pk(id: Int!): delivery_details

  """
  fetch data from the table in a streaming manner: "delivery.details"
  """
  delivery_details_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_details_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_details_bool_exp
  ): [delivery_details!]!

  """
  fetch data from the table: "delivery.driver"
  """
  delivery_driver(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  fetch aggregated fields from the table: "delivery.driver"
  """
  delivery_driver_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """fetch data from the table: "delivery.driver" using primary key columns"""
  delivery_driver_by_pk(id: Int!): delivery_driver

  """
  fetch data from the table in a streaming manner: "delivery.driver"
  """
  delivery_driver_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_driver_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  execute function "delivery.get_delivery_companies" which returns "delivery.company"
  """
  delivery_get_delivery_companies(
    """
    input parameters for function "delivery_get_delivery_companies"
    """
    args: delivery_get_delivery_companies_args!

    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  execute function "delivery.get_delivery_companies" and query aggregates on result of table type "delivery.company"
  """
  delivery_get_delivery_companies_aggregate(
    """
    input parameters for function "delivery_get_delivery_companies_aggregate"
    """
    args: delivery_get_delivery_companies_args!

    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery.operator"
  """
  delivery_operator(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch aggregated fields from the table: "delivery.operator"
  """
  delivery_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """
  fetch data from the table: "delivery.operator" using primary key columns
  """
  delivery_operator_by_pk(id: Int!): delivery_operator

  """
  fetch data from the table in a streaming manner: "delivery.operator"
  """
  delivery_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch data from the table: "delivery.order"
  """
  delivery_order(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch aggregated fields from the table: "delivery.order"
  """
  delivery_order_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """fetch data from the table: "delivery.order" using primary key columns"""
  delivery_order_by_pk(id: Int!): delivery_order

  """
  fetch data from the table: "delivery.order_public"
  """
  delivery_order_public(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch aggregated fields from the table: "delivery.order_public"
  """
  delivery_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): delivery_order_public_aggregate!

  """
  fetch data from the table in a streaming manner: "delivery.order_public"
  """
  delivery_order_public_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_order_public_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch data from the table in a streaming manner: "delivery.order"
  """
  delivery_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_order_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch data from the table: "direct_chat"
  """
  direct_chat(
    """distinct select on columns"""
    distinct_on: [direct_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direct_chat_order_by!]

    """filter the rows returned"""
    where: direct_chat_bool_exp
  ): [direct_chat!]!

  """
  fetch aggregated fields from the table: "direct_chat"
  """
  direct_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [direct_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [direct_chat_order_by!]

    """filter the rows returned"""
    where: direct_chat_bool_exp
  ): direct_chat_aggregate!

  """fetch data from the table: "direct_chat" using primary key columns"""
  direct_chat_by_pk(chat_id: Int!): direct_chat

  """
  fetch data from the table in a streaming manner: "direct_chat"
  """
  direct_chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [direct_chat_stream_cursor_input]!

    """filter the rows returned"""
    where: direct_chat_bool_exp
  ): [direct_chat!]!

  """
  fetch data from the table: "language"
  """
  language(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate(
    """distinct select on columns"""
    distinct_on: [language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [language_order_by!]

    """filter the rows returned"""
    where: language_bool_exp
  ): language_aggregate!

  """fetch data from the table: "language" using primary key columns"""
  language_by_pk(id: String!): language

  """
  fetch data from the table in a streaming manner: "language"
  """
  language_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [language_stream_cursor_input]!

    """filter the rows returned"""
    where: language_bool_exp
  ): [language!]!

  """
  fetch data from the table: "laundry.category"
  """
  laundry_category(
    """distinct select on columns"""
    distinct_on: [laundry_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_category_order_by!]

    """filter the rows returned"""
    where: laundry_category_bool_exp
  ): [laundry_category!]!

  """
  fetch aggregated fields from the table: "laundry.category"
  """
  laundry_category_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_category_order_by!]

    """filter the rows returned"""
    where: laundry_category_bool_exp
  ): laundry_category_aggregate!

  """
  fetch data from the table: "laundry.category" using primary key columns
  """
  laundry_category_by_pk(id: Int!): laundry_category

  """
  fetch data from the table in a streaming manner: "laundry.category"
  """
  laundry_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [laundry_category_stream_cursor_input]!

    """filter the rows returned"""
    where: laundry_category_bool_exp
  ): [laundry_category!]!

  """
  fetch data from the table: "laundry.operator"
  """
  laundry_operator(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): [laundry_operator!]!

  """
  fetch aggregated fields from the table: "laundry.operator"
  """
  laundry_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_operator_order_by!]

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): laundry_operator_aggregate!

  """
  fetch data from the table: "laundry.operator" using primary key columns
  """
  laundry_operator_by_pk(id: Int!): laundry_operator

  """
  fetch data from the table in a streaming manner: "laundry.operator"
  """
  laundry_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [laundry_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: laundry_operator_bool_exp
  ): [laundry_operator!]!

  """
  fetch data from the table: "laundry.order"
  """
  laundry_order(
    """distinct select on columns"""
    distinct_on: [laundry_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_order_by!]

    """filter the rows returned"""
    where: laundry_order_bool_exp
  ): [laundry_order!]!

  """
  fetch aggregated fields from the table: "laundry.order"
  """
  laundry_order_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_order_by!]

    """filter the rows returned"""
    where: laundry_order_bool_exp
  ): laundry_order_aggregate!

  """fetch data from the table: "laundry.order" using primary key columns"""
  laundry_order_by_pk(id: Int!): laundry_order

  """
  fetch data from the table: "laundry.order_category"
  """
  laundry_order_category(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): [laundry_order_category!]!

  """
  fetch aggregated fields from the table: "laundry.order_category"
  """
  laundry_order_category_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_order_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_order_category_order_by!]

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): laundry_order_category_aggregate!

  """
  fetch data from the table: "laundry.order_category" using primary key columns
  """
  laundry_order_category_by_pk(id: Int!): laundry_order_category

  """
  fetch data from the table in a streaming manner: "laundry.order_category"
  """
  laundry_order_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [laundry_order_category_stream_cursor_input]!

    """filter the rows returned"""
    where: laundry_order_category_bool_exp
  ): [laundry_order_category!]!

  """
  fetch data from the table in a streaming manner: "laundry.order"
  """
  laundry_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [laundry_order_stream_cursor_input]!

    """filter the rows returned"""
    where: laundry_order_bool_exp
  ): [laundry_order!]!

  """
  fetch data from the table: "laundry.store"
  """
  laundry_store(
    """distinct select on columns"""
    distinct_on: [laundry_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_store_order_by!]

    """filter the rows returned"""
    where: laundry_store_bool_exp
  ): [laundry_store!]!

  """
  fetch aggregated fields from the table: "laundry.store"
  """
  laundry_store_aggregate(
    """distinct select on columns"""
    distinct_on: [laundry_store_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laundry_store_order_by!]

    """filter the rows returned"""
    where: laundry_store_bool_exp
  ): laundry_store_aggregate!

  """fetch data from the table: "laundry.store" using primary key columns"""
  laundry_store_by_pk(id: Int!): laundry_store

  """
  fetch data from the table in a streaming manner: "laundry.store"
  """
  laundry_store_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [laundry_store_stream_cursor_input]!

    """filter the rows returned"""
    where: laundry_store_bool_exp
  ): [laundry_store!]!

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table: "mez_admin_chat"
  """
  mez_admin_chat(
    """distinct select on columns"""
    distinct_on: [mez_admin_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_chat_order_by!]

    """filter the rows returned"""
    where: mez_admin_chat_bool_exp
  ): [mez_admin_chat!]!

  """
  fetch aggregated fields from the table: "mez_admin_chat"
  """
  mez_admin_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_chat_order_by!]

    """filter the rows returned"""
    where: mez_admin_chat_bool_exp
  ): mez_admin_chat_aggregate!

  """fetch data from the table: "mez_admin_chat" using primary key columns"""
  mez_admin_chat_by_pk(chat_id: Int!): mez_admin_chat

  """
  fetch data from the table in a streaming manner: "mez_admin_chat"
  """
  mez_admin_chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mez_admin_chat_stream_cursor_input]!

    """filter the rows returned"""
    where: mez_admin_chat_bool_exp
  ): [mez_admin_chat!]!

  """
  fetch data from the table in a streaming manner: "mez_admin"
  """
  mez_admin_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mez_admin_stream_cursor_input]!

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch data from the table: "mez_json"
  """
  mez_json(
    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): [mez_json!]!

  """
  fetch aggregated fields from the table: "mez_json"
  """
  mez_json_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """fetch data from the table: "mez_json" using primary key columns"""
  mez_json_by_pk(json_object: jsonb!): mez_json

  """
  fetch data from the table in a streaming manner: "mez_json"
  """
  mez_json_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mez_json_stream_cursor_input]!

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): [mez_json!]!

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table in a streaming manner: "notification_info"
  """
  notification_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_info_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch data from the table: "restaurant.cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant.cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant.cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant.cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant.cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant.cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table in a streaming manner: "restaurant.cart_item"
  """
  restaurant_cart_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch data from the table in a streaming manner: "restaurant.cart"
  """
  restaurant_cart_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch data from the table: "restaurant.category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant.category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant.category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table in a streaming manner: "restaurant.category"
  """
  restaurant_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_category_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch data from the table: "restaurant.choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant.choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant.choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  fetch data from the table in a streaming manner: "restaurant.choice"
  """
  restaurant_choice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_choice_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  execute function "restaurant.get_restaurants" which returns "restaurant.restaurant"
  """
  restaurant_get_restaurants(
    """
    input parameters for function "restaurant_get_restaurants"
    """
    args: restaurant_get_restaurants_args!

    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """
  execute function "restaurant.get_restaurants" and query aggregates on result of table type "restaurant.restaurant"
  """
  restaurant_get_restaurants_aggregate(
    """
    input parameters for function "restaurant_get_restaurants_aggregate"
    """
    args: restaurant_get_restaurants_args!

    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): restaurant_restaurant_aggregate!

  """
  fetch data from the table: "restaurant.item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant.item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant.item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant.item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant.item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant.item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  fetch data from the table in a streaming manner: "restaurant.item_option_map"
  """
  restaurant_item_option_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_option_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch data from the table in a streaming manner: "restaurant.item"
  """
  restaurant_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch data from the table: "restaurant.operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant.operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant.operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table in a streaming manner: "restaurant.operator"
  """
  restaurant_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch data from the table: "restaurant.option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant.option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant.option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant.option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant.option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant.option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  fetch data from the table in a streaming manner: "restaurant.option_choice_map"
  """
  restaurant_option_choice_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_choice_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch data from the table in a streaming manner: "restaurant.option"
  """
  restaurant_option_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch data from the table: "restaurant.order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant.order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant.order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant.order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant.order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant.order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table in a streaming manner: "restaurant.order_item"
  """
  restaurant_order_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch data from the table: "restaurant.order_public"
  """
  restaurant_order_public(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch aggregated fields from the table: "restaurant.order_public"
  """
  restaurant_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): restaurant_order_public_aggregate!

  """
  fetch data from the table in a streaming manner: "restaurant.order_public"
  """
  restaurant_order_public_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_public_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch data from the table in a streaming manner: "restaurant.order"
  """
  restaurant_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  execute function "restaurant.orders_by_date" which returns "mez_json"
  """
  restaurant_orders_by_date(
    """
    input parameters for function "restaurant_orders_by_date"
    """
    args: restaurant_orders_by_date_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json

  """
  execute function "restaurant.orders_by_date" and query aggregates on result of table type "mez_json"
  """
  restaurant_orders_by_date_aggregate(
    """
    input parameters for function "restaurant_orders_by_date_aggregate"
    """
    args: restaurant_orders_by_date_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """
  execute function "restaurant.orders_by_month" which returns "mez_json"
  """
  restaurant_orders_by_month(
    """
    input parameters for function "restaurant_orders_by_month"
    """
    args: restaurant_orders_by_month_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json

  """
  execute function "restaurant.orders_by_month" and query aggregates on result of table type "mez_json"
  """
  restaurant_orders_by_month_aggregate(
    """
    input parameters for function "restaurant_orders_by_month_aggregate"
    """
    args: restaurant_orders_by_month_args!

    """distinct select on columns"""
    distinct_on: [mez_json_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_json_order_by!]

    """filter the rows returned"""
    where: mez_json_bool_exp
  ): mez_json_aggregate!

  """
  fetch data from the table: "restaurant.restaurant"
  """
  restaurant_restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant.restaurant"
  """
  restaurant_restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): restaurant_restaurant_aggregate!

  """
  fetch data from the table: "restaurant.restaurant" using primary key columns
  """
  restaurant_restaurant_by_pk(id: Int!): restaurant_restaurant

  """
  fetch data from the table in a streaming manner: "restaurant.restaurant"
  """
  restaurant_restaurant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_restaurant_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_restaurant_bool_exp
  ): [restaurant_restaurant!]!

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table in a streaming manner: "review"
  """
  review_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [review_stream_cursor_input]!

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch data from the table: "service_provider_customer_chat"
  """
  service_provider_customer_chat(
    """distinct select on columns"""
    distinct_on: [service_provider_customer_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_customer_chat_order_by!]

    """filter the rows returned"""
    where: service_provider_customer_chat_bool_exp
  ): [service_provider_customer_chat!]!

  """
  fetch aggregated fields from the table: "service_provider_customer_chat"
  """
  service_provider_customer_chat_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_customer_chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_customer_chat_order_by!]

    """filter the rows returned"""
    where: service_provider_customer_chat_bool_exp
  ): service_provider_customer_chat_aggregate!

  """
  fetch data from the table: "service_provider_customer_chat" using primary key columns
  """
  service_provider_customer_chat_by_pk(chat_id: Int!): service_provider_customer_chat

  """
  fetch data from the table in a streaming manner: "service_provider_customer_chat"
  """
  service_provider_customer_chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_customer_chat_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_customer_chat_bool_exp
  ): [service_provider_customer_chat!]!

  """
  fetch data from the table: "service_provider.delivery_partner"
  """
  service_provider_delivery_partner(
    """distinct select on columns"""
    distinct_on: [service_provider_delivery_partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_delivery_partner_order_by!]

    """filter the rows returned"""
    where: service_provider_delivery_partner_bool_exp
  ): [service_provider_delivery_partner!]!

  """
  fetch aggregated fields from the table: "service_provider.delivery_partner"
  """
  service_provider_delivery_partner_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_delivery_partner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_delivery_partner_order_by!]

    """filter the rows returned"""
    where: service_provider_delivery_partner_bool_exp
  ): service_provider_delivery_partner_aggregate!

  """
  fetch data from the table: "service_provider.delivery_partner" using primary key columns
  """
  service_provider_delivery_partner_by_pk(id: Int!): service_provider_delivery_partner

  """
  fetch data from the table in a streaming manner: "service_provider.delivery_partner"
  """
  service_provider_delivery_partner_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_delivery_partner_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_delivery_partner_bool_exp
  ): [service_provider_delivery_partner!]!

  """
  fetch data from the table: "service_provider.location"
  """
  service_provider_location(
    """distinct select on columns"""
    distinct_on: [service_provider_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_location_order_by!]

    """filter the rows returned"""
    where: service_provider_location_bool_exp
  ): [service_provider_location!]!

  """
  fetch aggregated fields from the table: "service_provider.location"
  """
  service_provider_location_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_location_order_by!]

    """filter the rows returned"""
    where: service_provider_location_bool_exp
  ): service_provider_location_aggregate!

  """
  fetch data from the table: "service_provider.location" using primary key columns
  """
  service_provider_location_by_pk(id: Int!): service_provider_location

  """
  fetch data from the table in a streaming manner: "service_provider.location"
  """
  service_provider_location_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_location_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_location_bool_exp
  ): [service_provider_location!]!

  """
  fetch data from the table: "service_provider.post"
  """
  service_provider_post(
    """distinct select on columns"""
    distinct_on: [service_provider_post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_post_order_by!]

    """filter the rows returned"""
    where: service_provider_post_bool_exp
  ): [service_provider_post!]!

  """
  fetch aggregated fields from the table: "service_provider.post"
  """
  service_provider_post_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_post_order_by!]

    """filter the rows returned"""
    where: service_provider_post_bool_exp
  ): service_provider_post_aggregate!

  """
  fetch data from the table: "service_provider.post" using primary key columns
  """
  service_provider_post_by_pk(id: Int!): service_provider_post

  """
  fetch data from the table in a streaming manner: "service_provider.post"
  """
  service_provider_post_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_post_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_post_bool_exp
  ): [service_provider_post!]!

  """
  fetch data from the table: "service_provider.service_link"
  """
  service_provider_service_link(
    """distinct select on columns"""
    distinct_on: [service_provider_service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_service_link_order_by!]

    """filter the rows returned"""
    where: service_provider_service_link_bool_exp
  ): [service_provider_service_link!]!

  """
  fetch aggregated fields from the table: "service_provider.service_link"
  """
  service_provider_service_link_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_service_link_order_by!]

    """filter the rows returned"""
    where: service_provider_service_link_bool_exp
  ): service_provider_service_link_aggregate!

  """
  fetch data from the table: "service_provider.service_link" using primary key columns
  """
  service_provider_service_link_by_pk(id: Int!): service_provider_service_link

  """
  fetch data from the table in a streaming manner: "service_provider.service_link"
  """
  service_provider_service_link_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_service_link_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_service_link_bool_exp
  ): [service_provider_service_link!]!

  """
  fetch data from the table: "service_provider.subscriber"
  """
  service_provider_subscriber(
    """distinct select on columns"""
    distinct_on: [service_provider_subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_subscriber_order_by!]

    """filter the rows returned"""
    where: service_provider_subscriber_bool_exp
  ): [service_provider_subscriber!]!

  """
  fetch aggregated fields from the table: "service_provider.subscriber"
  """
  service_provider_subscriber_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_subscriber_order_by!]

    """filter the rows returned"""
    where: service_provider_subscriber_bool_exp
  ): service_provider_subscriber_aggregate!

  """
  fetch data from the table: "service_provider.subscriber" using primary key columns
  """
  service_provider_subscriber_by_pk(id: Int!): service_provider_subscriber

  """
  fetch data from the table in a streaming manner: "service_provider.subscriber"
  """
  service_provider_subscriber_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_subscriber_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_subscriber_bool_exp
  ): [service_provider_subscriber!]!

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table in a streaming manner: "translation"
  """
  translation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table in a streaming manner: "translation_value"
  """
  translation_value_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_value_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "translation"
"""
type translation {
  """An object relationship"""
  delivery_company: delivery_company
  id: Int!

  """An object relationship"""
  laundry: laundry_store

  """An object relationship"""
  restaurant: restaurant_restaurant
  service_provider_id: Int!
  service_provider_type: String!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!
}

"""
aggregated selection of "translation"
"""
type translation_aggregate {
  aggregate: translation_aggregate_fields
  nodes: [translation!]!
}

"""
aggregate fields of "translation"
"""
type translation_aggregate_fields {
  avg: translation_avg_fields
  count(columns: [translation_select_column!], distinct: Boolean): Int!
  max: translation_max_fields
  min: translation_min_fields
  stddev: translation_stddev_fields
  stddev_pop: translation_stddev_pop_fields
  stddev_samp: translation_stddev_samp_fields
  sum: translation_sum_fields
  var_pop: translation_var_pop_fields
  var_samp: translation_var_samp_fields
  variance: translation_variance_fields
}

"""aggregate avg on columns"""
type translation_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "translation". All fields are combined with a logical 'AND'.
"""
input translation_bool_exp {
  _and: [translation_bool_exp!]
  _not: translation_bool_exp
  _or: [translation_bool_exp!]
  delivery_company: delivery_company_bool_exp
  id: Int_comparison_exp
  laundry: laundry_store_bool_exp
  restaurant: restaurant_restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  translations: translation_value_bool_exp
  translations_aggregate: translation_value_aggregate_bool_exp
}

"""
unique or primary key constraints on table "translation"
"""
enum translation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translation_pkey
}

"""
input type for incrementing numeric columns in table "translation"
"""
input translation_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "translation"
"""
input translation_insert_input {
  delivery_company: delivery_company_obj_rel_insert_input
  id: Int
  laundry: laundry_store_obj_rel_insert_input
  restaurant: restaurant_restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
  translations: translation_value_arr_rel_insert_input
}

"""aggregate max on columns"""
type translation_max_fields {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type translation_min_fields {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "translation"
"""
type translation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation!]!
}

"""
input type for inserting object relation for remote table "translation"
"""
input translation_obj_rel_insert_input {
  data: translation_insert_input!

  """upsert condition"""
  on_conflict: translation_on_conflict
}

"""
on_conflict condition type for table "translation"
"""
input translation_on_conflict {
  constraint: translation_constraint!
  update_columns: [translation_update_column!]! = []
  where: translation_bool_exp
}

"""Ordering options when selecting data from "translation"."""
input translation_order_by {
  delivery_company: delivery_company_order_by
  id: order_by
  laundry: laundry_store_order_by
  restaurant: restaurant_restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
  translations_aggregate: translation_value_aggregate_order_by
}

"""primary key columns input for table: translation"""
input translation_pk_columns_input {
  id: Int!
}

"""
select columns of table "translation"
"""
enum translation_select_column {
  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "translation"
"""
input translation_set_input {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type translation_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type translation_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type translation_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "translation"
"""
input translation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_stream_cursor_value_input {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type translation_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "translation"
"""
enum translation_update_column {
  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input translation_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_set_input

  """filter the rows which have to be updated"""
  where: translation_bool_exp!
}

"""
columns and relationships of "translation_value"
"""
type translation_value {
  """An object relationship"""
  language: language!
  language_id: String!

  """An object relationship"""
  translation_group: translation!
  translation_id: Int!
  value: String!
}

"""
aggregated selection of "translation_value"
"""
type translation_value_aggregate {
  aggregate: translation_value_aggregate_fields
  nodes: [translation_value!]!
}

input translation_value_aggregate_bool_exp {
  count: translation_value_aggregate_bool_exp_count
}

input translation_value_aggregate_bool_exp_count {
  arguments: [translation_value_select_column!]
  distinct: Boolean
  filter: translation_value_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "translation_value"
"""
type translation_value_aggregate_fields {
  avg: translation_value_avg_fields
  count(columns: [translation_value_select_column!], distinct: Boolean): Int!
  max: translation_value_max_fields
  min: translation_value_min_fields
  stddev: translation_value_stddev_fields
  stddev_pop: translation_value_stddev_pop_fields
  stddev_samp: translation_value_stddev_samp_fields
  sum: translation_value_sum_fields
  var_pop: translation_value_var_pop_fields
  var_samp: translation_value_var_samp_fields
  variance: translation_value_variance_fields
}

"""
order by aggregate values of table "translation_value"
"""
input translation_value_aggregate_order_by {
  avg: translation_value_avg_order_by
  count: order_by
  max: translation_value_max_order_by
  min: translation_value_min_order_by
  stddev: translation_value_stddev_order_by
  stddev_pop: translation_value_stddev_pop_order_by
  stddev_samp: translation_value_stddev_samp_order_by
  sum: translation_value_sum_order_by
  var_pop: translation_value_var_pop_order_by
  var_samp: translation_value_var_samp_order_by
  variance: translation_value_variance_order_by
}

"""
input type for inserting array relation for remote table "translation_value"
"""
input translation_value_arr_rel_insert_input {
  data: [translation_value_insert_input!]!

  """upsert condition"""
  on_conflict: translation_value_on_conflict
}

"""aggregate avg on columns"""
type translation_value_avg_fields {
  translation_id: Float
}

"""
order by avg() on columns of table "translation_value"
"""
input translation_value_avg_order_by {
  translation_id: order_by
}

"""
Boolean expression to filter rows from the table "translation_value". All fields are combined with a logical 'AND'.
"""
input translation_value_bool_exp {
  _and: [translation_value_bool_exp!]
  _not: translation_value_bool_exp
  _or: [translation_value_bool_exp!]
  language: language_bool_exp
  language_id: String_comparison_exp
  translation_group: translation_bool_exp
  translation_id: Int_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "translation_value"
"""
enum translation_value_constraint {
  """
  unique or primary key constraint on columns "translation_id", "language_id"
  """
  translation_value_pkey
}

"""
input type for incrementing numeric columns in table "translation_value"
"""
input translation_value_inc_input {
  translation_id: Int
}

"""
input type for inserting data into table "translation_value"
"""
input translation_value_insert_input {
  language: language_obj_rel_insert_input
  language_id: String
  translation_group: translation_obj_rel_insert_input
  translation_id: Int
  value: String
}

"""aggregate max on columns"""
type translation_value_max_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by max() on columns of table "translation_value"
"""
input translation_value_max_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type translation_value_min_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by min() on columns of table "translation_value"
"""
input translation_value_min_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""
response of any mutation on the table "translation_value"
"""
type translation_value_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation_value!]!
}

"""
on_conflict condition type for table "translation_value"
"""
input translation_value_on_conflict {
  constraint: translation_value_constraint!
  update_columns: [translation_value_update_column!]! = []
  where: translation_value_bool_exp
}

"""Ordering options when selecting data from "translation_value"."""
input translation_value_order_by {
  language: language_order_by
  language_id: order_by
  translation_group: translation_order_by
  translation_id: order_by
  value: order_by
}

"""primary key columns input for table: translation_value"""
input translation_value_pk_columns_input {
  language_id: String!
  translation_id: Int!
}

"""
select columns of table "translation_value"
"""
enum translation_value_select_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

"""
input type for updating data in table "translation_value"
"""
input translation_value_set_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate stddev on columns"""
type translation_value_stddev_fields {
  translation_id: Float
}

"""
order by stddev() on columns of table "translation_value"
"""
input translation_value_stddev_order_by {
  translation_id: order_by
}

"""aggregate stddev_pop on columns"""
type translation_value_stddev_pop_fields {
  translation_id: Float
}

"""
order by stddev_pop() on columns of table "translation_value"
"""
input translation_value_stddev_pop_order_by {
  translation_id: order_by
}

"""aggregate stddev_samp on columns"""
type translation_value_stddev_samp_fields {
  translation_id: Float
}

"""
order by stddev_samp() on columns of table "translation_value"
"""
input translation_value_stddev_samp_order_by {
  translation_id: order_by
}

"""
Streaming cursor of the table "translation_value"
"""
input translation_value_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_value_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_value_stream_cursor_value_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate sum on columns"""
type translation_value_sum_fields {
  translation_id: Int
}

"""
order by sum() on columns of table "translation_value"
"""
input translation_value_sum_order_by {
  translation_id: order_by
}

"""
update columns of table "translation_value"
"""
enum translation_value_update_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

input translation_value_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_value_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_value_set_input

  """filter the rows which have to be updated"""
  where: translation_value_bool_exp!
}

"""aggregate var_pop on columns"""
type translation_value_var_pop_fields {
  translation_id: Float
}

"""
order by var_pop() on columns of table "translation_value"
"""
input translation_value_var_pop_order_by {
  translation_id: order_by
}

"""aggregate var_samp on columns"""
type translation_value_var_samp_fields {
  translation_id: Float
}

"""
order by var_samp() on columns of table "translation_value"
"""
input translation_value_var_samp_order_by {
  translation_id: order_by
}

"""aggregate variance on columns"""
type translation_value_variance_fields {
  translation_id: Float
}

"""
order by variance() on columns of table "translation_value"
"""
input translation_value_variance_order_by {
  translation_id: order_by
}

"""aggregate var_pop on columns"""
type translation_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type translation_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type translation_variance_fields {
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "user"
"""
type user {
  big_image: String
  creation_time: timestamptz!

  """An object relationship"""
  customer: customer_customer
  deleted: Boolean!
  email: String
  firebase_id: String!
  id: Int!
  image: String
  language_id: String!
  name: String
  phone: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""aggregate avg on columns"""
type user_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  big_image: String_comparison_exp
  creation_time: timestamptz_comparison_exp
  customer: customer_customer_bool_exp
  deleted: Boolean_comparison_exp
  email: String_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for incrementing numeric columns in table "user"
"""
input user_inc_input {
  id: Int
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  big_image: String
  creation_time: timestamptz
  customer: customer_customer_obj_rel_insert_input
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate max on columns"""
type user_max_fields {
  big_image: String
  creation_time: timestamptz
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate min on columns"""
type user_min_fields {
  big_image: String
  creation_time: timestamptz
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  big_image: order_by
  creation_time: order_by
  customer: customer_customer_order_by
  deleted: order_by
  email: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  name: order_by
  phone: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: Int!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  big_image

  """column name"""
  creation_time

  """column name"""
  deleted

  """column name"""
  email

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name

  """column name"""
  phone
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  big_image: String
  creation_time: timestamptz
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate stddev on columns"""
type user_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type user_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type user_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  big_image: String
  creation_time: timestamptz
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate sum on columns"""
type user_sum_fields {
  id: Int
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  big_image

  """column name"""
  creation_time

  """column name"""
  deleted

  """column name"""
  email

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name

  """column name"""
  phone
}

input user_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

"""aggregate var_pop on columns"""
type user_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type user_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type user_variance_fields {
  id: Float
}
