schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "chat"
"""
type chat {
  agora_info(
    """JSON select path"""
    path: String
  ): jsonb
  chat_info(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  chat_participants(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """An aggregate relationship"""
  chat_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!
  creation_time: timestamptz!
  id: Int!
  messages(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "chat"
"""
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

"""
aggregate fields of "chat"
"""
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int!
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input chat_append_input {
  agora_info: jsonb
  chat_info: jsonb
  messages: jsonb
}

"""aggregate avg on columns"""
type chat_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
"""
input chat_bool_exp {
  _and: [chat_bool_exp!]
  _not: chat_bool_exp
  _or: [chat_bool_exp!]
  agora_info: jsonb_comparison_exp
  chat_info: jsonb_comparison_exp
  chat_participants: chat_participant_bool_exp
  chat_participants_aggregate: chat_participant_aggregate_bool_exp
  creation_time: timestamptz_comparison_exp
  id: Int_comparison_exp
  messages: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "chat"
"""
enum chat_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input chat_delete_at_path_input {
  agora_info: [String!]
  chat_info: [String!]
  messages: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input chat_delete_elem_input {
  agora_info: Int
  chat_info: Int
  messages: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input chat_delete_key_input {
  agora_info: String
  chat_info: String
  messages: String
}

"""
input type for incrementing numeric columns in table "chat"
"""
input chat_inc_input {
  id: Int
}

"""
input type for inserting data into table "chat"
"""
input chat_insert_input {
  agora_info: jsonb
  chat_info: jsonb
  chat_participants: chat_participant_arr_rel_insert_input
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate max on columns"""
type chat_max_fields {
  creation_time: timestamptz
  id: Int
}

"""aggregate min on columns"""
type chat_min_fields {
  creation_time: timestamptz
  id: Int
}

"""
response of any mutation on the table "chat"
"""
type chat_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat!]!
}

"""
input type for inserting object relation for remote table "chat"
"""
input chat_obj_rel_insert_input {
  data: chat_insert_input!

  """upsert condition"""
  on_conflict: chat_on_conflict
}

"""
on_conflict condition type for table "chat"
"""
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]! = []
  where: chat_bool_exp
}

"""Ordering options when selecting data from "chat"."""
input chat_order_by {
  agora_info: order_by
  chat_info: order_by
  chat_participants_aggregate: chat_participant_aggregate_order_by
  creation_time: order_by
  id: order_by
  messages: order_by
}

"""
columns and relationships of "chat_participant"
"""
type chat_participant {
  app_type_id: String!

  """An object relationship"""
  chat: chat!
  chat_id: Int!
  id: Int!

  """An object relationship"""
  notification_info: notification_info
  participant_id: Int!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "chat_participant"
"""
type chat_participant_aggregate {
  aggregate: chat_participant_aggregate_fields
  nodes: [chat_participant!]!
}

input chat_participant_aggregate_bool_exp {
  count: chat_participant_aggregate_bool_exp_count
}

input chat_participant_aggregate_bool_exp_count {
  arguments: [chat_participant_select_column!]
  distinct: Boolean
  filter: chat_participant_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "chat_participant"
"""
type chat_participant_aggregate_fields {
  avg: chat_participant_avg_fields
  count(columns: [chat_participant_select_column!], distinct: Boolean): Int!
  max: chat_participant_max_fields
  min: chat_participant_min_fields
  stddev: chat_participant_stddev_fields
  stddev_pop: chat_participant_stddev_pop_fields
  stddev_samp: chat_participant_stddev_samp_fields
  sum: chat_participant_sum_fields
  var_pop: chat_participant_var_pop_fields
  var_samp: chat_participant_var_samp_fields
  variance: chat_participant_variance_fields
}

"""
order by aggregate values of table "chat_participant"
"""
input chat_participant_aggregate_order_by {
  avg: chat_participant_avg_order_by
  count: order_by
  max: chat_participant_max_order_by
  min: chat_participant_min_order_by
  stddev: chat_participant_stddev_order_by
  stddev_pop: chat_participant_stddev_pop_order_by
  stddev_samp: chat_participant_stddev_samp_order_by
  sum: chat_participant_sum_order_by
  var_pop: chat_participant_var_pop_order_by
  var_samp: chat_participant_var_samp_order_by
  variance: chat_participant_variance_order_by
}

"""
input type for inserting array relation for remote table "chat_participant"
"""
input chat_participant_arr_rel_insert_input {
  data: [chat_participant_insert_input!]!

  """upsert condition"""
  on_conflict: chat_participant_on_conflict
}

"""aggregate avg on columns"""
type chat_participant_avg_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by avg() on columns of table "chat_participant"
"""
input chat_participant_avg_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
Boolean expression to filter rows from the table "chat_participant". All fields are combined with a logical 'AND'.
"""
input chat_participant_bool_exp {
  _and: [chat_participant_bool_exp!]
  _not: chat_participant_bool_exp
  _or: [chat_participant_bool_exp!]
  app_type_id: String_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  id: Int_comparison_exp
  notification_info: notification_info_bool_exp
  participant_id: Int_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "chat_participant"
"""
enum chat_participant_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_participants_pkey
}

"""
input type for incrementing numeric columns in table "chat_participant"
"""
input chat_participant_inc_input {
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
input type for inserting data into table "chat_participant"
"""
input chat_participant_insert_input {
  app_type_id: String
  chat: chat_obj_rel_insert_input
  chat_id: Int
  id: Int
  notification_info: notification_info_obj_rel_insert_input
  participant_id: Int
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type chat_participant_max_fields {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by max() on columns of table "chat_participant"
"""
input chat_participant_max_order_by {
  app_type_id: order_by
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate min on columns"""
type chat_participant_min_fields {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by min() on columns of table "chat_participant"
"""
input chat_participant_min_order_by {
  app_type_id: order_by
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
response of any mutation on the table "chat_participant"
"""
type chat_participant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat_participant!]!
}

"""
on_conflict condition type for table "chat_participant"
"""
input chat_participant_on_conflict {
  constraint: chat_participant_constraint!
  update_columns: [chat_participant_update_column!]! = []
  where: chat_participant_bool_exp
}

"""Ordering options when selecting data from "chat_participant"."""
input chat_participant_order_by {
  app_type_id: order_by
  chat: chat_order_by
  chat_id: order_by
  id: order_by
  notification_info: notification_info_order_by
  participant_id: order_by
  user: user_order_by
}

"""primary key columns input for table: chat_participant"""
input chat_participant_pk_columns_input {
  id: Int!
}

"""
select columns of table "chat_participant"
"""
enum chat_participant_select_column {
  """column name"""
  app_type_id

  """column name"""
  chat_id

  """column name"""
  id

  """column name"""
  participant_id
}

"""
input type for updating data in table "chat_participant"
"""
input chat_participant_set_input {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""aggregate stddev on columns"""
type chat_participant_stddev_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev() on columns of table "chat_participant"
"""
input chat_participant_stddev_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate stddev_pop on columns"""
type chat_participant_stddev_pop_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev_pop() on columns of table "chat_participant"
"""
input chat_participant_stddev_pop_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate stddev_samp on columns"""
type chat_participant_stddev_samp_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by stddev_samp() on columns of table "chat_participant"
"""
input chat_participant_stddev_samp_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
Streaming cursor of the table "chat_participant"
"""
input chat_participant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_participant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_participant_stream_cursor_value_input {
  app_type_id: String
  chat_id: Int
  id: Int
  participant_id: Int
}

"""aggregate sum on columns"""
type chat_participant_sum_fields {
  chat_id: Int
  id: Int
  participant_id: Int
}

"""
order by sum() on columns of table "chat_participant"
"""
input chat_participant_sum_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""
update columns of table "chat_participant"
"""
enum chat_participant_update_column {
  """column name"""
  app_type_id

  """column name"""
  chat_id

  """column name"""
  id

  """column name"""
  participant_id
}

input chat_participant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_participant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_participant_set_input
  where: chat_participant_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_participant_var_pop_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by var_pop() on columns of table "chat_participant"
"""
input chat_participant_var_pop_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate var_samp on columns"""
type chat_participant_var_samp_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by var_samp() on columns of table "chat_participant"
"""
input chat_participant_var_samp_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""aggregate variance on columns"""
type chat_participant_variance_fields {
  chat_id: Float
  id: Float
  participant_id: Float
}

"""
order by variance() on columns of table "chat_participant"
"""
input chat_participant_variance_order_by {
  chat_id: order_by
  id: order_by
  participant_id: order_by
}

"""primary key columns input for table: chat"""
input chat_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input chat_prepend_input {
  agora_info: jsonb
  chat_info: jsonb
  messages: jsonb
}

"""
select columns of table "chat"
"""
enum chat_select_column {
  """column name"""
  agora_info

  """column name"""
  chat_info

  """column name"""
  creation_time

  """column name"""
  id

  """column name"""
  messages
}

"""
input type for updating data in table "chat"
"""
input chat_set_input {
  agora_info: jsonb
  chat_info: jsonb
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate stddev on columns"""
type chat_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type chat_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type chat_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "chat"
"""
input chat_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_stream_cursor_value_input {
  agora_info: jsonb
  chat_info: jsonb
  creation_time: timestamptz
  id: Int
  messages: jsonb
}

"""aggregate sum on columns"""
type chat_sum_fields {
  id: Int
}

"""
update columns of table "chat"
"""
enum chat_update_column {
  """column name"""
  agora_info

  """column name"""
  chat_info

  """column name"""
  creation_time

  """column name"""
  id

  """column name"""
  messages
}

input chat_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: chat_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: chat_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: chat_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: chat_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: chat_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_set_input
  where: chat_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type chat_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type chat_variance_fields {
  id: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "customer"
"""
type customer {
  app_version: String

  """An object relationship"""
  cart: restaurant_cart

  """An array relationship"""
  deliveries(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """An aggregate relationship"""
  deliveries_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """
  A computed field, executes function "customer_notification_token"
  """
  notification_token: String

  """An array relationship"""
  saved_locations(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): [saved_location!]!

  """An aggregate relationship"""
  saved_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): saved_location_aggregate!
  service_provider_type: String
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "customer"
"""
type customer_aggregate {
  aggregate: customer_aggregate_fields
  nodes: [customer!]!
}

"""
aggregate fields of "customer"
"""
type customer_aggregate_fields {
  avg: customer_avg_fields
  count(columns: [customer_select_column!], distinct: Boolean): Int!
  max: customer_max_fields
  min: customer_min_fields
  stddev: customer_stddev_fields
  stddev_pop: customer_stddev_pop_fields
  stddev_samp: customer_stddev_samp_fields
  sum: customer_sum_fields
  var_pop: customer_var_pop_fields
  var_samp: customer_var_samp_fields
  variance: customer_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input customer_append_input {
  stripe_info: jsonb
}

"""aggregate avg on columns"""
type customer_avg_fields {
  user_id: Float
}

"""
Boolean expression to filter rows from the table "customer". All fields are combined with a logical 'AND'.
"""
input customer_bool_exp {
  _and: [customer_bool_exp!]
  _not: customer_bool_exp
  _or: [customer_bool_exp!]
  app_version: String_comparison_exp
  cart: restaurant_cart_bool_exp
  deliveries: delivery_order_bool_exp
  deliveries_aggregate: delivery_order_aggregate_bool_exp
  notification_token: String_comparison_exp
  saved_locations: saved_location_bool_exp
  saved_locations_aggregate: saved_location_aggregate_bool_exp
  service_provider_type: String_comparison_exp
  stripe_info: jsonb_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "customer"
"""
enum customer_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  customer_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  customer_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input customer_delete_at_path_input {
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input customer_delete_elem_input {
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input customer_delete_key_input {
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "customer"
"""
input customer_inc_input {
  user_id: Int
}

"""
input type for inserting data into table "customer"
"""
input customer_insert_input {
  app_version: String
  cart: restaurant_cart_obj_rel_insert_input
  deliveries: delivery_order_arr_rel_insert_input
  saved_locations: saved_location_arr_rel_insert_input
  service_provider_type: String
  stripe_info: jsonb
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type customer_max_fields {
  app_version: String
  service_provider_type: String
  user_id: Int
}

"""aggregate min on columns"""
type customer_min_fields {
  app_version: String
  service_provider_type: String
  user_id: Int
}

"""
response of any mutation on the table "customer"
"""
type customer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer!]!
}

"""
input type for inserting object relation for remote table "customer"
"""
input customer_obj_rel_insert_input {
  data: customer_insert_input!

  """upsert condition"""
  on_conflict: customer_on_conflict
}

"""
on_conflict condition type for table "customer"
"""
input customer_on_conflict {
  constraint: customer_constraint!
  update_columns: [customer_update_column!]! = []
  where: customer_bool_exp
}

"""Ordering options when selecting data from "customer"."""
input customer_order_by {
  app_version: order_by
  cart: restaurant_cart_order_by
  deliveries_aggregate: delivery_order_aggregate_order_by
  notification_token: order_by
  saved_locations_aggregate: saved_location_aggregate_order_by
  service_provider_type: order_by
  stripe_info: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: customer"""
input customer_pk_columns_input {
  user_id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input customer_prepend_input {
  stripe_info: jsonb
}

"""
select columns of table "customer"
"""
enum customer_select_column {
  """column name"""
  app_version

  """column name"""
  service_provider_type

  """column name"""
  stripe_info

  """column name"""
  user_id
}

"""
input type for updating data in table "customer"
"""
input customer_set_input {
  app_version: String
  service_provider_type: String
  stripe_info: jsonb
  user_id: Int
}

"""aggregate stddev on columns"""
type customer_stddev_fields {
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type customer_stddev_pop_fields {
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type customer_stddev_samp_fields {
  user_id: Float
}

"""
Streaming cursor of the table "customer"
"""
input customer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customer_stream_cursor_value_input {
  app_version: String
  service_provider_type: String
  stripe_info: jsonb
  user_id: Int
}

"""aggregate sum on columns"""
type customer_sum_fields {
  user_id: Int
}

"""
update columns of table "customer"
"""
enum customer_update_column {
  """column name"""
  app_version

  """column name"""
  service_provider_type

  """column name"""
  stripe_info

  """column name"""
  user_id
}

input customer_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: customer_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: customer_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: customer_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: customer_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: customer_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: customer_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: customer_set_input
  where: customer_bool_exp!
}

"""aggregate var_pop on columns"""
type customer_var_pop_fields {
  user_id: Float
}

"""aggregate var_samp on columns"""
type customer_var_samp_fields {
  user_id: Float
}

"""aggregate variance on columns"""
type customer_variance_fields {
  user_id: Float
}

"""
columns and relationships of "delivery_company"
"""
type delivery_company {
  approved: Boolean!

  """An array relationship"""
  delivery_drivers(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """An aggregate relationship"""
  delivery_drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """An array relationship"""
  delivery_operators(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """An aggregate relationship"""
  delivery_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!
  image: String!
  name: String!
  open_status: String!
  service_provider_type: String!
}

"""
aggregated selection of "delivery_company"
"""
type delivery_company_aggregate {
  aggregate: delivery_company_aggregate_fields
  nodes: [delivery_company!]!
}

"""
aggregate fields of "delivery_company"
"""
type delivery_company_aggregate_fields {
  avg: delivery_company_avg_fields
  count(columns: [delivery_company_select_column!], distinct: Boolean): Int!
  max: delivery_company_max_fields
  min: delivery_company_min_fields
  stddev: delivery_company_stddev_fields
  stddev_pop: delivery_company_stddev_pop_fields
  stddev_samp: delivery_company_stddev_samp_fields
  sum: delivery_company_sum_fields
  var_pop: delivery_company_var_pop_fields
  var_samp: delivery_company_var_samp_fields
  variance: delivery_company_variance_fields
}

"""aggregate avg on columns"""
type delivery_company_avg_fields {
  description_id: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "delivery_company". All fields are combined with a logical 'AND'.
"""
input delivery_company_bool_exp {
  _and: [delivery_company_bool_exp!]
  _not: delivery_company_bool_exp
  _or: [delivery_company_bool_exp!]
  approved: Boolean_comparison_exp
  delivery_drivers: delivery_driver_bool_exp
  delivery_drivers_aggregate: delivery_driver_aggregate_bool_exp
  delivery_operators: delivery_operator_bool_exp
  delivery_operators_aggregate: delivery_operator_aggregate_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  name: String_comparison_exp
  open_status: String_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery_company"
"""
enum delivery_company_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_company_pkey
}

"""
input type for incrementing numeric columns in table "delivery_company"
"""
input delivery_company_inc_input {
  description_id: Int
  id: Int
}

"""
input type for inserting data into table "delivery_company"
"""
input delivery_company_insert_input {
  approved: Boolean
  delivery_drivers: delivery_driver_arr_rel_insert_input
  delivery_operators: delivery_operator_arr_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  image: String
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate max on columns"""
type delivery_company_max_fields {
  description_id: Int
  id: Int
  image: String
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate min on columns"""
type delivery_company_min_fields {
  description_id: Int
  id: Int
  image: String
  name: String
  open_status: String
  service_provider_type: String
}

"""
response of any mutation on the table "delivery_company"
"""
type delivery_company_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_company!]!
}

"""
input type for inserting object relation for remote table "delivery_company"
"""
input delivery_company_obj_rel_insert_input {
  data: delivery_company_insert_input!

  """upsert condition"""
  on_conflict: delivery_company_on_conflict
}

"""
on_conflict condition type for table "delivery_company"
"""
input delivery_company_on_conflict {
  constraint: delivery_company_constraint!
  update_columns: [delivery_company_update_column!]! = []
  where: delivery_company_bool_exp
}

"""Ordering options when selecting data from "delivery_company"."""
input delivery_company_order_by {
  approved: order_by
  delivery_drivers_aggregate: delivery_driver_aggregate_order_by
  delivery_operators_aggregate: delivery_operator_aggregate_order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  image: order_by
  name: order_by
  open_status: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: delivery_company"""
input delivery_company_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery_company"
"""
enum delivery_company_select_column {
  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "delivery_company"
"""
input delivery_company_set_input {
  approved: Boolean
  description_id: Int
  id: Int
  image: String
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate stddev on columns"""
type delivery_company_stddev_fields {
  description_id: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type delivery_company_stddev_pop_fields {
  description_id: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type delivery_company_stddev_samp_fields {
  description_id: Float
  id: Float
}

"""
Streaming cursor of the table "delivery_company"
"""
input delivery_company_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_company_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_company_stream_cursor_value_input {
  approved: Boolean
  description_id: Int
  id: Int
  image: String
  name: String
  open_status: String
  service_provider_type: String
}

"""aggregate sum on columns"""
type delivery_company_sum_fields {
  description_id: Int
  id: Int
}

"""
update columns of table "delivery_company"
"""
enum delivery_company_update_column {
  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  service_provider_type
}

input delivery_company_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_company_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_company_set_input
  where: delivery_company_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_company_var_pop_fields {
  description_id: Float
  id: Float
}

"""aggregate var_samp on columns"""
type delivery_company_var_samp_fields {
  description_id: Float
  id: Float
}

"""aggregate variance on columns"""
type delivery_company_variance_fields {
  description_id: Float
  id: Float
}

"""
columns and relationships of "delivery_cost"
"""
type delivery_cost {
  cost_per_km: money!
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int!
  minimum_cost: money!

  """An object relationship"""
  restaurant: restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "delivery_cost"
"""
type delivery_cost_aggregate {
  aggregate: delivery_cost_aggregate_fields
  nodes: [delivery_cost!]!
}

"""
aggregate fields of "delivery_cost"
"""
type delivery_cost_aggregate_fields {
  avg: delivery_cost_avg_fields
  count(columns: [delivery_cost_select_column!], distinct: Boolean): Int!
  max: delivery_cost_max_fields
  min: delivery_cost_min_fields
  stddev: delivery_cost_stddev_fields
  stddev_pop: delivery_cost_stddev_pop_fields
  stddev_samp: delivery_cost_stddev_samp_fields
  sum: delivery_cost_sum_fields
  var_pop: delivery_cost_var_pop_fields
  var_samp: delivery_cost_var_samp_fields
  variance: delivery_cost_variance_fields
}

"""aggregate avg on columns"""
type delivery_cost_avg_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "delivery_cost". All fields are combined with a logical 'AND'.
"""
input delivery_cost_bool_exp {
  _and: [delivery_cost_bool_exp!]
  _not: delivery_cost_bool_exp
  _or: [delivery_cost_bool_exp!]
  cost_per_km: money_comparison_exp
  free_delivery_km_range: Float_comparison_exp
  free_delivery_minimum_cost: money_comparison_exp
  id: Int_comparison_exp
  minimum_cost: money_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery_cost"
"""
enum delivery_cost_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_cost_pkey

  """
  unique or primary key constraint on columns "service_provider_type", "service_provider_id"
  """
  delivery_cost_service_provider_id_service_provider_type_key
}

"""
input type for incrementing numeric columns in table "delivery_cost"
"""
input delivery_cost_inc_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
}

"""
input type for inserting data into table "delivery_cost"
"""
input delivery_cost_insert_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  restaurant: restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type delivery_cost_max_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type delivery_cost_min_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "delivery_cost"
"""
type delivery_cost_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_cost!]!
}

"""
on_conflict condition type for table "delivery_cost"
"""
input delivery_cost_on_conflict {
  constraint: delivery_cost_constraint!
  update_columns: [delivery_cost_update_column!]! = []
  where: delivery_cost_bool_exp
}

"""Ordering options when selecting data from "delivery_cost"."""
input delivery_cost_order_by {
  cost_per_km: order_by
  free_delivery_km_range: order_by
  free_delivery_minimum_cost: order_by
  id: order_by
  minimum_cost: order_by
  restaurant: restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: delivery_cost"""
input delivery_cost_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery_cost"
"""
enum delivery_cost_select_column {
  """column name"""
  cost_per_km

  """column name"""
  free_delivery_km_range

  """column name"""
  free_delivery_minimum_cost

  """column name"""
  id

  """column name"""
  minimum_cost

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "delivery_cost"
"""
input delivery_cost_set_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type delivery_cost_stddev_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type delivery_cost_stddev_pop_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type delivery_cost_stddev_samp_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "delivery_cost"
"""
input delivery_cost_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_cost_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_cost_stream_cursor_value_input {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type delivery_cost_sum_fields {
  cost_per_km: money
  free_delivery_km_range: Float
  free_delivery_minimum_cost: money
  id: Int
  minimum_cost: money
  service_provider_id: Int
}

"""
update columns of table "delivery_cost"
"""
enum delivery_cost_update_column {
  """column name"""
  cost_per_km

  """column name"""
  free_delivery_km_range

  """column name"""
  free_delivery_minimum_cost

  """column name"""
  id

  """column name"""
  minimum_cost

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input delivery_cost_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_cost_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_cost_set_input
  where: delivery_cost_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_cost_var_pop_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type delivery_cost_var_samp_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type delivery_cost_variance_fields {
  cost_per_km: Float
  free_delivery_km_range: Float
  free_delivery_minimum_cost: Float
  id: Float
  minimum_cost: Float
  service_provider_id: Float
}

"""
columns and relationships of "delivery_driver"
"""
type delivery_driver {
  app_version: String
  current_location: geography

  """An object relationship"""
  delivery_company: delivery_company
  delivery_company_id: Int!

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String!

  """Just for relationship"""
  delivery_driver_type: String!
  id: Int!
  notification_info_id: Int

  """
  A computed field, executes function "driver_notification_token"
  """
  notification_token: String
  online: Boolean!

  """An object relationship"""
  restaurant: restaurant

  """awaiting_approval, authorized, banned"""
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "delivery_driver"
"""
type delivery_driver_aggregate {
  aggregate: delivery_driver_aggregate_fields
  nodes: [delivery_driver!]!
}

input delivery_driver_aggregate_bool_exp {
  bool_and: delivery_driver_aggregate_bool_exp_bool_and
  bool_or: delivery_driver_aggregate_bool_exp_bool_or
  count: delivery_driver_aggregate_bool_exp_count
}

input delivery_driver_aggregate_bool_exp_bool_and {
  arguments: delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_driver_aggregate_bool_exp_bool_or {
  arguments: delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_driver_aggregate_bool_exp_count {
  arguments: [delivery_driver_select_column!]
  distinct: Boolean
  filter: delivery_driver_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery_driver"
"""
type delivery_driver_aggregate_fields {
  avg: delivery_driver_avg_fields
  count(columns: [delivery_driver_select_column!], distinct: Boolean): Int!
  max: delivery_driver_max_fields
  min: delivery_driver_min_fields
  stddev: delivery_driver_stddev_fields
  stddev_pop: delivery_driver_stddev_pop_fields
  stddev_samp: delivery_driver_stddev_samp_fields
  sum: delivery_driver_sum_fields
  var_pop: delivery_driver_var_pop_fields
  var_samp: delivery_driver_var_samp_fields
  variance: delivery_driver_variance_fields
}

"""
order by aggregate values of table "delivery_driver"
"""
input delivery_driver_aggregate_order_by {
  avg: delivery_driver_avg_order_by
  count: order_by
  max: delivery_driver_max_order_by
  min: delivery_driver_min_order_by
  stddev: delivery_driver_stddev_order_by
  stddev_pop: delivery_driver_stddev_pop_order_by
  stddev_samp: delivery_driver_stddev_samp_order_by
  sum: delivery_driver_sum_order_by
  var_pop: delivery_driver_var_pop_order_by
  var_samp: delivery_driver_var_samp_order_by
  variance: delivery_driver_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery_driver"
"""
input delivery_driver_arr_rel_insert_input {
  data: [delivery_driver_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_driver_on_conflict
}

"""aggregate avg on columns"""
type delivery_driver_avg_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "delivery_driver"
"""
input delivery_driver_avg_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "delivery_driver". All fields are combined with a logical 'AND'.
"""
input delivery_driver_bool_exp {
  _and: [delivery_driver_bool_exp!]
  _not: delivery_driver_bool_exp
  _or: [delivery_driver_bool_exp!]
  app_version: String_comparison_exp
  current_location: geography_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_company_id: Int_comparison_exp
  delivery_company_type: String_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_info_id: Int_comparison_exp
  notification_token: String_comparison_exp
  online: Boolean_comparison_exp
  restaurant: restaurant_bool_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "delivery_driver"
"""
enum delivery_driver_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  delivery_driver_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  driver_pkey
}

"""
input type for incrementing numeric columns in table "delivery_driver"
"""
input delivery_driver_inc_input {
  delivery_company_id: Int
  id: Int
  notification_info_id: Int
  user_id: Int
}

"""
input type for inserting data into table "delivery_driver"
"""
input delivery_driver_insert_input {
  app_version: String
  current_location: geography
  delivery_company: delivery_company_obj_rel_insert_input
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  notification_info_id: Int
  online: Boolean
  restaurant: restaurant_obj_rel_insert_input

  """awaiting_approval, authorized, banned"""
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type delivery_driver_max_fields {
  app_version: String
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  notification_info_id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""
order by max() on columns of table "delivery_driver"
"""
input delivery_driver_max_order_by {
  app_version: order_by
  delivery_company_id: order_by

  """restaurant,laundry,delivery_company"""
  delivery_company_type: order_by

  """Just for relationship"""
  delivery_driver_type: order_by
  id: order_by
  notification_info_id: order_by

  """awaiting_approval, authorized, banned"""
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type delivery_driver_min_fields {
  app_version: String
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  notification_info_id: Int

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""
order by min() on columns of table "delivery_driver"
"""
input delivery_driver_min_order_by {
  app_version: order_by
  delivery_company_id: order_by

  """restaurant,laundry,delivery_company"""
  delivery_company_type: order_by

  """Just for relationship"""
  delivery_driver_type: order_by
  id: order_by
  notification_info_id: order_by

  """awaiting_approval, authorized, banned"""
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "delivery_driver"
"""
type delivery_driver_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_driver!]!
}

"""
input type for inserting object relation for remote table "delivery_driver"
"""
input delivery_driver_obj_rel_insert_input {
  data: delivery_driver_insert_input!

  """upsert condition"""
  on_conflict: delivery_driver_on_conflict
}

"""
on_conflict condition type for table "delivery_driver"
"""
input delivery_driver_on_conflict {
  constraint: delivery_driver_constraint!
  update_columns: [delivery_driver_update_column!]! = []
  where: delivery_driver_bool_exp
}

"""Ordering options when selecting data from "delivery_driver"."""
input delivery_driver_order_by {
  app_version: order_by
  current_location: order_by
  delivery_company: delivery_company_order_by
  delivery_company_id: order_by
  delivery_company_type: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_info_id: order_by
  notification_token: order_by
  online: order_by
  restaurant: restaurant_order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: delivery_driver"""
input delivery_driver_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery_driver"
"""
enum delivery_driver_select_column {
  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  notification_info_id

  """column name"""
  online

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "delivery_driver_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery_driver"
"""
enum delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  online
}

"""
select "delivery_driver_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery_driver"
"""
enum delivery_driver_select_column_delivery_driver_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  online
}

"""
input type for updating data in table "delivery_driver"
"""
input delivery_driver_set_input {
  app_version: String
  current_location: geography
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  notification_info_id: Int
  online: Boolean

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type delivery_driver_stddev_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "delivery_driver"
"""
input delivery_driver_stddev_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_driver_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "delivery_driver"
"""
input delivery_driver_stddev_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_driver_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "delivery_driver"
"""
input delivery_driver_stddev_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "delivery_driver"
"""
input delivery_driver_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_driver_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_driver_stream_cursor_value_input {
  app_version: String
  current_location: geography
  delivery_company_id: Int

  """restaurant,laundry,delivery_company"""
  delivery_company_type: String

  """Just for relationship"""
  delivery_driver_type: String
  id: Int
  notification_info_id: Int
  online: Boolean

  """awaiting_approval, authorized, banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type delivery_driver_sum_fields {
  delivery_company_id: Int
  id: Int
  notification_info_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "delivery_driver"
"""
input delivery_driver_sum_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""
update columns of table "delivery_driver"
"""
enum delivery_driver_update_column {
  """column name"""
  app_version

  """column name"""
  current_location

  """column name"""
  delivery_company_id

  """column name"""
  delivery_company_type

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  notification_info_id

  """column name"""
  online

  """column name"""
  status

  """column name"""
  user_id
}

input delivery_driver_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_driver_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_driver_set_input
  where: delivery_driver_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_driver_var_pop_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "delivery_driver"
"""
input delivery_driver_var_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type delivery_driver_var_samp_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "delivery_driver"
"""
input delivery_driver_var_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type delivery_driver_variance_fields {
  delivery_company_id: Float
  id: Float
  notification_info_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "delivery_driver"
"""
input delivery_driver_variance_order_by {
  delivery_company_id: order_by
  id: order_by
  notification_info_id: order_by
  user_id: order_by
}

"""
columns and relationships of "delivery_operator"
"""
type delivery_operator {
  app_version: String
  current_gps: geography
  delivery_company_id: Int!
  delivery_driver_type: String!
  id: Int!

  """
  A computed field, executes function "deliop_notification_token"
  """
  notification_token: String
  owner: Boolean!
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "delivery_operator"
"""
type delivery_operator_aggregate {
  aggregate: delivery_operator_aggregate_fields
  nodes: [delivery_operator!]!
}

input delivery_operator_aggregate_bool_exp {
  bool_and: delivery_operator_aggregate_bool_exp_bool_and
  bool_or: delivery_operator_aggregate_bool_exp_bool_or
  count: delivery_operator_aggregate_bool_exp_count
}

input delivery_operator_aggregate_bool_exp_bool_and {
  arguments: delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_operator_aggregate_bool_exp_bool_or {
  arguments: delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input delivery_operator_aggregate_bool_exp_count {
  arguments: [delivery_operator_select_column!]
  distinct: Boolean
  filter: delivery_operator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery_operator"
"""
type delivery_operator_aggregate_fields {
  avg: delivery_operator_avg_fields
  count(columns: [delivery_operator_select_column!], distinct: Boolean): Int!
  max: delivery_operator_max_fields
  min: delivery_operator_min_fields
  stddev: delivery_operator_stddev_fields
  stddev_pop: delivery_operator_stddev_pop_fields
  stddev_samp: delivery_operator_stddev_samp_fields
  sum: delivery_operator_sum_fields
  var_pop: delivery_operator_var_pop_fields
  var_samp: delivery_operator_var_samp_fields
  variance: delivery_operator_variance_fields
}

"""
order by aggregate values of table "delivery_operator"
"""
input delivery_operator_aggregate_order_by {
  avg: delivery_operator_avg_order_by
  count: order_by
  max: delivery_operator_max_order_by
  min: delivery_operator_min_order_by
  stddev: delivery_operator_stddev_order_by
  stddev_pop: delivery_operator_stddev_pop_order_by
  stddev_samp: delivery_operator_stddev_samp_order_by
  sum: delivery_operator_sum_order_by
  var_pop: delivery_operator_var_pop_order_by
  var_samp: delivery_operator_var_samp_order_by
  variance: delivery_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery_operator"
"""
input delivery_operator_arr_rel_insert_input {
  data: [delivery_operator_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_operator_on_conflict
}

"""aggregate avg on columns"""
type delivery_operator_avg_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "delivery_operator"
"""
input delivery_operator_avg_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "delivery_operator". All fields are combined with a logical 'AND'.
"""
input delivery_operator_bool_exp {
  _and: [delivery_operator_bool_exp!]
  _not: delivery_operator_bool_exp
  _or: [delivery_operator_bool_exp!]
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  delivery_company_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_token: String_comparison_exp
  owner: Boolean_comparison_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "delivery_operator"
"""
enum delivery_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_operator_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  delivery_operator_user_id_key
}

"""
input type for incrementing numeric columns in table "delivery_operator"
"""
input delivery_operator_inc_input {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "delivery_operator"
"""
input delivery_operator_insert_input {
  app_version: String
  current_gps: geography
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  owner: Boolean
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type delivery_operator_max_fields {
  app_version: String
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  status: String
  user_id: Int
}

"""
order by max() on columns of table "delivery_operator"
"""
input delivery_operator_max_order_by {
  app_version: order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type delivery_operator_min_fields {
  app_version: String
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  status: String
  user_id: Int
}

"""
order by min() on columns of table "delivery_operator"
"""
input delivery_operator_min_order_by {
  app_version: order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "delivery_operator"
"""
type delivery_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_operator!]!
}

"""
input type for inserting object relation for remote table "delivery_operator"
"""
input delivery_operator_obj_rel_insert_input {
  data: delivery_operator_insert_input!

  """upsert condition"""
  on_conflict: delivery_operator_on_conflict
}

"""
on_conflict condition type for table "delivery_operator"
"""
input delivery_operator_on_conflict {
  constraint: delivery_operator_constraint!
  update_columns: [delivery_operator_update_column!]! = []
  where: delivery_operator_bool_exp
}

"""Ordering options when selecting data from "delivery_operator"."""
input delivery_operator_order_by {
  app_version: order_by
  current_gps: order_by
  delivery_company_id: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_token: order_by
  owner: order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: delivery_operator"""
input delivery_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "delivery_operator"
"""
enum delivery_operator_select_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_company_id

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "delivery_operator_aggregate_bool_exp_bool_and_arguments_columns" columns of table "delivery_operator"
"""
enum delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  owner
}

"""
select "delivery_operator_aggregate_bool_exp_bool_or_arguments_columns" columns of table "delivery_operator"
"""
enum delivery_operator_select_column_delivery_operator_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  owner
}

"""
input type for updating data in table "delivery_operator"
"""
input delivery_operator_set_input {
  app_version: String
  current_gps: geography
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  owner: Boolean
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type delivery_operator_stddev_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "delivery_operator"
"""
input delivery_operator_stddev_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_operator_stddev_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "delivery_operator"
"""
input delivery_operator_stddev_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_operator_stddev_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "delivery_operator"
"""
input delivery_operator_stddev_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "delivery_operator"
"""
input delivery_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_operator_stream_cursor_value_input {
  app_version: String
  current_gps: geography
  delivery_company_id: Int
  delivery_driver_type: String
  id: Int
  owner: Boolean
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type delivery_operator_sum_fields {
  delivery_company_id: Int
  id: Int
  user_id: Int
}

"""
order by sum() on columns of table "delivery_operator"
"""
input delivery_operator_sum_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
update columns of table "delivery_operator"
"""
enum delivery_operator_update_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_company_id

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  status

  """column name"""
  user_id
}

input delivery_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_operator_set_input
  where: delivery_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_operator_var_pop_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "delivery_operator"
"""
input delivery_operator_var_pop_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type delivery_operator_var_samp_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "delivery_operator"
"""
input delivery_operator_var_samp_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type delivery_operator_variance_fields {
  delivery_company_id: Float
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "delivery_operator"
"""
input delivery_operator_variance_order_by {
  delivery_company_id: order_by
  id: order_by
  user_id: order_by
}

"""
columns and relationships of "delivery_order"
"""
type delivery_order {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz

  """An object relationship"""
  chat_with_customer: chat!
  chat_with_customer_id: Int!

  """An object relationship"""
  chat_with_service_provider: chat
  chat_with_service_provider_id: Int
  current_gps: geography

  """An object relationship"""
  customer: customer!
  customer_id: Int!

  """An object relationship"""
  customer_review_by_driver: review
  customer_review_by_driver_id: Int

  """An object relationship"""
  delivery_company: delivery_company
  delivery_cost: money!

  """An object relationship"""
  delivery_driver: delivery_driver
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """An object relationship"""
  delivery_operator: delivery_operator

  """to_customer, from_customer"""
  direction: String!

  """An object relationship"""
  driver_review_by_customer: review
  driver_review_by_customer_id: Int

  """An object relationship"""
  driver_review_by_service_provider: review
  driver_review_by_service_provider_id: Int
  dropoff_address: String!
  dropoff_gps: geography!
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int!

  """
  A computed field, executes function "delivery_in_process"
  """
  in_process: Boolean

  """
  A computed field, executes function "delivery_notification_token"
  """
  notification_token: String
  order_time: timestamptz!
  order_type: String!
  package_cost: money!
  payment_type: String!
  pickup_address: String!
  pickup_gps: geography!

  """An object relationship"""
  restaurant: restaurant

  """An object relationship"""
  restaurant_operator: restaurant_operator

  """An object relationship"""
  restaurant_order: restaurant_order
  schedule_time: String
  service_provider_id: Int

  """An object relationship"""
  service_provider_review_by_driver: review
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String!
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
aggregated selection of "delivery_order"
"""
type delivery_order_aggregate {
  aggregate: delivery_order_aggregate_fields
  nodes: [delivery_order!]!
}

input delivery_order_aggregate_bool_exp {
  count: delivery_order_aggregate_bool_exp_count
}

input delivery_order_aggregate_bool_exp_count {
  arguments: [delivery_order_select_column!]
  distinct: Boolean
  filter: delivery_order_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delivery_order"
"""
type delivery_order_aggregate_fields {
  avg: delivery_order_avg_fields
  count(columns: [delivery_order_select_column!], distinct: Boolean): Int!
  max: delivery_order_max_fields
  min: delivery_order_min_fields
  stddev: delivery_order_stddev_fields
  stddev_pop: delivery_order_stddev_pop_fields
  stddev_samp: delivery_order_stddev_samp_fields
  sum: delivery_order_sum_fields
  var_pop: delivery_order_var_pop_fields
  var_samp: delivery_order_var_samp_fields
  variance: delivery_order_variance_fields
}

"""
order by aggregate values of table "delivery_order"
"""
input delivery_order_aggregate_order_by {
  avg: delivery_order_avg_order_by
  count: order_by
  max: delivery_order_max_order_by
  min: delivery_order_min_order_by
  stddev: delivery_order_stddev_order_by
  stddev_pop: delivery_order_stddev_pop_order_by
  stddev_samp: delivery_order_stddev_samp_order_by
  sum: delivery_order_sum_order_by
  var_pop: delivery_order_var_pop_order_by
  var_samp: delivery_order_var_samp_order_by
  variance: delivery_order_variance_order_by
}

"""
input type for inserting array relation for remote table "delivery_order"
"""
input delivery_order_arr_rel_insert_input {
  data: [delivery_order_insert_input!]!

  """upsert condition"""
  on_conflict: delivery_order_on_conflict
}

"""aggregate avg on columns"""
type delivery_order_avg_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by avg() on columns of table "delivery_order"
"""
input delivery_order_avg_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Boolean expression to filter rows from the table "delivery_order". All fields are combined with a logical 'AND'.
"""
input delivery_order_bool_exp {
  _and: [delivery_order_bool_exp!]
  _not: delivery_order_bool_exp
  _or: [delivery_order_bool_exp!]
  actual_arrival_at_dropoff_time: timestamptz_comparison_exp
  actual_arrival_at_pickup_time: timestamptz_comparison_exp
  actual_delivered_time: timestamptz_comparison_exp
  actual_package_ready_time: timestamptz_comparison_exp
  cancellation_time: timestamptz_comparison_exp
  chat_with_customer: chat_bool_exp
  chat_with_customer_id: Int_comparison_exp
  chat_with_service_provider: chat_bool_exp
  chat_with_service_provider_id: Int_comparison_exp
  current_gps: geography_comparison_exp
  customer: customer_bool_exp
  customer_id: Int_comparison_exp
  customer_review_by_driver: review_bool_exp
  customer_review_by_driver_id: Int_comparison_exp
  delivery_company: delivery_company_bool_exp
  delivery_cost: money_comparison_exp
  delivery_driver: delivery_driver_bool_exp
  delivery_driver_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  delivery_operator: delivery_operator_bool_exp
  direction: String_comparison_exp
  driver_review_by_customer: review_bool_exp
  driver_review_by_customer_id: Int_comparison_exp
  driver_review_by_service_provider: review_bool_exp
  driver_review_by_service_provider_id: Int_comparison_exp
  dropoff_address: String_comparison_exp
  dropoff_gps: geography_comparison_exp
  estimated_arrival_at_dropoff_time: timestamptz_comparison_exp
  estimated_arrival_at_pickup_time: timestamptz_comparison_exp
  estimated_package_ready_time: timestamptz_comparison_exp
  id: Int_comparison_exp
  in_process: Boolean_comparison_exp
  notification_token: String_comparison_exp
  order_time: timestamptz_comparison_exp
  order_type: String_comparison_exp
  package_cost: money_comparison_exp
  payment_type: String_comparison_exp
  pickup_address: String_comparison_exp
  pickup_gps: geography_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_operator: restaurant_operator_bool_exp
  restaurant_order: restaurant_order_bool_exp
  schedule_time: String_comparison_exp
  service_provider_id: Int_comparison_exp
  service_provider_review_by_driver: review_bool_exp
  service_provider_review_by_driver_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  status: String_comparison_exp
  stripe_payment_id: Int_comparison_exp
  trip_distance: Int_comparison_exp
  trip_duration: Int_comparison_exp
  trip_polyline: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery_order"
"""
enum delivery_order_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  delivery_pkey
}

"""
input type for incrementing numeric columns in table "delivery_order"
"""
input delivery_order_inc_input {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
input type for inserting data into table "delivery_order"
"""
input delivery_order_insert_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer: chat_obj_rel_insert_input
  chat_with_customer_id: Int
  chat_with_service_provider: chat_obj_rel_insert_input
  chat_with_service_provider_id: Int
  current_gps: geography
  customer: customer_obj_rel_insert_input
  customer_id: Int
  customer_review_by_driver: review_obj_rel_insert_input
  customer_review_by_driver_id: Int
  delivery_company: delivery_company_obj_rel_insert_input
  delivery_cost: money
  delivery_driver: delivery_driver_obj_rel_insert_input
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String
  delivery_operator: delivery_operator_obj_rel_insert_input

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer: review_obj_rel_insert_input
  driver_review_by_customer_id: Int
  driver_review_by_service_provider: review_obj_rel_insert_input
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  restaurant: restaurant_obj_rel_insert_input
  restaurant_operator: restaurant_operator_obj_rel_insert_input
  restaurant_order: restaurant_order_obj_rel_insert_input
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver: review_obj_rel_insert_input
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate max on columns"""
type delivery_order_max_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by max() on columns of table "delivery_order"
"""
input delivery_order_max_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: order_by

  """to_customer, from_customer"""
  direction: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """restaurant, delivery_company"""
  service_provider_type: order_by

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""aggregate min on columns"""
type delivery_order_min_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""
order by min() on columns of table "delivery_order"
"""
input delivery_order_min_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: order_by

  """to_customer, from_customer"""
  direction: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by

  """restaurant, delivery_company"""
  service_provider_type: order_by

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
  trip_polyline: order_by
}

"""
response of any mutation on the table "delivery_order"
"""
type delivery_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_order!]!
}

"""
input type for inserting object relation for remote table "delivery_order"
"""
input delivery_order_obj_rel_insert_input {
  data: delivery_order_insert_input!

  """upsert condition"""
  on_conflict: delivery_order_on_conflict
}

"""
on_conflict condition type for table "delivery_order"
"""
input delivery_order_on_conflict {
  constraint: delivery_order_constraint!
  update_columns: [delivery_order_update_column!]! = []
  where: delivery_order_bool_exp
}

"""Ordering options when selecting data from "delivery_order"."""
input delivery_order_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  cancellation_time: order_by
  chat_with_customer: chat_order_by
  chat_with_customer_id: order_by
  chat_with_service_provider: chat_order_by
  chat_with_service_provider_id: order_by
  current_gps: order_by
  customer: customer_order_by
  customer_id: order_by
  customer_review_by_driver: review_order_by
  customer_review_by_driver_id: order_by
  delivery_company: delivery_company_order_by
  delivery_cost: order_by
  delivery_driver: delivery_driver_order_by
  delivery_driver_id: order_by
  delivery_driver_type: order_by
  delivery_operator: delivery_operator_order_by
  direction: order_by
  driver_review_by_customer: review_order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider: review_order_by
  driver_review_by_service_provider_id: order_by
  dropoff_address: order_by
  dropoff_gps: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  id: order_by
  in_process: order_by
  notification_token: order_by
  order_time: order_by
  order_type: order_by
  package_cost: order_by
  payment_type: order_by
  pickup_address: order_by
  pickup_gps: order_by
  restaurant: restaurant_order_by
  restaurant_operator: restaurant_operator_order_by
  restaurant_order: restaurant_order_order_by
  schedule_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver: review_order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by
  status: order_by
  stripe_payment_id: order_by
  trip_distance: order_by
  trip_duration: order_by
  trip_polyline: order_by
}

"""primary key columns input for table: delivery_order"""
input delivery_order_pk_columns_input {
  id: Int!
}

"""
columns and relationships of "delivery_order_public"
"""
type delivery_order_public {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""
aggregated selection of "delivery_order_public"
"""
type delivery_order_public_aggregate {
  aggregate: delivery_order_public_aggregate_fields
  nodes: [delivery_order_public!]!
}

"""
aggregate fields of "delivery_order_public"
"""
type delivery_order_public_aggregate_fields {
  avg: delivery_order_public_avg_fields
  count(columns: [delivery_order_public_select_column!], distinct: Boolean): Int!
  max: delivery_order_public_max_fields
  min: delivery_order_public_min_fields
  stddev: delivery_order_public_stddev_fields
  stddev_pop: delivery_order_public_stddev_pop_fields
  stddev_samp: delivery_order_public_stddev_samp_fields
  sum: delivery_order_public_sum_fields
  var_pop: delivery_order_public_var_pop_fields
  var_samp: delivery_order_public_var_samp_fields
  variance: delivery_order_public_variance_fields
}

"""aggregate avg on columns"""
type delivery_order_public_avg_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
Boolean expression to filter rows from the table "delivery_order_public". All fields are combined with a logical 'AND'.
"""
input delivery_order_public_bool_exp {
  _and: [delivery_order_public_bool_exp!]
  _not: delivery_order_public_bool_exp
  _or: [delivery_order_public_bool_exp!]
  actual_arrival_at_dropoff_time: timestamptz_comparison_exp
  actual_arrival_at_pickup_time: timestamptz_comparison_exp
  actual_delivered_time: timestamptz_comparison_exp
  actual_package_ready_time: timestamptz_comparison_exp
  customer_id: Int_comparison_exp
  customer_review_by_driver_id: Int_comparison_exp
  delivery_driver_id: Int_comparison_exp
  delivery_driver_type: String_comparison_exp
  driver_review_by_customer_id: Int_comparison_exp
  driver_review_by_service_provider_id: Int_comparison_exp
  estimated_arrival_at_dropoff_time: timestamptz_comparison_exp
  estimated_arrival_at_pickup_time: timestamptz_comparison_exp
  estimated_package_ready_time: timestamptz_comparison_exp
  order_time: timestamptz_comparison_exp
  service_provider_id: Int_comparison_exp
  service_provider_review_by_driver_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  status: String_comparison_exp
  trip_distance: Int_comparison_exp
  trip_duration: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "delivery_order_public"
"""
input delivery_order_public_inc_input {
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  trip_distance: Int
  trip_duration: Int
}

"""
input type for inserting data into table "delivery_order_public"
"""
input delivery_order_public_insert_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate max on columns"""
type delivery_order_public_max_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate min on columns"""
type delivery_order_public_min_fields {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""
response of any mutation on the table "delivery_order_public"
"""
type delivery_order_public_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_order_public!]!
}

"""Ordering options when selecting data from "delivery_order_public"."""
input delivery_order_public_order_by {
  actual_arrival_at_dropoff_time: order_by
  actual_arrival_at_pickup_time: order_by
  actual_delivered_time: order_by
  actual_package_ready_time: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_driver_id: order_by
  delivery_driver_type: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  estimated_arrival_at_dropoff_time: order_by
  estimated_arrival_at_pickup_time: order_by
  estimated_package_ready_time: order_by
  order_time: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  service_provider_type: order_by
  status: order_by
  trip_distance: order_by
  trip_duration: order_by
}

"""
select columns of table "delivery_order_public"
"""
enum delivery_order_public_select_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  order_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  trip_distance

  """column name"""
  trip_duration
}

"""
input type for updating data in table "delivery_order_public"
"""
input delivery_order_public_set_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate stddev on columns"""
type delivery_order_public_stddev_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate stddev_pop on columns"""
type delivery_order_public_stddev_pop_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate stddev_samp on columns"""
type delivery_order_public_stddev_samp_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
Streaming cursor of the table "delivery_order_public"
"""
input delivery_order_public_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_order_public_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_order_public_stream_cursor_value_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  delivery_driver_type: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  order_time: timestamptz
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  service_provider_type: String
  status: String
  trip_distance: Int
  trip_duration: Int
}

"""aggregate sum on columns"""
type delivery_order_public_sum_fields {
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  trip_distance: Int
  trip_duration: Int
}

input delivery_order_public_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_order_public_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_order_public_set_input
  where: delivery_order_public_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_order_public_var_pop_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate var_samp on columns"""
type delivery_order_public_var_samp_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""aggregate variance on columns"""
type delivery_order_public_variance_fields {
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  trip_distance: Float
  trip_duration: Float
}

"""
select columns of table "delivery_order"
"""
enum delivery_order_select_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  direction

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  package_cost

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  schedule_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

"""
input type for updating data in table "delivery_order"
"""
input delivery_order_set_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate stddev on columns"""
type delivery_order_stddev_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev() on columns of table "delivery_order"
"""
input delivery_order_stddev_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_pop on columns"""
type delivery_order_stddev_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_pop() on columns of table "delivery_order"
"""
input delivery_order_stddev_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate stddev_samp on columns"""
type delivery_order_stddev_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by stddev_samp() on columns of table "delivery_order"
"""
input delivery_order_stddev_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Streaming cursor of the table "delivery_order"
"""
input delivery_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_order_stream_cursor_value_input {
  actual_arrival_at_dropoff_time: timestamptz
  actual_arrival_at_pickup_time: timestamptz
  actual_delivered_time: timestamptz
  actual_package_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  current_gps: geography
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int

  """restaurant_operator, delivery_driver, delivery_operator"""
  delivery_driver_type: String

  """to_customer, from_customer"""
  direction: String
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  dropoff_address: String
  dropoff_gps: geography
  estimated_arrival_at_dropoff_time: timestamptz
  estimated_arrival_at_pickup_time: timestamptz
  estimated_package_ready_time: timestamptz
  id: Int
  order_time: timestamptz
  order_type: String
  package_cost: money
  payment_type: String
  pickup_address: String
  pickup_gps: geography
  schedule_time: String
  service_provider_id: Int
  service_provider_review_by_driver_id: Int

  """restaurant, delivery_company"""
  service_provider_type: String

  """
  orderReceived, packageReady, atPickup, onTheWayToDropoff, atDropoff,
  delivered, cancelledByCustomer, cancelledByDeliverer,
  cancelledByServiceProvider
  """
  status: String
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
  trip_polyline: String
}

"""aggregate sum on columns"""
type delivery_order_sum_fields {
  chat_with_customer_id: Int
  chat_with_service_provider_id: Int
  customer_id: Int
  customer_review_by_driver_id: Int
  delivery_cost: money
  delivery_driver_id: Int
  driver_review_by_customer_id: Int
  driver_review_by_service_provider_id: Int
  id: Int
  package_cost: money
  service_provider_id: Int
  service_provider_review_by_driver_id: Int
  stripe_payment_id: Int

  """in meters"""
  trip_distance: Int

  """in seconds"""
  trip_duration: Int
}

"""
order by sum() on columns of table "delivery_order"
"""
input delivery_order_sum_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
update columns of table "delivery_order"
"""
enum delivery_order_update_column {
  """column name"""
  actual_arrival_at_dropoff_time

  """column name"""
  actual_arrival_at_pickup_time

  """column name"""
  actual_delivered_time

  """column name"""
  actual_package_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_with_customer_id

  """column name"""
  chat_with_service_provider_id

  """column name"""
  current_gps

  """column name"""
  customer_id

  """column name"""
  customer_review_by_driver_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_driver_id

  """column name"""
  delivery_driver_type

  """column name"""
  direction

  """column name"""
  driver_review_by_customer_id

  """column name"""
  driver_review_by_service_provider_id

  """column name"""
  dropoff_address

  """column name"""
  dropoff_gps

  """column name"""
  estimated_arrival_at_dropoff_time

  """column name"""
  estimated_arrival_at_pickup_time

  """column name"""
  estimated_package_ready_time

  """column name"""
  id

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  package_cost

  """column name"""
  payment_type

  """column name"""
  pickup_address

  """column name"""
  pickup_gps

  """column name"""
  schedule_time

  """column name"""
  service_provider_id

  """column name"""
  service_provider_review_by_driver_id

  """column name"""
  service_provider_type

  """column name"""
  status

  """column name"""
  stripe_payment_id

  """column name"""
  trip_distance

  """column name"""
  trip_duration

  """column name"""
  trip_polyline
}

input delivery_order_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delivery_order_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delivery_order_set_input
  where: delivery_order_bool_exp!
}

"""aggregate var_pop on columns"""
type delivery_order_var_pop_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_pop() on columns of table "delivery_order"
"""
input delivery_order_var_pop_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate var_samp on columns"""
type delivery_order_var_samp_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by var_samp() on columns of table "delivery_order"
"""
input delivery_order_var_samp_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""aggregate variance on columns"""
type delivery_order_variance_fields {
  chat_with_customer_id: Float
  chat_with_service_provider_id: Float
  customer_id: Float
  customer_review_by_driver_id: Float
  delivery_cost: Float
  delivery_driver_id: Float
  driver_review_by_customer_id: Float
  driver_review_by_service_provider_id: Float
  id: Float
  package_cost: Float
  service_provider_id: Float
  service_provider_review_by_driver_id: Float
  stripe_payment_id: Float

  """in meters"""
  trip_distance: Float

  """in seconds"""
  trip_duration: Float
}

"""
order by variance() on columns of table "delivery_order"
"""
input delivery_order_variance_order_by {
  chat_with_customer_id: order_by
  chat_with_service_provider_id: order_by
  customer_id: order_by
  customer_review_by_driver_id: order_by
  delivery_cost: order_by
  delivery_driver_id: order_by
  driver_review_by_customer_id: order_by
  driver_review_by_service_provider_id: order_by
  id: order_by
  package_cost: order_by
  service_provider_id: order_by
  service_provider_review_by_driver_id: order_by
  stripe_payment_id: order_by

  """in meters"""
  trip_distance: order_by

  """in seconds"""
  trip_duration: order_by
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "mez_admin"
"""
type mez_admin {
  """
  A computed field, executes function "mez_admin_notification_token"
  """
  notification_token: String

  """An object relationship"""
  user: user
  user_id: Int!
  version: String
}

"""
aggregated selection of "mez_admin"
"""
type mez_admin_aggregate {
  aggregate: mez_admin_aggregate_fields
  nodes: [mez_admin!]!
}

"""
aggregate fields of "mez_admin"
"""
type mez_admin_aggregate_fields {
  avg: mez_admin_avg_fields
  count(columns: [mez_admin_select_column!], distinct: Boolean): Int!
  max: mez_admin_max_fields
  min: mez_admin_min_fields
  stddev: mez_admin_stddev_fields
  stddev_pop: mez_admin_stddev_pop_fields
  stddev_samp: mez_admin_stddev_samp_fields
  sum: mez_admin_sum_fields
  var_pop: mez_admin_var_pop_fields
  var_samp: mez_admin_var_samp_fields
  variance: mez_admin_variance_fields
}

"""aggregate avg on columns"""
type mez_admin_avg_fields {
  user_id: Float
}

"""
Boolean expression to filter rows from the table "mez_admin". All fields are combined with a logical 'AND'.
"""
input mez_admin_bool_exp {
  _and: [mez_admin_bool_exp!]
  _not: mez_admin_bool_exp
  _or: [mez_admin_bool_exp!]
  notification_token: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "mez_admin"
"""
enum mez_admin_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  mez_admin_pkey
}

"""
input type for incrementing numeric columns in table "mez_admin"
"""
input mez_admin_inc_input {
  user_id: Int
}

"""
input type for inserting data into table "mez_admin"
"""
input mez_admin_insert_input {
  user: user_obj_rel_insert_input
  user_id: Int
  version: String
}

"""aggregate max on columns"""
type mez_admin_max_fields {
  user_id: Int
  version: String
}

"""aggregate min on columns"""
type mez_admin_min_fields {
  user_id: Int
  version: String
}

"""
response of any mutation on the table "mez_admin"
"""
type mez_admin_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mez_admin!]!
}

"""
on_conflict condition type for table "mez_admin"
"""
input mez_admin_on_conflict {
  constraint: mez_admin_constraint!
  update_columns: [mez_admin_update_column!]! = []
  where: mez_admin_bool_exp
}

"""Ordering options when selecting data from "mez_admin"."""
input mez_admin_order_by {
  notification_token: order_by
  user: user_order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: mez_admin"""
input mez_admin_pk_columns_input {
  user_id: Int!
}

"""
select columns of table "mez_admin"
"""
enum mez_admin_select_column {
  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "mez_admin"
"""
input mez_admin_set_input {
  user_id: Int
  version: String
}

"""aggregate stddev on columns"""
type mez_admin_stddev_fields {
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type mez_admin_stddev_pop_fields {
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type mez_admin_stddev_samp_fields {
  user_id: Float
}

"""
Streaming cursor of the table "mez_admin"
"""
input mez_admin_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mez_admin_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mez_admin_stream_cursor_value_input {
  user_id: Int
  version: String
}

"""aggregate sum on columns"""
type mez_admin_sum_fields {
  user_id: Int
}

"""
update columns of table "mez_admin"
"""
enum mez_admin_update_column {
  """column name"""
  user_id

  """column name"""
  version
}

input mez_admin_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mez_admin_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mez_admin_set_input
  where: mez_admin_bool_exp!
}

"""aggregate var_pop on columns"""
type mez_admin_var_pop_fields {
  user_id: Float
}

"""aggregate var_samp on columns"""
type mez_admin_var_samp_fields {
  user_id: Float
}

"""aggregate variance on columns"""
type mez_admin_variance_fields {
  user_id: Float
}

scalar money

"""
Boolean expression to compare columns of type "money". All fields are combined with logical 'AND'.
"""
input money_comparison_exp {
  _eq: money
  _gt: money
  _gte: money
  _in: [money!]
  _is_null: Boolean
  _lt: money
  _lte: money
  _neq: money
  _nin: [money!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "chat"
  """
  delete_chat(
    """filter the rows which have to be deleted"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  delete single row from the table: "chat"
  """
  delete_chat_by_pk(id: Int!): chat

  """
  delete data from the table: "chat_participant"
  """
  delete_chat_participant(
    """filter the rows which have to be deleted"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  delete single row from the table: "chat_participant"
  """
  delete_chat_participant_by_pk(id: Int!): chat_participant

  """
  delete data from the table: "customer"
  """
  delete_customer(
    """filter the rows which have to be deleted"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  delete single row from the table: "customer"
  """
  delete_customer_by_pk(user_id: Int!): customer

  """
  delete data from the table: "delivery_company"
  """
  delete_delivery_company(
    """filter the rows which have to be deleted"""
    where: delivery_company_bool_exp!
  ): delivery_company_mutation_response

  """
  delete single row from the table: "delivery_company"
  """
  delete_delivery_company_by_pk(id: Int!): delivery_company

  """
  delete data from the table: "delivery_cost"
  """
  delete_delivery_cost(
    """filter the rows which have to be deleted"""
    where: delivery_cost_bool_exp!
  ): delivery_cost_mutation_response

  """
  delete single row from the table: "delivery_cost"
  """
  delete_delivery_cost_by_pk(id: Int!): delivery_cost

  """
  delete data from the table: "delivery_driver"
  """
  delete_delivery_driver(
    """filter the rows which have to be deleted"""
    where: delivery_driver_bool_exp!
  ): delivery_driver_mutation_response

  """
  delete single row from the table: "delivery_driver"
  """
  delete_delivery_driver_by_pk(id: Int!): delivery_driver

  """
  delete data from the table: "delivery_operator"
  """
  delete_delivery_operator(
    """filter the rows which have to be deleted"""
    where: delivery_operator_bool_exp!
  ): delivery_operator_mutation_response

  """
  delete single row from the table: "delivery_operator"
  """
  delete_delivery_operator_by_pk(id: Int!): delivery_operator

  """
  delete data from the table: "delivery_order"
  """
  delete_delivery_order(
    """filter the rows which have to be deleted"""
    where: delivery_order_bool_exp!
  ): delivery_order_mutation_response

  """
  delete single row from the table: "delivery_order"
  """
  delete_delivery_order_by_pk(id: Int!): delivery_order

  """
  delete data from the table: "delivery_order_public"
  """
  delete_delivery_order_public(
    """filter the rows which have to be deleted"""
    where: delivery_order_public_bool_exp!
  ): delivery_order_public_mutation_response

  """
  delete data from the table: "mez_admin"
  """
  delete_mez_admin(
    """filter the rows which have to be deleted"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  delete single row from the table: "mez_admin"
  """
  delete_mez_admin_by_pk(user_id: Int!): mez_admin

  """
  delete data from the table: "notification_info"
  """
  delete_notification_info(
    """filter the rows which have to be deleted"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  delete single row from the table: "notification_info"
  """
  delete_notification_info_by_pk(id: Int!): notification_info

  """
  delete data from the table: "post"
  """
  delete_post(
    """filter the rows which have to be deleted"""
    where: post_bool_exp!
  ): post_mutation_response

  """
  delete single row from the table: "post"
  """
  delete_post_by_pk(id: Int!): post

  """
  delete data from the table: "restaurant"
  """
  delete_restaurant(
    """filter the rows which have to be deleted"""
    where: restaurant_bool_exp!
  ): restaurant_mutation_response

  """
  delete single row from the table: "restaurant"
  """
  delete_restaurant_by_pk(id: Int!): restaurant

  """
  delete data from the table: "restaurant_cart"
  """
  delete_restaurant_cart(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  delete single row from the table: "restaurant_cart"
  """
  delete_restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  delete data from the table: "restaurant_cart_item"
  """
  delete_restaurant_cart_item(
    """filter the rows which have to be deleted"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  delete single row from the table: "restaurant_cart_item"
  """
  delete_restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  delete data from the table: "restaurant_category"
  """
  delete_restaurant_category(
    """filter the rows which have to be deleted"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  delete single row from the table: "restaurant_category"
  """
  delete_restaurant_category_by_pk(id: Int!): restaurant_category

  """
  delete data from the table: "restaurant_choice"
  """
  delete_restaurant_choice(
    """filter the rows which have to be deleted"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  delete single row from the table: "restaurant_choice"
  """
  delete_restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  delete data from the table: "restaurant_item"
  """
  delete_restaurant_item(
    """filter the rows which have to be deleted"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  delete single row from the table: "restaurant_item"
  """
  delete_restaurant_item_by_pk(id: Int!): restaurant_item

  """
  delete data from the table: "restaurant_item_option_map"
  """
  delete_restaurant_item_option_map(
    """filter the rows which have to be deleted"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  delete single row from the table: "restaurant_item_option_map"
  """
  delete_restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  delete data from the table: "restaurant_operator"
  """
  delete_restaurant_operator(
    """filter the rows which have to be deleted"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  delete single row from the table: "restaurant_operator"
  """
  delete_restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  delete data from the table: "restaurant_option"
  """
  delete_restaurant_option(
    """filter the rows which have to be deleted"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  delete single row from the table: "restaurant_option"
  """
  delete_restaurant_option_by_pk(id: Int!): restaurant_option

  """
  delete data from the table: "restaurant_option_choice_map"
  """
  delete_restaurant_option_choice_map(
    """filter the rows which have to be deleted"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  delete single row from the table: "restaurant_option_choice_map"
  """
  delete_restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  delete data from the table: "restaurant_order"
  """
  delete_restaurant_order(
    """filter the rows which have to be deleted"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  delete single row from the table: "restaurant_order"
  """
  delete_restaurant_order_by_pk(id: Int!): restaurant_order

  """
  delete data from the table: "restaurant_order_item"
  """
  delete_restaurant_order_item(
    """filter the rows which have to be deleted"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  delete single row from the table: "restaurant_order_item"
  """
  delete_restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  delete data from the table: "restaurant_order_public"
  """
  delete_restaurant_order_public(
    """filter the rows which have to be deleted"""
    where: restaurant_order_public_bool_exp!
  ): restaurant_order_public_mutation_response

  """
  delete data from the table: "review"
  """
  delete_review(
    """filter the rows which have to be deleted"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  delete single row from the table: "review"
  """
  delete_review_by_pk(id: Int!): review

  """
  delete data from the table: "saved_location"
  """
  delete_saved_location(
    """filter the rows which have to be deleted"""
    where: saved_location_bool_exp!
  ): saved_location_mutation_response

  """
  delete single row from the table: "saved_location"
  """
  delete_saved_location_by_pk(id: Int!): saved_location

  """
  delete data from the table: "service_link"
  """
  delete_service_link(
    """filter the rows which have to be deleted"""
    where: service_link_bool_exp!
  ): service_link_mutation_response

  """
  delete single row from the table: "service_link"
  """
  delete_service_link_by_pk(id: Int!): service_link

  """
  delete data from the table: "service_provider_payment_info"
  """
  delete_service_provider_payment_info(
    """filter the rows which have to be deleted"""
    where: service_provider_payment_info_bool_exp!
  ): service_provider_payment_info_mutation_response

  """
  delete single row from the table: "service_provider_payment_info"
  """
  delete_service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  delete data from the table: "stripe_info"
  """
  delete_stripe_info(
    """filter the rows which have to be deleted"""
    where: stripe_info_bool_exp!
  ): stripe_info_mutation_response

  """
  delete single row from the table: "stripe_info"
  """
  delete_stripe_info_by_pk(id: Int!): stripe_info

  """
  delete data from the table: "subscriber"
  """
  delete_subscriber(
    """filter the rows which have to be deleted"""
    where: subscriber_bool_exp!
  ): subscriber_mutation_response

  """
  delete single row from the table: "subscriber"
  """
  delete_subscriber_by_pk(id: Int!): subscriber

  """
  delete data from the table: "topology.app_type"
  """
  delete_topology_app_type(
    """filter the rows which have to be deleted"""
    where: topology_app_type_bool_exp!
  ): topology_app_type_mutation_response

  """
  delete single row from the table: "topology.app_type"
  """
  delete_topology_app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): topology_app_type

  """
  delete data from the table: "topology.language"
  """
  delete_topology_language(
    """filter the rows which have to be deleted"""
    where: topology_language_bool_exp!
  ): topology_language_mutation_response

  """
  delete single row from the table: "topology.language"
  """
  delete_topology_language_by_pk(id: String!): topology_language

  """
  delete data from the table: "translation"
  """
  delete_translation(
    """filter the rows which have to be deleted"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  delete single row from the table: "translation"
  """
  delete_translation_by_pk(id: Int!): translation

  """
  delete data from the table: "translation_value"
  """
  delete_translation_value(
    """filter the rows which have to be deleted"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  delete single row from the table: "translation_value"
  """
  delete_translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: Int!): user

  """
  insert data into the table: "chat"
  """
  insert_chat(
    """the rows to be inserted"""
    objects: [chat_insert_input!]!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  """
  insert a single row into the table: "chat"
  """
  insert_chat_one(
    """the row to be inserted"""
    object: chat_insert_input!

    """upsert condition"""
    on_conflict: chat_on_conflict
  ): chat

  """
  insert data into the table: "chat_participant"
  """
  insert_chat_participant(
    """the rows to be inserted"""
    objects: [chat_participant_insert_input!]!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant_mutation_response

  """
  insert a single row into the table: "chat_participant"
  """
  insert_chat_participant_one(
    """the row to be inserted"""
    object: chat_participant_insert_input!

    """upsert condition"""
    on_conflict: chat_participant_on_conflict
  ): chat_participant

  """
  insert data into the table: "customer"
  """
  insert_customer(
    """the rows to be inserted"""
    objects: [customer_insert_input!]!

    """upsert condition"""
    on_conflict: customer_on_conflict
  ): customer_mutation_response

  """
  insert a single row into the table: "customer"
  """
  insert_customer_one(
    """the row to be inserted"""
    object: customer_insert_input!

    """upsert condition"""
    on_conflict: customer_on_conflict
  ): customer

  """
  insert data into the table: "delivery_company"
  """
  insert_delivery_company(
    """the rows to be inserted"""
    objects: [delivery_company_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_company_on_conflict
  ): delivery_company_mutation_response

  """
  insert a single row into the table: "delivery_company"
  """
  insert_delivery_company_one(
    """the row to be inserted"""
    object: delivery_company_insert_input!

    """upsert condition"""
    on_conflict: delivery_company_on_conflict
  ): delivery_company

  """
  insert data into the table: "delivery_cost"
  """
  insert_delivery_cost(
    """the rows to be inserted"""
    objects: [delivery_cost_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_cost_on_conflict
  ): delivery_cost_mutation_response

  """
  insert a single row into the table: "delivery_cost"
  """
  insert_delivery_cost_one(
    """the row to be inserted"""
    object: delivery_cost_insert_input!

    """upsert condition"""
    on_conflict: delivery_cost_on_conflict
  ): delivery_cost

  """
  insert data into the table: "delivery_driver"
  """
  insert_delivery_driver(
    """the rows to be inserted"""
    objects: [delivery_driver_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_driver_on_conflict
  ): delivery_driver_mutation_response

  """
  insert a single row into the table: "delivery_driver"
  """
  insert_delivery_driver_one(
    """the row to be inserted"""
    object: delivery_driver_insert_input!

    """upsert condition"""
    on_conflict: delivery_driver_on_conflict
  ): delivery_driver

  """
  insert data into the table: "delivery_operator"
  """
  insert_delivery_operator(
    """the rows to be inserted"""
    objects: [delivery_operator_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_operator_on_conflict
  ): delivery_operator_mutation_response

  """
  insert a single row into the table: "delivery_operator"
  """
  insert_delivery_operator_one(
    """the row to be inserted"""
    object: delivery_operator_insert_input!

    """upsert condition"""
    on_conflict: delivery_operator_on_conflict
  ): delivery_operator

  """
  insert data into the table: "delivery_order"
  """
  insert_delivery_order(
    """the rows to be inserted"""
    objects: [delivery_order_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_order_on_conflict
  ): delivery_order_mutation_response

  """
  insert a single row into the table: "delivery_order"
  """
  insert_delivery_order_one(
    """the row to be inserted"""
    object: delivery_order_insert_input!

    """upsert condition"""
    on_conflict: delivery_order_on_conflict
  ): delivery_order

  """
  insert data into the table: "delivery_order_public"
  """
  insert_delivery_order_public(
    """the rows to be inserted"""
    objects: [delivery_order_public_insert_input!]!
  ): delivery_order_public_mutation_response

  """
  insert a single row into the table: "delivery_order_public"
  """
  insert_delivery_order_public_one(
    """the row to be inserted"""
    object: delivery_order_public_insert_input!
  ): delivery_order_public

  """
  insert data into the table: "mez_admin"
  """
  insert_mez_admin(
    """the rows to be inserted"""
    objects: [mez_admin_insert_input!]!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin_mutation_response

  """
  insert a single row into the table: "mez_admin"
  """
  insert_mez_admin_one(
    """the row to be inserted"""
    object: mez_admin_insert_input!

    """upsert condition"""
    on_conflict: mez_admin_on_conflict
  ): mez_admin

  """
  insert data into the table: "notification_info"
  """
  insert_notification_info(
    """the rows to be inserted"""
    objects: [notification_info_insert_input!]!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info_mutation_response

  """
  insert a single row into the table: "notification_info"
  """
  insert_notification_info_one(
    """the row to be inserted"""
    object: notification_info_insert_input!

    """upsert condition"""
    on_conflict: notification_info_on_conflict
  ): notification_info

  """
  insert data into the table: "post"
  """
  insert_post(
    """the rows to be inserted"""
    objects: [post_insert_input!]!

    """upsert condition"""
    on_conflict: post_on_conflict
  ): post_mutation_response

  """
  insert a single row into the table: "post"
  """
  insert_post_one(
    """the row to be inserted"""
    object: post_insert_input!

    """upsert condition"""
    on_conflict: post_on_conflict
  ): post

  """
  insert data into the table: "restaurant"
  """
  insert_restaurant(
    """the rows to be inserted"""
    objects: [restaurant_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_on_conflict
  ): restaurant_mutation_response

  """
  insert data into the table: "restaurant_cart"
  """
  insert_restaurant_cart(
    """the rows to be inserted"""
    objects: [restaurant_cart_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart_mutation_response

  """
  insert data into the table: "restaurant_cart_item"
  """
  insert_restaurant_cart_item(
    """the rows to be inserted"""
    objects: [restaurant_cart_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item_mutation_response

  """
  insert a single row into the table: "restaurant_cart_item"
  """
  insert_restaurant_cart_item_one(
    """the row to be inserted"""
    object: restaurant_cart_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_item_on_conflict
  ): restaurant_cart_item

  """
  insert a single row into the table: "restaurant_cart"
  """
  insert_restaurant_cart_one(
    """the row to be inserted"""
    object: restaurant_cart_insert_input!

    """upsert condition"""
    on_conflict: restaurant_cart_on_conflict
  ): restaurant_cart

  """
  insert data into the table: "restaurant_category"
  """
  insert_restaurant_category(
    """the rows to be inserted"""
    objects: [restaurant_category_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category_mutation_response

  """
  insert a single row into the table: "restaurant_category"
  """
  insert_restaurant_category_one(
    """the row to be inserted"""
    object: restaurant_category_insert_input!

    """upsert condition"""
    on_conflict: restaurant_category_on_conflict
  ): restaurant_category

  """
  insert data into the table: "restaurant_choice"
  """
  insert_restaurant_choice(
    """the rows to be inserted"""
    objects: [restaurant_choice_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice_mutation_response

  """
  insert a single row into the table: "restaurant_choice"
  """
  insert_restaurant_choice_one(
    """the row to be inserted"""
    object: restaurant_choice_insert_input!

    """upsert condition"""
    on_conflict: restaurant_choice_on_conflict
  ): restaurant_choice

  """
  insert data into the table: "restaurant_item"
  """
  insert_restaurant_item(
    """the rows to be inserted"""
    objects: [restaurant_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item_mutation_response

  """
  insert a single row into the table: "restaurant_item"
  """
  insert_restaurant_item_one(
    """the row to be inserted"""
    object: restaurant_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_on_conflict
  ): restaurant_item

  """
  insert data into the table: "restaurant_item_option_map"
  """
  insert_restaurant_item_option_map(
    """the rows to be inserted"""
    objects: [restaurant_item_option_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map_mutation_response

  """
  insert a single row into the table: "restaurant_item_option_map"
  """
  insert_restaurant_item_option_map_one(
    """the row to be inserted"""
    object: restaurant_item_option_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_item_option_map_on_conflict
  ): restaurant_item_option_map

  """
  insert a single row into the table: "restaurant"
  """
  insert_restaurant_one(
    """the row to be inserted"""
    object: restaurant_insert_input!

    """upsert condition"""
    on_conflict: restaurant_on_conflict
  ): restaurant

  """
  insert data into the table: "restaurant_operator"
  """
  insert_restaurant_operator(
    """the rows to be inserted"""
    objects: [restaurant_operator_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator_mutation_response

  """
  insert a single row into the table: "restaurant_operator"
  """
  insert_restaurant_operator_one(
    """the row to be inserted"""
    object: restaurant_operator_insert_input!

    """upsert condition"""
    on_conflict: restaurant_operator_on_conflict
  ): restaurant_operator

  """
  insert data into the table: "restaurant_option"
  """
  insert_restaurant_option(
    """the rows to be inserted"""
    objects: [restaurant_option_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option_mutation_response

  """
  insert data into the table: "restaurant_option_choice_map"
  """
  insert_restaurant_option_choice_map(
    """the rows to be inserted"""
    objects: [restaurant_option_choice_map_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map_mutation_response

  """
  insert a single row into the table: "restaurant_option_choice_map"
  """
  insert_restaurant_option_choice_map_one(
    """the row to be inserted"""
    object: restaurant_option_choice_map_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_choice_map_on_conflict
  ): restaurant_option_choice_map

  """
  insert a single row into the table: "restaurant_option"
  """
  insert_restaurant_option_one(
    """the row to be inserted"""
    object: restaurant_option_insert_input!

    """upsert condition"""
    on_conflict: restaurant_option_on_conflict
  ): restaurant_option

  """
  insert data into the table: "restaurant_order"
  """
  insert_restaurant_order(
    """the rows to be inserted"""
    objects: [restaurant_order_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order_mutation_response

  """
  insert data into the table: "restaurant_order_item"
  """
  insert_restaurant_order_item(
    """the rows to be inserted"""
    objects: [restaurant_order_item_insert_input!]!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item_mutation_response

  """
  insert a single row into the table: "restaurant_order_item"
  """
  insert_restaurant_order_item_one(
    """the row to be inserted"""
    object: restaurant_order_item_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_item_on_conflict
  ): restaurant_order_item

  """
  insert a single row into the table: "restaurant_order"
  """
  insert_restaurant_order_one(
    """the row to be inserted"""
    object: restaurant_order_insert_input!

    """upsert condition"""
    on_conflict: restaurant_order_on_conflict
  ): restaurant_order

  """
  insert data into the table: "restaurant_order_public"
  """
  insert_restaurant_order_public(
    """the rows to be inserted"""
    objects: [restaurant_order_public_insert_input!]!
  ): restaurant_order_public_mutation_response

  """
  insert a single row into the table: "restaurant_order_public"
  """
  insert_restaurant_order_public_one(
    """the row to be inserted"""
    object: restaurant_order_public_insert_input!
  ): restaurant_order_public

  """
  insert data into the table: "review"
  """
  insert_review(
    """the rows to be inserted"""
    objects: [review_insert_input!]!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review_mutation_response

  """
  insert a single row into the table: "review"
  """
  insert_review_one(
    """the row to be inserted"""
    object: review_insert_input!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review

  """
  insert data into the table: "saved_location"
  """
  insert_saved_location(
    """the rows to be inserted"""
    objects: [saved_location_insert_input!]!

    """upsert condition"""
    on_conflict: saved_location_on_conflict
  ): saved_location_mutation_response

  """
  insert a single row into the table: "saved_location"
  """
  insert_saved_location_one(
    """the row to be inserted"""
    object: saved_location_insert_input!

    """upsert condition"""
    on_conflict: saved_location_on_conflict
  ): saved_location

  """
  insert data into the table: "service_link"
  """
  insert_service_link(
    """the rows to be inserted"""
    objects: [service_link_insert_input!]!

    """upsert condition"""
    on_conflict: service_link_on_conflict
  ): service_link_mutation_response

  """
  insert a single row into the table: "service_link"
  """
  insert_service_link_one(
    """the row to be inserted"""
    object: service_link_insert_input!

    """upsert condition"""
    on_conflict: service_link_on_conflict
  ): service_link

  """
  insert data into the table: "service_provider_payment_info"
  """
  insert_service_provider_payment_info(
    """the rows to be inserted"""
    objects: [service_provider_payment_info_insert_input!]!

    """upsert condition"""
    on_conflict: service_provider_payment_info_on_conflict
  ): service_provider_payment_info_mutation_response

  """
  insert a single row into the table: "service_provider_payment_info"
  """
  insert_service_provider_payment_info_one(
    """the row to be inserted"""
    object: service_provider_payment_info_insert_input!

    """upsert condition"""
    on_conflict: service_provider_payment_info_on_conflict
  ): service_provider_payment_info

  """
  insert data into the table: "stripe_info"
  """
  insert_stripe_info(
    """the rows to be inserted"""
    objects: [stripe_info_insert_input!]!

    """upsert condition"""
    on_conflict: stripe_info_on_conflict
  ): stripe_info_mutation_response

  """
  insert a single row into the table: "stripe_info"
  """
  insert_stripe_info_one(
    """the row to be inserted"""
    object: stripe_info_insert_input!

    """upsert condition"""
    on_conflict: stripe_info_on_conflict
  ): stripe_info

  """
  insert data into the table: "subscriber"
  """
  insert_subscriber(
    """the rows to be inserted"""
    objects: [subscriber_insert_input!]!

    """upsert condition"""
    on_conflict: subscriber_on_conflict
  ): subscriber_mutation_response

  """
  insert a single row into the table: "subscriber"
  """
  insert_subscriber_one(
    """the row to be inserted"""
    object: subscriber_insert_input!

    """upsert condition"""
    on_conflict: subscriber_on_conflict
  ): subscriber

  """
  insert data into the table: "topology.app_type"
  """
  insert_topology_app_type(
    """the rows to be inserted"""
    objects: [topology_app_type_insert_input!]!

    """upsert condition"""
    on_conflict: topology_app_type_on_conflict
  ): topology_app_type_mutation_response

  """
  insert a single row into the table: "topology.app_type"
  """
  insert_topology_app_type_one(
    """the row to be inserted"""
    object: topology_app_type_insert_input!

    """upsert condition"""
    on_conflict: topology_app_type_on_conflict
  ): topology_app_type

  """
  insert data into the table: "topology.language"
  """
  insert_topology_language(
    """the rows to be inserted"""
    objects: [topology_language_insert_input!]!

    """upsert condition"""
    on_conflict: topology_language_on_conflict
  ): topology_language_mutation_response

  """
  insert a single row into the table: "topology.language"
  """
  insert_topology_language_one(
    """the row to be inserted"""
    object: topology_language_insert_input!

    """upsert condition"""
    on_conflict: topology_language_on_conflict
  ): topology_language

  """
  insert data into the table: "translation"
  """
  insert_translation(
    """the rows to be inserted"""
    objects: [translation_insert_input!]!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation_mutation_response

  """
  insert a single row into the table: "translation"
  """
  insert_translation_one(
    """the row to be inserted"""
    object: translation_insert_input!

    """upsert condition"""
    on_conflict: translation_on_conflict
  ): translation

  """
  insert data into the table: "translation_value"
  """
  insert_translation_value(
    """the rows to be inserted"""
    objects: [translation_value_insert_input!]!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value_mutation_response

  """
  insert a single row into the table: "translation_value"
  """
  insert_translation_value_one(
    """the row to be inserted"""
    object: translation_value_insert_input!

    """upsert condition"""
    on_conflict: translation_value_on_conflict
  ): translation_value

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "chat"
  """
  update_chat(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input

    """filter the rows which have to be updated"""
    where: chat_bool_exp!
  ): chat_mutation_response

  """
  update single row of the table: "chat"
  """
  update_chat_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chat_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chat_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: chat_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chat_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chat_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_set_input
    pk_columns: chat_pk_columns_input!
  ): chat

  """
  update multiples rows of table: "chat"
  """
  update_chat_many(
    """updates to execute, in order"""
    updates: [chat_updates!]!
  ): [chat_mutation_response]

  """
  update data of the table: "chat_participant"
  """
  update_chat_participant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input

    """filter the rows which have to be updated"""
    where: chat_participant_bool_exp!
  ): chat_participant_mutation_response

  """
  update single row of the table: "chat_participant"
  """
  update_chat_participant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_participant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_participant_set_input
    pk_columns: chat_participant_pk_columns_input!
  ): chat_participant

  """
  update multiples rows of table: "chat_participant"
  """
  update_chat_participant_many(
    """updates to execute, in order"""
    updates: [chat_participant_updates!]!
  ): [chat_participant_mutation_response]

  """
  update data of the table: "customer"
  """
  update_customer(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customer_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customer_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: customer_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customer_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customer_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input

    """filter the rows which have to be updated"""
    where: customer_bool_exp!
  ): customer_mutation_response

  """
  update single row of the table: "customer"
  """
  update_customer_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customer_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customer_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: customer_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customer_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customer_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_set_input
    pk_columns: customer_pk_columns_input!
  ): customer

  """
  update multiples rows of table: "customer"
  """
  update_customer_many(
    """updates to execute, in order"""
    updates: [customer_updates!]!
  ): [customer_mutation_response]

  """
  update data of the table: "delivery_company"
  """
  update_delivery_company(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_company_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_company_set_input

    """filter the rows which have to be updated"""
    where: delivery_company_bool_exp!
  ): delivery_company_mutation_response

  """
  update single row of the table: "delivery_company"
  """
  update_delivery_company_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_company_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_company_set_input
    pk_columns: delivery_company_pk_columns_input!
  ): delivery_company

  """
  update multiples rows of table: "delivery_company"
  """
  update_delivery_company_many(
    """updates to execute, in order"""
    updates: [delivery_company_updates!]!
  ): [delivery_company_mutation_response]

  """
  update data of the table: "delivery_cost"
  """
  update_delivery_cost(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_cost_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_cost_set_input

    """filter the rows which have to be updated"""
    where: delivery_cost_bool_exp!
  ): delivery_cost_mutation_response

  """
  update single row of the table: "delivery_cost"
  """
  update_delivery_cost_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_cost_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_cost_set_input
    pk_columns: delivery_cost_pk_columns_input!
  ): delivery_cost

  """
  update multiples rows of table: "delivery_cost"
  """
  update_delivery_cost_many(
    """updates to execute, in order"""
    updates: [delivery_cost_updates!]!
  ): [delivery_cost_mutation_response]

  """
  update data of the table: "delivery_driver"
  """
  update_delivery_driver(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_driver_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_driver_set_input

    """filter the rows which have to be updated"""
    where: delivery_driver_bool_exp!
  ): delivery_driver_mutation_response

  """
  update single row of the table: "delivery_driver"
  """
  update_delivery_driver_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_driver_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_driver_set_input
    pk_columns: delivery_driver_pk_columns_input!
  ): delivery_driver

  """
  update multiples rows of table: "delivery_driver"
  """
  update_delivery_driver_many(
    """updates to execute, in order"""
    updates: [delivery_driver_updates!]!
  ): [delivery_driver_mutation_response]

  """
  update data of the table: "delivery_operator"
  """
  update_delivery_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_operator_set_input

    """filter the rows which have to be updated"""
    where: delivery_operator_bool_exp!
  ): delivery_operator_mutation_response

  """
  update single row of the table: "delivery_operator"
  """
  update_delivery_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_operator_set_input
    pk_columns: delivery_operator_pk_columns_input!
  ): delivery_operator

  """
  update multiples rows of table: "delivery_operator"
  """
  update_delivery_operator_many(
    """updates to execute, in order"""
    updates: [delivery_operator_updates!]!
  ): [delivery_operator_mutation_response]

  """
  update data of the table: "delivery_order"
  """
  update_delivery_order(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_set_input

    """filter the rows which have to be updated"""
    where: delivery_order_bool_exp!
  ): delivery_order_mutation_response

  """
  update single row of the table: "delivery_order"
  """
  update_delivery_order_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_set_input
    pk_columns: delivery_order_pk_columns_input!
  ): delivery_order

  """
  update multiples rows of table: "delivery_order"
  """
  update_delivery_order_many(
    """updates to execute, in order"""
    updates: [delivery_order_updates!]!
  ): [delivery_order_mutation_response]

  """
  update data of the table: "delivery_order_public"
  """
  update_delivery_order_public(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delivery_order_public_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delivery_order_public_set_input

    """filter the rows which have to be updated"""
    where: delivery_order_public_bool_exp!
  ): delivery_order_public_mutation_response

  """
  update multiples rows of table: "delivery_order_public"
  """
  update_delivery_order_public_many(
    """updates to execute, in order"""
    updates: [delivery_order_public_updates!]!
  ): [delivery_order_public_mutation_response]

  """
  update data of the table: "mez_admin"
  """
  update_mez_admin(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input

    """filter the rows which have to be updated"""
    where: mez_admin_bool_exp!
  ): mez_admin_mutation_response

  """
  update single row of the table: "mez_admin"
  """
  update_mez_admin_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mez_admin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mez_admin_set_input
    pk_columns: mez_admin_pk_columns_input!
  ): mez_admin

  """
  update multiples rows of table: "mez_admin"
  """
  update_mez_admin_many(
    """updates to execute, in order"""
    updates: [mez_admin_updates!]!
  ): [mez_admin_mutation_response]

  """
  update data of the table: "notification_info"
  """
  update_notification_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input

    """filter the rows which have to be updated"""
    where: notification_info_bool_exp!
  ): notification_info_mutation_response

  """
  update single row of the table: "notification_info"
  """
  update_notification_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notification_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notification_info_set_input
    pk_columns: notification_info_pk_columns_input!
  ): notification_info

  """
  update multiples rows of table: "notification_info"
  """
  update_notification_info_many(
    """updates to execute, in order"""
    updates: [notification_info_updates!]!
  ): [notification_info_mutation_response]

  """
  update data of the table: "post"
  """
  update_post(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: post_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: post_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_set_input

    """filter the rows which have to be updated"""
    where: post_bool_exp!
  ): post_mutation_response

  """
  update single row of the table: "post"
  """
  update_post_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: post_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: post_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: post_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: post_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: post_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: post_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_set_input
    pk_columns: post_pk_columns_input!
  ): post

  """
  update multiples rows of table: "post"
  """
  update_post_many(
    """updates to execute, in order"""
    updates: [post_updates!]!
  ): [post_mutation_response]

  """
  update data of the table: "restaurant"
  """
  update_restaurant(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_set_input

    """filter the rows which have to be updated"""
    where: restaurant_bool_exp!
  ): restaurant_mutation_response

  """
  update single row of the table: "restaurant"
  """
  update_restaurant_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_set_input
    pk_columns: restaurant_pk_columns_input!
  ): restaurant

  """
  update data of the table: "restaurant_cart"
  """
  update_restaurant_cart(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_bool_exp!
  ): restaurant_cart_mutation_response

  """
  update single row of the table: "restaurant_cart"
  """
  update_restaurant_cart_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_set_input
    pk_columns: restaurant_cart_pk_columns_input!
  ): restaurant_cart

  """
  update data of the table: "restaurant_cart_item"
  """
  update_restaurant_cart_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_cart_item_bool_exp!
  ): restaurant_cart_item_mutation_response

  """
  update single row of the table: "restaurant_cart_item"
  """
  update_restaurant_cart_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_cart_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_cart_item_set_input
    pk_columns: restaurant_cart_item_pk_columns_input!
  ): restaurant_cart_item

  """
  update multiples rows of table: "restaurant_cart_item"
  """
  update_restaurant_cart_item_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_item_updates!]!
  ): [restaurant_cart_item_mutation_response]

  """
  update multiples rows of table: "restaurant_cart"
  """
  update_restaurant_cart_many(
    """updates to execute, in order"""
    updates: [restaurant_cart_updates!]!
  ): [restaurant_cart_mutation_response]

  """
  update data of the table: "restaurant_category"
  """
  update_restaurant_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input

    """filter the rows which have to be updated"""
    where: restaurant_category_bool_exp!
  ): restaurant_category_mutation_response

  """
  update single row of the table: "restaurant_category"
  """
  update_restaurant_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_category_set_input
    pk_columns: restaurant_category_pk_columns_input!
  ): restaurant_category

  """
  update multiples rows of table: "restaurant_category"
  """
  update_restaurant_category_many(
    """updates to execute, in order"""
    updates: [restaurant_category_updates!]!
  ): [restaurant_category_mutation_response]

  """
  update data of the table: "restaurant_choice"
  """
  update_restaurant_choice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input

    """filter the rows which have to be updated"""
    where: restaurant_choice_bool_exp!
  ): restaurant_choice_mutation_response

  """
  update single row of the table: "restaurant_choice"
  """
  update_restaurant_choice_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_choice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_choice_set_input
    pk_columns: restaurant_choice_pk_columns_input!
  ): restaurant_choice

  """
  update multiples rows of table: "restaurant_choice"
  """
  update_restaurant_choice_many(
    """updates to execute, in order"""
    updates: [restaurant_choice_updates!]!
  ): [restaurant_choice_mutation_response]

  """
  update data of the table: "restaurant_item"
  """
  update_restaurant_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_bool_exp!
  ): restaurant_item_mutation_response

  """
  update single row of the table: "restaurant_item"
  """
  update_restaurant_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_set_input
    pk_columns: restaurant_item_pk_columns_input!
  ): restaurant_item

  """
  update multiples rows of table: "restaurant_item"
  """
  update_restaurant_item_many(
    """updates to execute, in order"""
    updates: [restaurant_item_updates!]!
  ): [restaurant_item_mutation_response]

  """
  update data of the table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_item_option_map_bool_exp!
  ): restaurant_item_option_map_mutation_response

  """
  update single row of the table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_item_option_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_item_option_map_set_input
    pk_columns: restaurant_item_option_map_pk_columns_input!
  ): restaurant_item_option_map

  """
  update multiples rows of table: "restaurant_item_option_map"
  """
  update_restaurant_item_option_map_many(
    """updates to execute, in order"""
    updates: [restaurant_item_option_map_updates!]!
  ): [restaurant_item_option_map_mutation_response]

  """
  update multiples rows of table: "restaurant"
  """
  update_restaurant_many(
    """updates to execute, in order"""
    updates: [restaurant_updates!]!
  ): [restaurant_mutation_response]

  """
  update data of the table: "restaurant_operator"
  """
  update_restaurant_operator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input

    """filter the rows which have to be updated"""
    where: restaurant_operator_bool_exp!
  ): restaurant_operator_mutation_response

  """
  update single row of the table: "restaurant_operator"
  """
  update_restaurant_operator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_operator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_operator_set_input
    pk_columns: restaurant_operator_pk_columns_input!
  ): restaurant_operator

  """
  update multiples rows of table: "restaurant_operator"
  """
  update_restaurant_operator_many(
    """updates to execute, in order"""
    updates: [restaurant_operator_updates!]!
  ): [restaurant_operator_mutation_response]

  """
  update data of the table: "restaurant_option"
  """
  update_restaurant_option(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_bool_exp!
  ): restaurant_option_mutation_response

  """
  update single row of the table: "restaurant_option"
  """
  update_restaurant_option_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_set_input
    pk_columns: restaurant_option_pk_columns_input!
  ): restaurant_option

  """
  update data of the table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input

    """filter the rows which have to be updated"""
    where: restaurant_option_choice_map_bool_exp!
  ): restaurant_option_choice_map_mutation_response

  """
  update single row of the table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_option_choice_map_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_option_choice_map_set_input
    pk_columns: restaurant_option_choice_map_pk_columns_input!
  ): restaurant_option_choice_map

  """
  update multiples rows of table: "restaurant_option_choice_map"
  """
  update_restaurant_option_choice_map_many(
    """updates to execute, in order"""
    updates: [restaurant_option_choice_map_updates!]!
  ): [restaurant_option_choice_map_mutation_response]

  """
  update multiples rows of table: "restaurant_option"
  """
  update_restaurant_option_many(
    """updates to execute, in order"""
    updates: [restaurant_option_updates!]!
  ): [restaurant_option_mutation_response]

  """
  update data of the table: "restaurant_order"
  """
  update_restaurant_order(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_bool_exp!
  ): restaurant_order_mutation_response

  """
  update single row of the table: "restaurant_order"
  """
  update_restaurant_order_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: restaurant_order_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: restaurant_order_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: restaurant_order_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: restaurant_order_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: restaurant_order_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_set_input
    pk_columns: restaurant_order_pk_columns_input!
  ): restaurant_order

  """
  update data of the table: "restaurant_order_item"
  """
  update_restaurant_order_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_item_bool_exp!
  ): restaurant_order_item_mutation_response

  """
  update single row of the table: "restaurant_order_item"
  """
  update_restaurant_order_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_item_set_input
    pk_columns: restaurant_order_item_pk_columns_input!
  ): restaurant_order_item

  """
  update multiples rows of table: "restaurant_order_item"
  """
  update_restaurant_order_item_many(
    """updates to execute, in order"""
    updates: [restaurant_order_item_updates!]!
  ): [restaurant_order_item_mutation_response]

  """
  update multiples rows of table: "restaurant_order"
  """
  update_restaurant_order_many(
    """updates to execute, in order"""
    updates: [restaurant_order_updates!]!
  ): [restaurant_order_mutation_response]

  """
  update data of the table: "restaurant_order_public"
  """
  update_restaurant_order_public(
    """increments the numeric columns with given value of the filtered values"""
    _inc: restaurant_order_public_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: restaurant_order_public_set_input

    """filter the rows which have to be updated"""
    where: restaurant_order_public_bool_exp!
  ): restaurant_order_public_mutation_response

  """
  update multiples rows of table: "restaurant_order_public"
  """
  update_restaurant_order_public_many(
    """updates to execute, in order"""
    updates: [restaurant_order_public_updates!]!
  ): [restaurant_order_public_mutation_response]

  """
  update data of the table: "review"
  """
  update_review(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input

    """filter the rows which have to be updated"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  update single row of the table: "review"
  """
  update_review_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  """
  update multiples rows of table: "review"
  """
  update_review_many(
    """updates to execute, in order"""
    updates: [review_updates!]!
  ): [review_mutation_response]

  """
  update data of the table: "saved_location"
  """
  update_saved_location(
    """increments the numeric columns with given value of the filtered values"""
    _inc: saved_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: saved_location_set_input

    """filter the rows which have to be updated"""
    where: saved_location_bool_exp!
  ): saved_location_mutation_response

  """
  update single row of the table: "saved_location"
  """
  update_saved_location_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: saved_location_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: saved_location_set_input
    pk_columns: saved_location_pk_columns_input!
  ): saved_location

  """
  update multiples rows of table: "saved_location"
  """
  update_saved_location_many(
    """updates to execute, in order"""
    updates: [saved_location_updates!]!
  ): [saved_location_mutation_response]

  """
  update data of the table: "service_link"
  """
  update_service_link(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_link_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_link_set_input

    """filter the rows which have to be updated"""
    where: service_link_bool_exp!
  ): service_link_mutation_response

  """
  update single row of the table: "service_link"
  """
  update_service_link_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_link_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_link_set_input
    pk_columns: service_link_pk_columns_input!
  ): service_link

  """
  update multiples rows of table: "service_link"
  """
  update_service_link_many(
    """updates to execute, in order"""
    updates: [service_link_updates!]!
  ): [service_link_mutation_response]

  """
  update data of the table: "service_provider_payment_info"
  """
  update_service_provider_payment_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_payment_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_payment_info_set_input

    """filter the rows which have to be updated"""
    where: service_provider_payment_info_bool_exp!
  ): service_provider_payment_info_mutation_response

  """
  update single row of the table: "service_provider_payment_info"
  """
  update_service_provider_payment_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_provider_payment_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_provider_payment_info_set_input
    pk_columns: service_provider_payment_info_pk_columns_input!
  ): service_provider_payment_info

  """
  update multiples rows of table: "service_provider_payment_info"
  """
  update_service_provider_payment_info_many(
    """updates to execute, in order"""
    updates: [service_provider_payment_info_updates!]!
  ): [service_provider_payment_info_mutation_response]

  """
  update data of the table: "stripe_info"
  """
  update_stripe_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: stripe_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stripe_info_set_input

    """filter the rows which have to be updated"""
    where: stripe_info_bool_exp!
  ): stripe_info_mutation_response

  """
  update single row of the table: "stripe_info"
  """
  update_stripe_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: stripe_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stripe_info_set_input
    pk_columns: stripe_info_pk_columns_input!
  ): stripe_info

  """
  update multiples rows of table: "stripe_info"
  """
  update_stripe_info_many(
    """updates to execute, in order"""
    updates: [stripe_info_updates!]!
  ): [stripe_info_mutation_response]

  """
  update data of the table: "subscriber"
  """
  update_subscriber(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriber_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriber_set_input

    """filter the rows which have to be updated"""
    where: subscriber_bool_exp!
  ): subscriber_mutation_response

  """
  update single row of the table: "subscriber"
  """
  update_subscriber_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: subscriber_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: subscriber_set_input
    pk_columns: subscriber_pk_columns_input!
  ): subscriber

  """
  update multiples rows of table: "subscriber"
  """
  update_subscriber_many(
    """updates to execute, in order"""
    updates: [subscriber_updates!]!
  ): [subscriber_mutation_response]

  """
  update data of the table: "topology.app_type"
  """
  update_topology_app_type(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_app_type_set_input

    """filter the rows which have to be updated"""
    where: topology_app_type_bool_exp!
  ): topology_app_type_mutation_response

  """
  update single row of the table: "topology.app_type"
  """
  update_topology_app_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_app_type_set_input
    pk_columns: topology_app_type_pk_columns_input!
  ): topology_app_type

  """
  update multiples rows of table: "topology.app_type"
  """
  update_topology_app_type_many(
    """updates to execute, in order"""
    updates: [topology_app_type_updates!]!
  ): [topology_app_type_mutation_response]

  """
  update data of the table: "topology.language"
  """
  update_topology_language(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_language_set_input

    """filter the rows which have to be updated"""
    where: topology_language_bool_exp!
  ): topology_language_mutation_response

  """
  update single row of the table: "topology.language"
  """
  update_topology_language_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: topology_language_set_input
    pk_columns: topology_language_pk_columns_input!
  ): topology_language

  """
  update multiples rows of table: "topology.language"
  """
  update_topology_language_many(
    """updates to execute, in order"""
    updates: [topology_language_updates!]!
  ): [topology_language_mutation_response]

  """
  update data of the table: "translation"
  """
  update_translation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input

    """filter the rows which have to be updated"""
    where: translation_bool_exp!
  ): translation_mutation_response

  """
  update single row of the table: "translation"
  """
  update_translation_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_set_input
    pk_columns: translation_pk_columns_input!
  ): translation

  """
  update multiples rows of table: "translation"
  """
  update_translation_many(
    """updates to execute, in order"""
    updates: [translation_updates!]!
  ): [translation_mutation_response]

  """
  update data of the table: "translation_value"
  """
  update_translation_value(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input

    """filter the rows which have to be updated"""
    where: translation_value_bool_exp!
  ): translation_value_mutation_response

  """
  update single row of the table: "translation_value"
  """
  update_translation_value_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: translation_value_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: translation_value_set_input
    pk_columns: translation_value_pk_columns_input!
  ): translation_value

  """
  update multiples rows of table: "translation_value"
  """
  update_translation_value_many(
    """updates to execute, in order"""
    updates: [translation_value_updates!]!
  ): [translation_value_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

"""
columns and relationships of "notification_info"
"""
type notification_info {
  app_type_id: String!
  id: Int!
  token: String!
  user_id: Int!
}

"""
aggregated selection of "notification_info"
"""
type notification_info_aggregate {
  aggregate: notification_info_aggregate_fields
  nodes: [notification_info!]!
}

"""
aggregate fields of "notification_info"
"""
type notification_info_aggregate_fields {
  avg: notification_info_avg_fields
  count(columns: [notification_info_select_column!], distinct: Boolean): Int!
  max: notification_info_max_fields
  min: notification_info_min_fields
  stddev: notification_info_stddev_fields
  stddev_pop: notification_info_stddev_pop_fields
  stddev_samp: notification_info_stddev_samp_fields
  sum: notification_info_sum_fields
  var_pop: notification_info_var_pop_fields
  var_samp: notification_info_var_samp_fields
  variance: notification_info_variance_fields
}

"""aggregate avg on columns"""
type notification_info_avg_fields {
  id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "notification_info". All fields are combined with a logical 'AND'.
"""
input notification_info_bool_exp {
  _and: [notification_info_bool_exp!]
  _not: notification_info_bool_exp
  _or: [notification_info_bool_exp!]
  app_type_id: String_comparison_exp
  id: Int_comparison_exp
  token: String_comparison_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "notification_info"
"""
enum notification_info_constraint {
  """
  unique or primary key constraint on columns "app_type_id", "user_id"
  """
  notification_info_app_type_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  notification_info_pkey

  """
  unique or primary key constraint on columns "app_type_id", "user_id"
  """
  notification_info_user_id_app_type_id_key
}

"""
input type for incrementing numeric columns in table "notification_info"
"""
input notification_info_inc_input {
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "notification_info"
"""
input notification_info_insert_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate max on columns"""
type notification_info_max_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate min on columns"""
type notification_info_min_fields {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""
response of any mutation on the table "notification_info"
"""
type notification_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification_info!]!
}

"""
input type for inserting object relation for remote table "notification_info"
"""
input notification_info_obj_rel_insert_input {
  data: notification_info_insert_input!

  """upsert condition"""
  on_conflict: notification_info_on_conflict
}

"""
on_conflict condition type for table "notification_info"
"""
input notification_info_on_conflict {
  constraint: notification_info_constraint!
  update_columns: [notification_info_update_column!]! = []
  where: notification_info_bool_exp
}

"""Ordering options when selecting data from "notification_info"."""
input notification_info_order_by {
  app_type_id: order_by
  id: order_by
  token: order_by
  user_id: order_by
}

"""primary key columns input for table: notification_info"""
input notification_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "notification_info"
"""
enum notification_info_select_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  user_id
}

"""
input type for updating data in table "notification_info"
"""
input notification_info_set_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate stddev on columns"""
type notification_info_stddev_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type notification_info_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type notification_info_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
Streaming cursor of the table "notification_info"
"""
input notification_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_info_stream_cursor_value_input {
  app_type_id: String
  id: Int
  token: String
  user_id: Int
}

"""aggregate sum on columns"""
type notification_info_sum_fields {
  id: Int
  user_id: Int
}

"""
update columns of table "notification_info"
"""
enum notification_info_update_column {
  """column name"""
  app_type_id

  """column name"""
  id

  """column name"""
  token

  """column name"""
  user_id
}

input notification_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: notification_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: notification_info_set_input
  where: notification_info_bool_exp!
}

"""aggregate var_pop on columns"""
type notification_info_var_pop_fields {
  id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type notification_info_var_samp_fields {
  id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type notification_info_variance_fields {
  id: Float
  user_id: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "post"
"""
type post {
  comments(
    """JSON select path"""
    path: String
  ): jsonb
  id: Int!
  image: String
  likes(
    """JSON select path"""
    path: String
  ): jsonb
  message: String!
  posted_on: timestamptz!

  """An object relationship"""
  restaurant: restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "post"
"""
type post_aggregate {
  aggregate: post_aggregate_fields
  nodes: [post!]!
}

"""
aggregate fields of "post"
"""
type post_aggregate_fields {
  avg: post_avg_fields
  count(columns: [post_select_column!], distinct: Boolean): Int!
  max: post_max_fields
  min: post_min_fields
  stddev: post_stddev_fields
  stddev_pop: post_stddev_pop_fields
  stddev_samp: post_stddev_samp_fields
  sum: post_sum_fields
  var_pop: post_var_pop_fields
  var_samp: post_var_samp_fields
  variance: post_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input post_append_input {
  comments: jsonb
  likes: jsonb
}

"""aggregate avg on columns"""
type post_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "post". All fields are combined with a logical 'AND'.
"""
input post_bool_exp {
  _and: [post_bool_exp!]
  _not: post_bool_exp
  _or: [post_bool_exp!]
  comments: jsonb_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  likes: jsonb_comparison_exp
  message: String_comparison_exp
  posted_on: timestamptz_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "post"
"""
enum post_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input post_delete_at_path_input {
  comments: [String!]
  likes: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input post_delete_elem_input {
  comments: Int
  likes: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input post_delete_key_input {
  comments: String
  likes: String
}

"""
input type for incrementing numeric columns in table "post"
"""
input post_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "post"
"""
input post_insert_input {
  comments: jsonb
  id: Int
  image: String
  likes: jsonb
  message: String
  posted_on: timestamptz
  restaurant: restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type post_max_fields {
  id: Int
  image: String
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type post_min_fields {
  id: Int
  image: String
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "post"
"""
type post_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post!]!
}

"""
on_conflict condition type for table "post"
"""
input post_on_conflict {
  constraint: post_constraint!
  update_columns: [post_update_column!]! = []
  where: post_bool_exp
}

"""Ordering options when selecting data from "post"."""
input post_order_by {
  comments: order_by
  id: order_by
  image: order_by
  likes: order_by
  message: order_by
  posted_on: order_by
  restaurant: restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: post"""
input post_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input post_prepend_input {
  comments: jsonb
  likes: jsonb
}

"""
select columns of table "post"
"""
enum post_select_column {
  """column name"""
  comments

  """column name"""
  id

  """column name"""
  image

  """column name"""
  likes

  """column name"""
  message

  """column name"""
  posted_on

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "post"
"""
input post_set_input {
  comments: jsonb
  id: Int
  image: String
  likes: jsonb
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type post_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type post_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type post_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "post"
"""
input post_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_stream_cursor_value_input {
  comments: jsonb
  id: Int
  image: String
  likes: jsonb
  message: String
  posted_on: timestamptz
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type post_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "post"
"""
enum post_update_column {
  """column name"""
  comments

  """column name"""
  id

  """column name"""
  image

  """column name"""
  likes

  """column name"""
  message

  """column name"""
  posted_on

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input post_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: post_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: post_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: post_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: post_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: post_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: post_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: post_set_input
  where: post_bool_exp!
}

"""aggregate var_pop on columns"""
type post_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type post_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type post_variance_fields {
  id: Float
  service_provider_id: Float
}

type query_root {
  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(user_id: Int!): customer

  """
  fetch data from the table: "delivery_company"
  """
  delivery_company(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  fetch aggregated fields from the table: "delivery_company"
  """
  delivery_company_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery_company" using primary key columns
  """
  delivery_company_by_pk(id: Int!): delivery_company

  """
  fetch data from the table: "delivery_cost"
  """
  delivery_cost(
    """distinct select on columns"""
    distinct_on: [delivery_cost_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_cost_order_by!]

    """filter the rows returned"""
    where: delivery_cost_bool_exp
  ): [delivery_cost!]!

  """
  fetch aggregated fields from the table: "delivery_cost"
  """
  delivery_cost_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_cost_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_cost_order_by!]

    """filter the rows returned"""
    where: delivery_cost_bool_exp
  ): delivery_cost_aggregate!

  """fetch data from the table: "delivery_cost" using primary key columns"""
  delivery_cost_by_pk(id: Int!): delivery_cost

  """
  fetch data from the table: "delivery_driver"
  """
  delivery_driver(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  fetch aggregated fields from the table: "delivery_driver"
  """
  delivery_driver_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """fetch data from the table: "delivery_driver" using primary key columns"""
  delivery_driver_by_pk(id: Int!): delivery_driver

  """
  fetch data from the table: "delivery_operator"
  """
  delivery_operator(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch aggregated fields from the table: "delivery_operator"
  """
  delivery_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """
  fetch data from the table: "delivery_operator" using primary key columns
  """
  delivery_operator_by_pk(id: Int!): delivery_operator

  """
  fetch data from the table: "delivery_order"
  """
  delivery_order(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch aggregated fields from the table: "delivery_order"
  """
  delivery_order_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """fetch data from the table: "delivery_order" using primary key columns"""
  delivery_order_by_pk(id: Int!): delivery_order

  """
  fetch data from the table: "delivery_order_public"
  """
  delivery_order_public(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch aggregated fields from the table: "delivery_order_public"
  """
  delivery_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): delivery_order_public_aggregate!

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table: "post"
  """
  post(
    """distinct select on columns"""
    distinct_on: [post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_order_by!]

    """filter the rows returned"""
    where: post_bool_exp
  ): [post!]!

  """
  fetch aggregated fields from the table: "post"
  """
  post_aggregate(
    """distinct select on columns"""
    distinct_on: [post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_order_by!]

    """filter the rows returned"""
    where: post_bool_exp
  ): post_aggregate!

  """fetch data from the table: "post" using primary key columns"""
  post_by_pk(id: Int!): post

  """
  fetch data from the table: "restaurant"
  """
  restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant"
  """
  restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): restaurant_aggregate!

  """fetch data from the table: "restaurant" using primary key columns"""
  restaurant_by_pk(id: Int!): restaurant

  """
  fetch data from the table: "restaurant_cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant_cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant_cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant_cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant_cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant_cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table: "restaurant_category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant_category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant_category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table: "restaurant_choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant_choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant_choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  fetch data from the table: "restaurant_item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant_item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant_item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant_item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  fetch data from the table: "restaurant_operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant_operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant_operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table: "restaurant_option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant_option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant_option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant_option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  fetch data from the table: "restaurant_order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant_order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant_order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant_order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant_order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant_order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table: "restaurant_order_public"
  """
  restaurant_order_public(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch aggregated fields from the table: "restaurant_order_public"
  """
  restaurant_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): restaurant_order_public_aggregate!

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table: "saved_location"
  """
  saved_location(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): [saved_location!]!

  """
  fetch aggregated fields from the table: "saved_location"
  """
  saved_location_aggregate(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): saved_location_aggregate!

  """fetch data from the table: "saved_location" using primary key columns"""
  saved_location_by_pk(id: Int!): saved_location

  """
  fetch data from the table: "service_link"
  """
  service_link(
    """distinct select on columns"""
    distinct_on: [service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_link_order_by!]

    """filter the rows returned"""
    where: service_link_bool_exp
  ): [service_link!]!

  """
  fetch aggregated fields from the table: "service_link"
  """
  service_link_aggregate(
    """distinct select on columns"""
    distinct_on: [service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_link_order_by!]

    """filter the rows returned"""
    where: service_link_bool_exp
  ): service_link_aggregate!

  """fetch data from the table: "service_link" using primary key columns"""
  service_link_by_pk(id: Int!): service_link

  """
  fetch data from the table: "service_provider_payment_info"
  """
  service_provider_payment_info(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch aggregated fields from the table: "service_provider_payment_info"
  """
  service_provider_payment_info_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): service_provider_payment_info_aggregate!

  """
  fetch data from the table: "service_provider_payment_info" using primary key columns
  """
  service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  fetch data from the table: "stripe_info"
  """
  stripe_info(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch aggregated fields from the table: "stripe_info"
  """
  stripe_info_aggregate(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): stripe_info_aggregate!

  """fetch data from the table: "stripe_info" using primary key columns"""
  stripe_info_by_pk(id: Int!): stripe_info

  """
  fetch data from the table: "subscriber"
  """
  subscriber(
    """distinct select on columns"""
    distinct_on: [subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriber_order_by!]

    """filter the rows returned"""
    where: subscriber_bool_exp
  ): [subscriber!]!

  """
  fetch aggregated fields from the table: "subscriber"
  """
  subscriber_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriber_order_by!]

    """filter the rows returned"""
    where: subscriber_bool_exp
  ): subscriber_aggregate!

  """fetch data from the table: "subscriber" using primary key columns"""
  subscriber_by_pk(id: Int!): subscriber

  """
  fetch data from the table: "topology.app_type"
  """
  topology_app_type(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch aggregated fields from the table: "topology.app_type"
  """
  topology_app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): topology_app_type_aggregate!

  """
  fetch data from the table: "topology.app_type" using primary key columns
  """
  topology_app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): topology_app_type

  """
  fetch data from the table: "topology.language"
  """
  topology_language(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch aggregated fields from the table: "topology.language"
  """
  topology_language_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): topology_language_aggregate!

  """
  fetch data from the table: "topology.language" using primary key columns
  """
  topology_language_by_pk(id: String!): topology_language

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user
}

"""
columns and relationships of "restaurant"
"""
type restaurant {
  accepted_payments(
    """JSON select path"""
    path: String
  ): jsonb
  approved: Boolean!

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """An array relationship"""
  delivery_drivers(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """An aggregate relationship"""
  delivery_drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """An object relationship"""
  description: translation
  description_id: Int
  firebase_id: String
  id: Int!
  image: String!
  language_id: String!
  location_gps: geography!
  location_text: String!
  name: String!

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String!

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """An aggregate relationship"""
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """An object relationship"""
  payment_info: service_provider_payment_info
  payment_info_id: Int

  """An array relationship"""
  restaurant_operators(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """An aggregate relationship"""
  restaurant_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """An array relationship"""
  reviews(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """An aggregate relationship"""
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!
  schedule(
    """JSON select path"""
    path: String
  ): jsonb
  self_delivery: Boolean!
  service_provider_type: String!

  """
  A computed field, executes function "special_items"
  """
  specials(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "restaurant"
"""
type restaurant_aggregate {
  aggregate: restaurant_aggregate_fields
  nodes: [restaurant!]!
}

"""
aggregate fields of "restaurant"
"""
type restaurant_aggregate_fields {
  avg: restaurant_avg_fields
  count(columns: [restaurant_select_column!], distinct: Boolean): Int!
  max: restaurant_max_fields
  min: restaurant_min_fields
  stddev: restaurant_stddev_fields
  stddev_pop: restaurant_stddev_pop_fields
  stddev_samp: restaurant_stddev_samp_fields
  sum: restaurant_sum_fields
  var_pop: restaurant_var_pop_fields
  var_samp: restaurant_var_samp_fields
  variance: restaurant_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input restaurant_append_input {
  accepted_payments: jsonb
  schedule: jsonb
  stripe_info: jsonb
}

"""aggregate avg on columns"""
type restaurant_avg_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant". All fields are combined with a logical 'AND'.
"""
input restaurant_bool_exp {
  _and: [restaurant_bool_exp!]
  _not: restaurant_bool_exp
  _or: [restaurant_bool_exp!]
  accepted_payments: jsonb_comparison_exp
  approved: Boolean_comparison_exp
  categories: restaurant_category_bool_exp
  categories_aggregate: restaurant_category_aggregate_bool_exp
  delivery_drivers: delivery_driver_bool_exp
  delivery_drivers_aggregate: delivery_driver_aggregate_bool_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  location_gps: geography_comparison_exp
  location_text: String_comparison_exp
  name: String_comparison_exp
  open_status: String_comparison_exp
  orders: restaurant_order_bool_exp
  orders_aggregate: restaurant_order_aggregate_bool_exp
  payment_info: service_provider_payment_info_bool_exp
  payment_info_id: Int_comparison_exp
  restaurant_operators: restaurant_operator_bool_exp
  restaurant_operators_aggregate: restaurant_operator_aggregate_bool_exp
  reviews: review_bool_exp
  reviews_aggregate: review_aggregate_bool_exp
  schedule: jsonb_comparison_exp
  self_delivery: Boolean_comparison_exp
  service_provider_type: String_comparison_exp
  specials: restaurant_item_bool_exp
  stripe_info: jsonb_comparison_exp
}

"""
columns and relationships of "restaurant_cart"
"""
type restaurant_cart {
  """
  A computed field, executes function "cost"
  """
  cost: money

  """An object relationship"""
  customer: customer!
  customer_id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """An object relationship"""
  restaurant: restaurant
  restaurant_id: Int
}

"""
aggregated selection of "restaurant_cart"
"""
type restaurant_cart_aggregate {
  aggregate: restaurant_cart_aggregate_fields
  nodes: [restaurant_cart!]!
}

"""
aggregate fields of "restaurant_cart"
"""
type restaurant_cart_aggregate_fields {
  avg: restaurant_cart_avg_fields
  count(columns: [restaurant_cart_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_max_fields
  min: restaurant_cart_min_fields
  stddev: restaurant_cart_stddev_fields
  stddev_pop: restaurant_cart_stddev_pop_fields
  stddev_samp: restaurant_cart_stddev_samp_fields
  sum: restaurant_cart_sum_fields
  var_pop: restaurant_cart_var_pop_fields
  var_samp: restaurant_cart_var_samp_fields
  variance: restaurant_cart_variance_fields
}

"""aggregate avg on columns"""
type restaurant_cart_avg_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant_cart". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_bool_exp {
  _and: [restaurant_cart_bool_exp!]
  _not: restaurant_cart_bool_exp
  _or: [restaurant_cart_bool_exp!]
  cost: money_comparison_exp
  customer: customer_bool_exp
  customer_id: Int_comparison_exp
  items: restaurant_cart_item_bool_exp
  items_aggregate: restaurant_cart_item_aggregate_bool_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_cart"
"""
enum restaurant_cart_constraint {
  """
  unique or primary key constraint on columns "customer_id"
  """
  restaurant_cart_pkey1
}

"""
input type for incrementing numeric columns in table "restaurant_cart"
"""
input restaurant_cart_inc_input {
  customer_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_cart"
"""
input restaurant_cart_insert_input {
  customer: customer_obj_rel_insert_input
  customer_id: Int
  items: restaurant_cart_item_arr_rel_insert_input
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""
columns and relationships of "restaurant_cart_item"
"""
type restaurant_cart_item {
  cost_per_one: money!
  customer_id: Int!
  id: Int!
  note: String
  quantity: Int!

  """An object relationship"""
  restaurant_cart: restaurant_cart!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!

  """{<option-id>:[<choice-id>]"""
  selected_options(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "restaurant_cart_item"
"""
type restaurant_cart_item_aggregate {
  aggregate: restaurant_cart_item_aggregate_fields
  nodes: [restaurant_cart_item!]!
}

input restaurant_cart_item_aggregate_bool_exp {
  count: restaurant_cart_item_aggregate_bool_exp_count
}

input restaurant_cart_item_aggregate_bool_exp_count {
  arguments: [restaurant_cart_item_select_column!]
  distinct: Boolean
  filter: restaurant_cart_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_cart_item"
"""
type restaurant_cart_item_aggregate_fields {
  avg: restaurant_cart_item_avg_fields
  count(columns: [restaurant_cart_item_select_column!], distinct: Boolean): Int!
  max: restaurant_cart_item_max_fields
  min: restaurant_cart_item_min_fields
  stddev: restaurant_cart_item_stddev_fields
  stddev_pop: restaurant_cart_item_stddev_pop_fields
  stddev_samp: restaurant_cart_item_stddev_samp_fields
  sum: restaurant_cart_item_sum_fields
  var_pop: restaurant_cart_item_var_pop_fields
  var_samp: restaurant_cart_item_var_samp_fields
  variance: restaurant_cart_item_variance_fields
}

"""
order by aggregate values of table "restaurant_cart_item"
"""
input restaurant_cart_item_aggregate_order_by {
  avg: restaurant_cart_item_avg_order_by
  count: order_by
  max: restaurant_cart_item_max_order_by
  min: restaurant_cart_item_min_order_by
  stddev: restaurant_cart_item_stddev_order_by
  stddev_pop: restaurant_cart_item_stddev_pop_order_by
  stddev_samp: restaurant_cart_item_stddev_samp_order_by
  sum: restaurant_cart_item_sum_order_by
  var_pop: restaurant_cart_item_var_pop_order_by
  var_samp: restaurant_cart_item_var_samp_order_by
  variance: restaurant_cart_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_cart_item"
"""
input restaurant_cart_item_arr_rel_insert_input {
  data: [restaurant_cart_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_cart_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_cart_item_avg_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by avg() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_avg_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_cart_item". All fields are combined with a logical 'AND'.
"""
input restaurant_cart_item_bool_exp {
  _and: [restaurant_cart_item_bool_exp!]
  _not: restaurant_cart_item_bool_exp
  _or: [restaurant_cart_item_bool_exp!]
  cost_per_one: money_comparison_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  quantity: Int_comparison_exp
  restaurant_cart: restaurant_cart_bool_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  selected_options: json_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_cart_item"
"""
enum restaurant_cart_item_constraint {
  """
  unique or primary key constraint on columns "restaurant_item_id", "customer_id"
  """
  restaurant_cart_item_customer_id_restaurant_item_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_cart_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_cart_item"
"""
input restaurant_cart_item_inc_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
input type for inserting data into table "restaurant_cart_item"
"""
input restaurant_cart_item_insert_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_cart: restaurant_cart_obj_rel_insert_input
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate max on columns"""
type restaurant_cart_item_max_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by max() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_max_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate min on columns"""
type restaurant_cart_item_min_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int
}

"""
order by min() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_min_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
response of any mutation on the table "restaurant_cart_item"
"""
type restaurant_cart_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart_item!]!
}

"""
on_conflict condition type for table "restaurant_cart_item"
"""
input restaurant_cart_item_on_conflict {
  constraint: restaurant_cart_item_constraint!
  update_columns: [restaurant_cart_item_update_column!]! = []
  where: restaurant_cart_item_bool_exp
}

"""Ordering options when selecting data from "restaurant_cart_item"."""
input restaurant_cart_item_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  note: order_by
  quantity: order_by
  restaurant_cart: restaurant_cart_order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  selected_options: order_by
}

"""primary key columns input for table: restaurant_cart_item"""
input restaurant_cart_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_cart_item"
"""
enum restaurant_cart_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

"""
input type for updating data in table "restaurant_cart_item"
"""
input restaurant_cart_item_set_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate stddev on columns"""
type restaurant_cart_item_stddev_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_item_stddev_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_item_stddev_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_stddev_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
Streaming cursor of the table "restaurant_cart_item"
"""
input restaurant_cart_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_item_stream_cursor_value_input {
  cost_per_one: money
  customer_id: Int
  id: Int
  note: String
  quantity: Int
  restaurant_item_id: Int

  """{<option-id>:[<choice-id>]"""
  selected_options: json
}

"""aggregate sum on columns"""
type restaurant_cart_item_sum_fields {
  cost_per_one: money
  customer_id: Int
  id: Int
  quantity: Int
  restaurant_item_id: Int
}

"""
order by sum() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_sum_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""
update columns of table "restaurant_cart_item"
"""
enum restaurant_cart_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  note

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  selected_options
}

input restaurant_cart_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_item_set_input
  where: restaurant_cart_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_item_var_pop_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_pop() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_var_pop_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_cart_item_var_samp_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by var_samp() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_var_samp_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate variance on columns"""
type restaurant_cart_item_variance_fields {
  cost_per_one: Float
  customer_id: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
}

"""
order by variance() on columns of table "restaurant_cart_item"
"""
input restaurant_cart_item_variance_order_by {
  cost_per_one: order_by
  customer_id: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
}

"""aggregate max on columns"""
type restaurant_cart_max_fields {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate min on columns"""
type restaurant_cart_min_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
response of any mutation on the table "restaurant_cart"
"""
type restaurant_cart_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_cart!]!
}

"""
input type for inserting object relation for remote table "restaurant_cart"
"""
input restaurant_cart_obj_rel_insert_input {
  data: restaurant_cart_insert_input!

  """upsert condition"""
  on_conflict: restaurant_cart_on_conflict
}

"""
on_conflict condition type for table "restaurant_cart"
"""
input restaurant_cart_on_conflict {
  constraint: restaurant_cart_constraint!
  update_columns: [restaurant_cart_update_column!]! = []
  where: restaurant_cart_bool_exp
}

"""Ordering options when selecting data from "restaurant_cart"."""
input restaurant_cart_order_by {
  cost: order_by
  customer: customer_order_by
  customer_id: order_by
  items_aggregate: restaurant_cart_item_aggregate_order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_cart"""
input restaurant_cart_pk_columns_input {
  customer_id: Int!
}

"""
select columns of table "restaurant_cart"
"""
enum restaurant_cart_select_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant_cart"
"""
input restaurant_cart_set_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_cart_stddev_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_cart_stddev_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_cart_stddev_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
Streaming cursor of the table "restaurant_cart"
"""
input restaurant_cart_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_cart_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_cart_stream_cursor_value_input {
  customer_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_cart_sum_fields {
  customer_id: Int
  restaurant_id: Int
}

"""
update columns of table "restaurant_cart"
"""
enum restaurant_cart_update_column {
  """column name"""
  customer_id

  """column name"""
  restaurant_id
}

input restaurant_cart_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_cart_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_cart_set_input
  where: restaurant_cart_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_cart_var_pop_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_cart_var_samp_fields {
  customer_id: Float
  restaurant_id: Float
}

"""aggregate variance on columns"""
type restaurant_cart_variance_fields {
  customer_id: Float
  restaurant_id: Float
}

"""
columns and relationships of "restaurant_category"
"""
type restaurant_category {
  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """An object relationship"""
  name: translation!
  name_id: Int!
  position: Int!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!
  schedule_id: Int
}

"""
aggregated selection of "restaurant_category"
"""
type restaurant_category_aggregate {
  aggregate: restaurant_category_aggregate_fields
  nodes: [restaurant_category!]!
}

input restaurant_category_aggregate_bool_exp {
  count: restaurant_category_aggregate_bool_exp_count
}

input restaurant_category_aggregate_bool_exp_count {
  arguments: [restaurant_category_select_column!]
  distinct: Boolean
  filter: restaurant_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_category"
"""
type restaurant_category_aggregate_fields {
  avg: restaurant_category_avg_fields
  count(columns: [restaurant_category_select_column!], distinct: Boolean): Int!
  max: restaurant_category_max_fields
  min: restaurant_category_min_fields
  stddev: restaurant_category_stddev_fields
  stddev_pop: restaurant_category_stddev_pop_fields
  stddev_samp: restaurant_category_stddev_samp_fields
  sum: restaurant_category_sum_fields
  var_pop: restaurant_category_var_pop_fields
  var_samp: restaurant_category_var_samp_fields
  variance: restaurant_category_variance_fields
}

"""
order by aggregate values of table "restaurant_category"
"""
input restaurant_category_aggregate_order_by {
  avg: restaurant_category_avg_order_by
  count: order_by
  max: restaurant_category_max_order_by
  min: restaurant_category_min_order_by
  stddev: restaurant_category_stddev_order_by
  stddev_pop: restaurant_category_stddev_pop_order_by
  stddev_samp: restaurant_category_stddev_samp_order_by
  sum: restaurant_category_sum_order_by
  var_pop: restaurant_category_var_pop_order_by
  var_samp: restaurant_category_var_samp_order_by
  variance: restaurant_category_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_category"
"""
input restaurant_category_arr_rel_insert_input {
  data: [restaurant_category_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""aggregate avg on columns"""
type restaurant_category_avg_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by avg() on columns of table "restaurant_category"
"""
input restaurant_category_avg_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_category". All fields are combined with a logical 'AND'.
"""
input restaurant_category_bool_exp {
  _and: [restaurant_category_bool_exp!]
  _not: restaurant_category_bool_exp
  _or: [restaurant_category_bool_exp!]
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_bool_exp
  items_aggregate: restaurant_item_aggregate_bool_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  position: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  schedule_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_category"
"""
enum restaurant_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_category_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_category"
"""
input restaurant_category_inc_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
input type for inserting data into table "restaurant_category"
"""
input restaurant_category_insert_input {
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  items: restaurant_item_arr_rel_insert_input
  name: translation_obj_rel_insert_input
  name_id: Int
  position: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate max on columns"""
type restaurant_category_max_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by max() on columns of table "restaurant_category"
"""
input restaurant_category_max_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate min on columns"""
type restaurant_category_min_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by min() on columns of table "restaurant_category"
"""
input restaurant_category_min_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
response of any mutation on the table "restaurant_category"
"""
type restaurant_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_category!]!
}

"""
input type for inserting object relation for remote table "restaurant_category"
"""
input restaurant_category_obj_rel_insert_input {
  data: restaurant_category_insert_input!

  """upsert condition"""
  on_conflict: restaurant_category_on_conflict
}

"""
on_conflict condition type for table "restaurant_category"
"""
input restaurant_category_on_conflict {
  constraint: restaurant_category_constraint!
  update_columns: [restaurant_category_update_column!]! = []
  where: restaurant_category_bool_exp
}

"""Ordering options when selecting data from "restaurant_category"."""
input restaurant_category_order_by {
  description: translation_order_by
  description_id: order_by
  id: order_by
  items_aggregate: restaurant_item_aggregate_order_by
  name: translation_order_by
  name_id: order_by
  position: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""primary key columns input for table: restaurant_category"""
input restaurant_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_category"
"""
enum restaurant_category_select_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

"""
input type for updating data in table "restaurant_category"
"""
input restaurant_category_set_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate stddev on columns"""
type restaurant_category_stddev_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_category_stddev_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_category_stddev_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_category"
"""
input restaurant_category_stddev_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
Streaming cursor of the table "restaurant_category"
"""
input restaurant_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_category_stream_cursor_value_input {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""aggregate sum on columns"""
type restaurant_category_sum_fields {
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
  schedule_id: Int
}

"""
order by sum() on columns of table "restaurant_category"
"""
input restaurant_category_sum_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
update columns of table "restaurant_category"
"""
enum restaurant_category_update_column {
  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  schedule_id
}

input restaurant_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_category_set_input
  where: restaurant_category_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_category_var_pop_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_pop() on columns of table "restaurant_category"
"""
input restaurant_category_var_pop_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_category_var_samp_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by var_samp() on columns of table "restaurant_category"
"""
input restaurant_category_var_samp_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""aggregate variance on columns"""
type restaurant_category_variance_fields {
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
  schedule_id: Float
}

"""
order by variance() on columns of table "restaurant_category"
"""
input restaurant_category_variance_order_by {
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  schedule_id: order_by
}

"""
columns and relationships of "restaurant_choice"
"""
type restaurant_choice {
  available: Boolean!
  cost: money!
  id: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant_choice"
"""
type restaurant_choice_aggregate {
  aggregate: restaurant_choice_aggregate_fields
  nodes: [restaurant_choice!]!
}

input restaurant_choice_aggregate_bool_exp {
  bool_and: restaurant_choice_aggregate_bool_exp_bool_and
  bool_or: restaurant_choice_aggregate_bool_exp_bool_or
  count: restaurant_choice_aggregate_bool_exp_count
}

input restaurant_choice_aggregate_bool_exp_bool_and {
  arguments: restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_choice_aggregate_bool_exp_bool_or {
  arguments: restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_choice_aggregate_bool_exp_count {
  arguments: [restaurant_choice_select_column!]
  distinct: Boolean
  filter: restaurant_choice_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_choice"
"""
type restaurant_choice_aggregate_fields {
  avg: restaurant_choice_avg_fields
  count(columns: [restaurant_choice_select_column!], distinct: Boolean): Int!
  max: restaurant_choice_max_fields
  min: restaurant_choice_min_fields
  stddev: restaurant_choice_stddev_fields
  stddev_pop: restaurant_choice_stddev_pop_fields
  stddev_samp: restaurant_choice_stddev_samp_fields
  sum: restaurant_choice_sum_fields
  var_pop: restaurant_choice_var_pop_fields
  var_samp: restaurant_choice_var_samp_fields
  variance: restaurant_choice_variance_fields
}

"""
order by aggregate values of table "restaurant_choice"
"""
input restaurant_choice_aggregate_order_by {
  avg: restaurant_choice_avg_order_by
  count: order_by
  max: restaurant_choice_max_order_by
  min: restaurant_choice_min_order_by
  stddev: restaurant_choice_stddev_order_by
  stddev_pop: restaurant_choice_stddev_pop_order_by
  stddev_samp: restaurant_choice_stddev_samp_order_by
  sum: restaurant_choice_sum_order_by
  var_pop: restaurant_choice_var_pop_order_by
  var_samp: restaurant_choice_var_samp_order_by
  variance: restaurant_choice_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_choice"
"""
input restaurant_choice_arr_rel_insert_input {
  data: [restaurant_choice_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_choice_on_conflict
}

"""aggregate avg on columns"""
type restaurant_choice_avg_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_choice"
"""
input restaurant_choice_avg_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_choice". All fields are combined with a logical 'AND'.
"""
input restaurant_choice_bool_exp {
  _and: [restaurant_choice_bool_exp!]
  _not: restaurant_choice_bool_exp
  _or: [restaurant_choice_bool_exp!]
  available: Boolean_comparison_exp
  cost: money_comparison_exp
  id: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_option_choice_map_bool_exp
  options_aggregate: restaurant_option_choice_map_aggregate_bool_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_choice"
"""
enum restaurant_choice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_choice_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_choice"
"""
input restaurant_choice_inc_input {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_choice"
"""
input restaurant_choice_insert_input {
  available: Boolean
  cost: money
  id: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_option_choice_map_arr_rel_insert_input
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_choice_max_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant_choice"
"""
input restaurant_choice_max_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_choice_min_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant_choice"
"""
input restaurant_choice_min_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant_choice"
"""
type restaurant_choice_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_choice!]!
}

"""
on_conflict condition type for table "restaurant_choice"
"""
input restaurant_choice_on_conflict {
  constraint: restaurant_choice_constraint!
  update_columns: [restaurant_choice_update_column!]! = []
  where: restaurant_choice_bool_exp
}

"""Ordering options when selecting data from "restaurant_choice"."""
input restaurant_choice_order_by {
  available: order_by
  cost: order_by
  id: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_option_choice_map_aggregate_order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_choice"""
input restaurant_choice_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_choice"
"""
enum restaurant_choice_select_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  restaurant_id
}

"""
select "restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant_choice"
"""
enum restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  available
}

"""
select "restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant_choice"
"""
enum restaurant_choice_select_column_restaurant_choice_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  available
}

"""
input type for updating data in table "restaurant_choice"
"""
input restaurant_choice_set_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_choice_stddev_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_choice_stddev_pop_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_choice_stddev_samp_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_choice"
"""
input restaurant_choice_stddev_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_choice"
"""
input restaurant_choice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_choice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_choice_stream_cursor_value_input {
  available: Boolean
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_choice_sum_fields {
  cost: money
  id: Int
  name_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_choice"
"""
input restaurant_choice_sum_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_choice"
"""
enum restaurant_choice_update_column {
  """column name"""
  available

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  name_id

  """column name"""
  restaurant_id
}

input restaurant_choice_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_choice_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_choice_set_input
  where: restaurant_choice_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_choice_var_pop_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_choice"
"""
input restaurant_choice_var_pop_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_choice_var_samp_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_choice"
"""
input restaurant_choice_var_samp_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_choice_variance_fields {
  cost: Float
  id: Float
  name_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_choice"
"""
input restaurant_choice_variance_order_by {
  cost: order_by
  id: order_by
  name_id: order_by
  restaurant_id: order_by
}

"""
unique or primary key constraints on table "restaurant"
"""
enum restaurant_constraint {
  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_firebase_id_key

  """
  unique or primary key constraint on columns "payment_info_id"
  """
  restaurant_payment_info_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input restaurant_delete_at_path_input {
  accepted_payments: [String!]
  schedule: [String!]
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input restaurant_delete_elem_input {
  accepted_payments: Int
  schedule: Int
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input restaurant_delete_key_input {
  accepted_payments: String
  schedule: String
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "restaurant"
"""
input restaurant_inc_input {
  description_id: Int
  id: Int
  payment_info_id: Int
}

"""
input type for inserting data into table "restaurant"
"""
input restaurant_insert_input {
  accepted_payments: jsonb
  approved: Boolean
  categories: restaurant_category_arr_rel_insert_input
  delivery_drivers: delivery_driver_arr_rel_insert_input
  description: translation_obj_rel_insert_input
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  orders: restaurant_order_arr_rel_insert_input
  payment_info: service_provider_payment_info_obj_rel_insert_input
  payment_info_id: Int
  restaurant_operators: restaurant_operator_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""
columns and relationships of "restaurant_item"
"""
type restaurant_item {
  archived: Boolean!
  available: Boolean!

  """An object relationship"""
  category: restaurant_category
  category_id: Int
  cost: money!

  """An object relationship"""
  description: translation
  description_id: Int
  id: Int!
  image: String

  """daily, special"""
  item_type: String!

  """An object relationship"""
  name: translation!
  name_id: Int!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  position: Int!

  """An object relationship"""
  restaurant: restaurant
  restaurant_id: Int!
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
aggregated selection of "restaurant_item"
"""
type restaurant_item_aggregate {
  aggregate: restaurant_item_aggregate_fields
  nodes: [restaurant_item!]!
}

input restaurant_item_aggregate_bool_exp {
  bool_and: restaurant_item_aggregate_bool_exp_bool_and
  bool_or: restaurant_item_aggregate_bool_exp_bool_or
  count: restaurant_item_aggregate_bool_exp_count
}

input restaurant_item_aggregate_bool_exp_bool_and {
  arguments: restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_item_aggregate_bool_exp_bool_or {
  arguments: restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_item_aggregate_bool_exp_count {
  arguments: [restaurant_item_select_column!]
  distinct: Boolean
  filter: restaurant_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_item"
"""
type restaurant_item_aggregate_fields {
  avg: restaurant_item_avg_fields
  count(columns: [restaurant_item_select_column!], distinct: Boolean): Int!
  max: restaurant_item_max_fields
  min: restaurant_item_min_fields
  stddev: restaurant_item_stddev_fields
  stddev_pop: restaurant_item_stddev_pop_fields
  stddev_samp: restaurant_item_stddev_samp_fields
  sum: restaurant_item_sum_fields
  var_pop: restaurant_item_var_pop_fields
  var_samp: restaurant_item_var_samp_fields
  variance: restaurant_item_variance_fields
}

"""
order by aggregate values of table "restaurant_item"
"""
input restaurant_item_aggregate_order_by {
  avg: restaurant_item_avg_order_by
  count: order_by
  max: restaurant_item_max_order_by
  min: restaurant_item_min_order_by
  stddev: restaurant_item_stddev_order_by
  stddev_pop: restaurant_item_stddev_pop_order_by
  stddev_samp: restaurant_item_stddev_samp_order_by
  sum: restaurant_item_sum_order_by
  var_pop: restaurant_item_var_pop_order_by
  var_samp: restaurant_item_var_samp_order_by
  variance: restaurant_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_item"
"""
input restaurant_item_arr_rel_insert_input {
  data: [restaurant_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_avg_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_item"
"""
input restaurant_item_avg_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_item". All fields are combined with a logical 'AND'.
"""
input restaurant_item_bool_exp {
  _and: [restaurant_item_bool_exp!]
  _not: restaurant_item_bool_exp
  _or: [restaurant_item_bool_exp!]
  archived: Boolean_comparison_exp
  available: Boolean_comparison_exp
  category: restaurant_category_bool_exp
  category_id: Int_comparison_exp
  cost: money_comparison_exp
  description: translation_bool_exp
  description_id: Int_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  item_type: String_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  options: restaurant_item_option_map_bool_exp
  options_aggregate: restaurant_item_option_map_aggregate_bool_exp
  position: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  special_period_end: timestamptz_comparison_exp
  special_period_start: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_item"
"""
enum restaurant_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_item"
"""
input restaurant_item_inc_input {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_item"
"""
input restaurant_item_insert_input {
  archived: Boolean
  available: Boolean
  category: restaurant_category_obj_rel_insert_input
  category_id: Int
  cost: money
  description: translation_obj_rel_insert_input
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name: translation_obj_rel_insert_input
  name_id: Int
  options: restaurant_item_option_map_arr_rel_insert_input
  position: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate max on columns"""
type restaurant_item_max_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by max() on columns of table "restaurant_item"
"""
input restaurant_item_max_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  image: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""aggregate min on columns"""
type restaurant_item_min_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""
order by min() on columns of table "restaurant_item"
"""
input restaurant_item_min_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  image: order_by

  """daily, special"""
  item_type: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""
response of any mutation on the table "restaurant_item"
"""
type restaurant_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item!]!
}

"""
input type for inserting object relation for remote table "restaurant_item"
"""
input restaurant_item_obj_rel_insert_input {
  data: restaurant_item_insert_input!

  """upsert condition"""
  on_conflict: restaurant_item_on_conflict
}

"""
on_conflict condition type for table "restaurant_item"
"""
input restaurant_item_on_conflict {
  constraint: restaurant_item_constraint!
  update_columns: [restaurant_item_update_column!]! = []
  where: restaurant_item_bool_exp
}

"""
columns and relationships of "restaurant_item_option_map"
"""
type restaurant_item_option_map {
  id: Int!
  item_id: Int!

  """An array relationship"""
  item_options(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """An aggregate relationship"""
  item_options_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!
  option_id: Int!

  """An object relationship"""
  restaurant: restaurant
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant_item_option_map"
"""
type restaurant_item_option_map_aggregate {
  aggregate: restaurant_item_option_map_aggregate_fields
  nodes: [restaurant_item_option_map!]!
}

input restaurant_item_option_map_aggregate_bool_exp {
  count: restaurant_item_option_map_aggregate_bool_exp_count
}

input restaurant_item_option_map_aggregate_bool_exp_count {
  arguments: [restaurant_item_option_map_select_column!]
  distinct: Boolean
  filter: restaurant_item_option_map_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_item_option_map"
"""
type restaurant_item_option_map_aggregate_fields {
  avg: restaurant_item_option_map_avg_fields
  count(columns: [restaurant_item_option_map_select_column!], distinct: Boolean): Int!
  max: restaurant_item_option_map_max_fields
  min: restaurant_item_option_map_min_fields
  stddev: restaurant_item_option_map_stddev_fields
  stddev_pop: restaurant_item_option_map_stddev_pop_fields
  stddev_samp: restaurant_item_option_map_stddev_samp_fields
  sum: restaurant_item_option_map_sum_fields
  var_pop: restaurant_item_option_map_var_pop_fields
  var_samp: restaurant_item_option_map_var_samp_fields
  variance: restaurant_item_option_map_variance_fields
}

"""
order by aggregate values of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_aggregate_order_by {
  avg: restaurant_item_option_map_avg_order_by
  count: order_by
  max: restaurant_item_option_map_max_order_by
  min: restaurant_item_option_map_min_order_by
  stddev: restaurant_item_option_map_stddev_order_by
  stddev_pop: restaurant_item_option_map_stddev_pop_order_by
  stddev_samp: restaurant_item_option_map_stddev_samp_order_by
  sum: restaurant_item_option_map_sum_order_by
  var_pop: restaurant_item_option_map_var_pop_order_by
  var_samp: restaurant_item_option_map_var_samp_order_by
  variance: restaurant_item_option_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_item_option_map"
"""
input restaurant_item_option_map_arr_rel_insert_input {
  data: [restaurant_item_option_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_item_option_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_item_option_map_avg_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_avg_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_item_option_map". All fields are combined with a logical 'AND'.
"""
input restaurant_item_option_map_bool_exp {
  _and: [restaurant_item_option_map_bool_exp!]
  _not: restaurant_item_option_map_bool_exp
  _or: [restaurant_item_option_map_bool_exp!]
  id: Int_comparison_exp
  item_id: Int_comparison_exp
  item_options: restaurant_option_bool_exp
  item_options_aggregate: restaurant_option_aggregate_bool_exp
  option_id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "item_id"
  """
  restaurant_item_option_map_item_id_option_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_item_option_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_item_option_map"
"""
input restaurant_item_option_map_inc_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_item_option_map"
"""
input restaurant_item_option_map_insert_input {
  id: Int
  item_id: Int
  item_options: restaurant_option_arr_rel_insert_input
  option_id: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_item_option_map_max_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_max_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_item_option_map_min_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_min_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant_item_option_map"
"""
type restaurant_item_option_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_item_option_map!]!
}

"""
on_conflict condition type for table "restaurant_item_option_map"
"""
input restaurant_item_option_map_on_conflict {
  constraint: restaurant_item_option_map_constraint!
  update_columns: [restaurant_item_option_map_update_column!]! = []
  where: restaurant_item_option_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant_item_option_map".
"""
input restaurant_item_option_map_order_by {
  id: order_by
  item_id: order_by
  item_options_aggregate: restaurant_option_aggregate_order_by
  option_id: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_item_option_map"""
input restaurant_item_option_map_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_select_column {
  """column name"""
  id

  """column name"""
  item_id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant_item_option_map"
"""
input restaurant_item_option_map_set_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_item_option_map_stddev_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_option_map_stddev_pop_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_option_map_stddev_samp_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_item_option_map"
"""
input restaurant_item_option_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_option_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_option_map_stream_cursor_value_input {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_item_option_map_sum_fields {
  id: Int
  item_id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_sum_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_item_option_map"
"""
enum restaurant_item_option_map_update_column {
  """column name"""
  id

  """column name"""
  item_id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

input restaurant_item_option_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_option_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_option_map_set_input
  where: restaurant_item_option_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_option_map_var_pop_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_var_pop_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_option_map_var_samp_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_var_samp_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_option_map_variance_fields {
  id: Float
  item_id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_item_option_map"
"""
input restaurant_item_option_map_variance_order_by {
  id: order_by
  item_id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""Ordering options when selecting data from "restaurant_item"."""
input restaurant_item_order_by {
  archived: order_by
  available: order_by
  category: restaurant_category_order_by
  category_id: order_by
  cost: order_by
  description: translation_order_by
  description_id: order_by
  id: order_by
  image: order_by
  item_type: order_by
  name: translation_order_by
  name_id: order_by
  options_aggregate: restaurant_item_option_map_aggregate_order_by
  position: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  special_period_end: order_by
  special_period_start: order_by
}

"""primary key columns input for table: restaurant_item"""
input restaurant_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_item"
"""
enum restaurant_item_select_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

"""
select "restaurant_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant_item"
"""
enum restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived

  """column name"""
  available
}

"""
select "restaurant_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant_item"
"""
enum restaurant_item_select_column_restaurant_item_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived

  """column name"""
  available
}

"""
input type for updating data in table "restaurant_item"
"""
input restaurant_item_set_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate stddev on columns"""
type restaurant_item_stddev_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_item_stddev_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_item_stddev_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_item"
"""
input restaurant_item_stddev_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_item"
"""
input restaurant_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_item_stream_cursor_value_input {
  archived: Boolean
  available: Boolean
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  image: String

  """daily, special"""
  item_type: String
  name_id: Int
  position: Int
  restaurant_id: Int
  special_period_end: timestamptz
  special_period_start: timestamptz
}

"""aggregate sum on columns"""
type restaurant_item_sum_fields {
  category_id: Int
  cost: money
  description_id: Int
  id: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_item"
"""
input restaurant_item_sum_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_item"
"""
enum restaurant_item_update_column {
  """column name"""
  archived

  """column name"""
  available

  """column name"""
  category_id

  """column name"""
  cost

  """column name"""
  description_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  item_type

  """column name"""
  name_id

  """column name"""
  position

  """column name"""
  restaurant_id

  """column name"""
  special_period_end

  """column name"""
  special_period_start
}

input restaurant_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_item_set_input
  where: restaurant_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_item_var_pop_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_item"
"""
input restaurant_item_var_pop_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_item_var_samp_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_item"
"""
input restaurant_item_var_samp_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_item_variance_fields {
  category_id: Float
  cost: Float
  description_id: Float
  id: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_item"
"""
input restaurant_item_variance_order_by {
  category_id: order_by
  cost: order_by
  description_id: order_by
  id: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate max on columns"""
type restaurant_max_fields {
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type restaurant_min_fields {
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "restaurant"
"""
type restaurant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant!]!
}

"""
input type for inserting object relation for remote table "restaurant"
"""
input restaurant_obj_rel_insert_input {
  data: restaurant_insert_input!

  """upsert condition"""
  on_conflict: restaurant_on_conflict
}

"""
on_conflict condition type for table "restaurant"
"""
input restaurant_on_conflict {
  constraint: restaurant_constraint!
  update_columns: [restaurant_update_column!]! = []
  where: restaurant_bool_exp
}

"""
columns and relationships of "restaurant_operator"
"""
type restaurant_operator {
  app_version: String
  current_gps: geography
  delivery_driver_type: String!
  id: Int!

  """
  A computed field, executes function "restaurant_operator_notification_token"
  """
  notification_token: String
  owner: Boolean!

  """An object relationship"""
  restaurant: restaurant
  restaurant_id: Int!

  """awaiting_approval,authorized,banned"""
  status: String!

  """An object relationship"""
  user: user!
  user_id: Int!
}

"""
aggregated selection of "restaurant_operator"
"""
type restaurant_operator_aggregate {
  aggregate: restaurant_operator_aggregate_fields
  nodes: [restaurant_operator!]!
}

input restaurant_operator_aggregate_bool_exp {
  bool_and: restaurant_operator_aggregate_bool_exp_bool_and
  bool_or: restaurant_operator_aggregate_bool_exp_bool_or
  count: restaurant_operator_aggregate_bool_exp_count
}

input restaurant_operator_aggregate_bool_exp_bool_and {
  arguments: restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_operator_aggregate_bool_exp_bool_or {
  arguments: restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_operator_aggregate_bool_exp_count {
  arguments: [restaurant_operator_select_column!]
  distinct: Boolean
  filter: restaurant_operator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_operator"
"""
type restaurant_operator_aggregate_fields {
  avg: restaurant_operator_avg_fields
  count(columns: [restaurant_operator_select_column!], distinct: Boolean): Int!
  max: restaurant_operator_max_fields
  min: restaurant_operator_min_fields
  stddev: restaurant_operator_stddev_fields
  stddev_pop: restaurant_operator_stddev_pop_fields
  stddev_samp: restaurant_operator_stddev_samp_fields
  sum: restaurant_operator_sum_fields
  var_pop: restaurant_operator_var_pop_fields
  var_samp: restaurant_operator_var_samp_fields
  variance: restaurant_operator_variance_fields
}

"""
order by aggregate values of table "restaurant_operator"
"""
input restaurant_operator_aggregate_order_by {
  avg: restaurant_operator_avg_order_by
  count: order_by
  max: restaurant_operator_max_order_by
  min: restaurant_operator_min_order_by
  stddev: restaurant_operator_stddev_order_by
  stddev_pop: restaurant_operator_stddev_pop_order_by
  stddev_samp: restaurant_operator_stddev_samp_order_by
  sum: restaurant_operator_sum_order_by
  var_pop: restaurant_operator_var_pop_order_by
  var_samp: restaurant_operator_var_samp_order_by
  variance: restaurant_operator_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_operator"
"""
input restaurant_operator_arr_rel_insert_input {
  data: [restaurant_operator_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_operator_on_conflict
}

"""aggregate avg on columns"""
type restaurant_operator_avg_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "restaurant_operator"
"""
input restaurant_operator_avg_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_operator". All fields are combined with a logical 'AND'.
"""
input restaurant_operator_bool_exp {
  _and: [restaurant_operator_bool_exp!]
  _not: restaurant_operator_bool_exp
  _or: [restaurant_operator_bool_exp!]
  app_version: String_comparison_exp
  current_gps: geography_comparison_exp
  delivery_driver_type: String_comparison_exp
  id: Int_comparison_exp
  notification_token: String_comparison_exp
  owner: Boolean_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  status: String_comparison_exp
  user: user_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_operator"
"""
enum restaurant_operator_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_operator_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  restaurant_operator_user_id_key
}

"""
input type for incrementing numeric columns in table "restaurant_operator"
"""
input restaurant_operator_inc_input {
  id: Int
  restaurant_id: Int
  user_id: Int
}

"""
input type for inserting data into table "restaurant_operator"
"""
input restaurant_operator_insert_input {
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  owner: Boolean
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user: user_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type restaurant_operator_max_fields {
  app_version: String
  delivery_driver_type: String
  id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by max() on columns of table "restaurant_operator"
"""
input restaurant_operator_max_order_by {
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type restaurant_operator_min_fields {
  app_version: String
  delivery_driver_type: String
  id: Int
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""
order by min() on columns of table "restaurant_operator"
"""
input restaurant_operator_min_order_by {
  app_version: order_by
  delivery_driver_type: order_by
  id: order_by
  restaurant_id: order_by

  """awaiting_approval,authorized,banned"""
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "restaurant_operator"
"""
type restaurant_operator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_operator!]!
}

"""
input type for inserting object relation for remote table "restaurant_operator"
"""
input restaurant_operator_obj_rel_insert_input {
  data: restaurant_operator_insert_input!

  """upsert condition"""
  on_conflict: restaurant_operator_on_conflict
}

"""
on_conflict condition type for table "restaurant_operator"
"""
input restaurant_operator_on_conflict {
  constraint: restaurant_operator_constraint!
  update_columns: [restaurant_operator_update_column!]! = []
  where: restaurant_operator_bool_exp
}

"""Ordering options when selecting data from "restaurant_operator"."""
input restaurant_operator_order_by {
  app_version: order_by
  current_gps: order_by
  delivery_driver_type: order_by
  id: order_by
  notification_token: order_by
  owner: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  status: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: restaurant_operator"""
input restaurant_operator_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_operator"
"""
enum restaurant_operator_select_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant_operator"
"""
enum restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  owner
}

"""
select "restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant_operator"
"""
enum restaurant_operator_select_column_restaurant_operator_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  owner
}

"""
input type for updating data in table "restaurant_operator"
"""
input restaurant_operator_set_input {
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate stddev on columns"""
type restaurant_operator_stddev_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_operator_stddev_pop_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_pop_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_operator_stddev_samp_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_operator"
"""
input restaurant_operator_stddev_samp_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "restaurant_operator"
"""
input restaurant_operator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_operator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_operator_stream_cursor_value_input {
  app_version: String
  current_gps: geography
  delivery_driver_type: String
  id: Int
  owner: Boolean
  restaurant_id: Int

  """awaiting_approval,authorized,banned"""
  status: String
  user_id: Int
}

"""aggregate sum on columns"""
type restaurant_operator_sum_fields {
  id: Int
  restaurant_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "restaurant_operator"
"""
input restaurant_operator_sum_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
update columns of table "restaurant_operator"
"""
enum restaurant_operator_update_column {
  """column name"""
  app_version

  """column name"""
  current_gps

  """column name"""
  delivery_driver_type

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  restaurant_id

  """column name"""
  status

  """column name"""
  user_id
}

input restaurant_operator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_operator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_operator_set_input
  where: restaurant_operator_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_operator_var_pop_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "restaurant_operator"
"""
input restaurant_operator_var_pop_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_operator_var_samp_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "restaurant_operator"
"""
input restaurant_operator_var_samp_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type restaurant_operator_variance_fields {
  id: Float
  restaurant_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "restaurant_operator"
"""
input restaurant_operator_variance_order_by {
  id: order_by
  restaurant_id: order_by
  user_id: order_by
}

"""
columns and relationships of "restaurant_option"
"""
type restaurant_option {
  """An array relationship"""
  choices(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """An aggregate relationship"""
  choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!
  cost_per_extra: money!
  free_choice: Int!
  id: Int!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!
  maximum_choice: Int!
  minimum_choice: Int!

  """An object relationship"""
  name: translation!
  name_id: Int!
  option_type: String!
  position: Int!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant_option"
"""
type restaurant_option_aggregate {
  aggregate: restaurant_option_aggregate_fields
  nodes: [restaurant_option!]!
}

input restaurant_option_aggregate_bool_exp {
  count: restaurant_option_aggregate_bool_exp_count
}

input restaurant_option_aggregate_bool_exp_count {
  arguments: [restaurant_option_select_column!]
  distinct: Boolean
  filter: restaurant_option_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_option"
"""
type restaurant_option_aggregate_fields {
  avg: restaurant_option_avg_fields
  count(columns: [restaurant_option_select_column!], distinct: Boolean): Int!
  max: restaurant_option_max_fields
  min: restaurant_option_min_fields
  stddev: restaurant_option_stddev_fields
  stddev_pop: restaurant_option_stddev_pop_fields
  stddev_samp: restaurant_option_stddev_samp_fields
  sum: restaurant_option_sum_fields
  var_pop: restaurant_option_var_pop_fields
  var_samp: restaurant_option_var_samp_fields
  variance: restaurant_option_variance_fields
}

"""
order by aggregate values of table "restaurant_option"
"""
input restaurant_option_aggregate_order_by {
  avg: restaurant_option_avg_order_by
  count: order_by
  max: restaurant_option_max_order_by
  min: restaurant_option_min_order_by
  stddev: restaurant_option_stddev_order_by
  stddev_pop: restaurant_option_stddev_pop_order_by
  stddev_samp: restaurant_option_stddev_samp_order_by
  sum: restaurant_option_sum_order_by
  var_pop: restaurant_option_var_pop_order_by
  var_samp: restaurant_option_var_samp_order_by
  variance: restaurant_option_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_option"
"""
input restaurant_option_arr_rel_insert_input {
  data: [restaurant_option_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_avg_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_option"
"""
input restaurant_option_avg_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_option". All fields are combined with a logical 'AND'.
"""
input restaurant_option_bool_exp {
  _and: [restaurant_option_bool_exp!]
  _not: restaurant_option_bool_exp
  _or: [restaurant_option_bool_exp!]
  choices: restaurant_option_choice_map_bool_exp
  choices_aggregate: restaurant_option_choice_map_aggregate_bool_exp
  cost_per_extra: money_comparison_exp
  free_choice: Int_comparison_exp
  id: Int_comparison_exp
  items: restaurant_item_option_map_bool_exp
  items_aggregate: restaurant_item_option_map_aggregate_bool_exp
  maximum_choice: Int_comparison_exp
  minimum_choice: Int_comparison_exp
  name: translation_bool_exp
  name_id: Int_comparison_exp
  option_type: String_comparison_exp
  position: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
columns and relationships of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map {
  choice_id: Int!
  id: Int!

  """An array relationship"""
  option_choices(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """An aggregate relationship"""
  option_choices_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!
  option_id: Int!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!
}

"""
aggregated selection of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_aggregate {
  aggregate: restaurant_option_choice_map_aggregate_fields
  nodes: [restaurant_option_choice_map!]!
}

input restaurant_option_choice_map_aggregate_bool_exp {
  count: restaurant_option_choice_map_aggregate_bool_exp_count
}

input restaurant_option_choice_map_aggregate_bool_exp_count {
  arguments: [restaurant_option_choice_map_select_column!]
  distinct: Boolean
  filter: restaurant_option_choice_map_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_aggregate_fields {
  avg: restaurant_option_choice_map_avg_fields
  count(columns: [restaurant_option_choice_map_select_column!], distinct: Boolean): Int!
  max: restaurant_option_choice_map_max_fields
  min: restaurant_option_choice_map_min_fields
  stddev: restaurant_option_choice_map_stddev_fields
  stddev_pop: restaurant_option_choice_map_stddev_pop_fields
  stddev_samp: restaurant_option_choice_map_stddev_samp_fields
  sum: restaurant_option_choice_map_sum_fields
  var_pop: restaurant_option_choice_map_var_pop_fields
  var_samp: restaurant_option_choice_map_var_samp_fields
  variance: restaurant_option_choice_map_variance_fields
}

"""
order by aggregate values of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_aggregate_order_by {
  avg: restaurant_option_choice_map_avg_order_by
  count: order_by
  max: restaurant_option_choice_map_max_order_by
  min: restaurant_option_choice_map_min_order_by
  stddev: restaurant_option_choice_map_stddev_order_by
  stddev_pop: restaurant_option_choice_map_stddev_pop_order_by
  stddev_samp: restaurant_option_choice_map_stddev_samp_order_by
  sum: restaurant_option_choice_map_sum_order_by
  var_pop: restaurant_option_choice_map_var_pop_order_by
  var_samp: restaurant_option_choice_map_var_samp_order_by
  variance: restaurant_option_choice_map_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_arr_rel_insert_input {
  data: [restaurant_option_choice_map_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_option_choice_map_on_conflict
}

"""aggregate avg on columns"""
type restaurant_option_choice_map_avg_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by avg() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_avg_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_option_choice_map".
All fields are combined with a logical 'AND'.
"""
input restaurant_option_choice_map_bool_exp {
  _and: [restaurant_option_choice_map_bool_exp!]
  _not: restaurant_option_choice_map_bool_exp
  _or: [restaurant_option_choice_map_bool_exp!]
  choice_id: Int_comparison_exp
  id: Int_comparison_exp
  option_choices: restaurant_choice_bool_exp
  option_choices_aggregate: restaurant_choice_aggregate_bool_exp
  option_id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_constraint {
  """
  unique or primary key constraint on columns "option_id", "choice_id"
  """
  restaurant_option_choice_map_option_id_choice_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_option_choice_map_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_inc_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_insert_input {
  choice_id: Int
  id: Int
  option_choices: restaurant_choice_arr_rel_insert_input
  option_id: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_option_choice_map_max_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_max_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_option_choice_map_min_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_min_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant_option_choice_map"
"""
type restaurant_option_choice_map_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option_choice_map!]!
}

"""
on_conflict condition type for table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_on_conflict {
  constraint: restaurant_option_choice_map_constraint!
  update_columns: [restaurant_option_choice_map_update_column!]! = []
  where: restaurant_option_choice_map_bool_exp
}

"""
Ordering options when selecting data from "restaurant_option_choice_map".
"""
input restaurant_option_choice_map_order_by {
  choice_id: order_by
  id: order_by
  option_choices_aggregate: restaurant_choice_aggregate_order_by
  option_id: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_option_choice_map"""
input restaurant_option_choice_map_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_select_column {
  """column name"""
  choice_id

  """column name"""
  id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_set_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_option_choice_map_stddev_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_choice_map_stddev_pop_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_pop_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_choice_map_stddev_samp_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stddev_samp_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_choice_map_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_choice_map_stream_cursor_value_input {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_option_choice_map_sum_fields {
  choice_id: Int
  id: Int
  option_id: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_sum_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_option_choice_map"
"""
enum restaurant_option_choice_map_update_column {
  """column name"""
  choice_id

  """column name"""
  id

  """column name"""
  option_id

  """column name"""
  restaurant_id
}

input restaurant_option_choice_map_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_choice_map_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_choice_map_set_input
  where: restaurant_option_choice_map_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_choice_map_var_pop_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_var_pop_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_choice_map_var_samp_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_var_samp_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_option_choice_map_variance_fields {
  choice_id: Float
  id: Float
  option_id: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_option_choice_map"
"""
input restaurant_option_choice_map_variance_order_by {
  choice_id: order_by
  id: order_by
  option_id: order_by
  restaurant_id: order_by
}

"""
unique or primary key constraints on table "restaurant_option"
"""
enum restaurant_option_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_option_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_option"
"""
input restaurant_option_inc_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
input type for inserting data into table "restaurant_option"
"""
input restaurant_option_insert_input {
  choices: restaurant_option_choice_map_arr_rel_insert_input
  cost_per_extra: money
  free_choice: Int
  id: Int
  items: restaurant_item_option_map_arr_rel_insert_input
  maximum_choice: Int
  minimum_choice: Int
  name: translation_obj_rel_insert_input
  name_id: Int
  option_type: String
  position: Int
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
}

"""aggregate max on columns"""
type restaurant_option_max_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""
order by max() on columns of table "restaurant_option"
"""
input restaurant_option_max_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate min on columns"""
type restaurant_option_min_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""
order by min() on columns of table "restaurant_option"
"""
input restaurant_option_min_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant_id: order_by
}

"""
response of any mutation on the table "restaurant_option"
"""
type restaurant_option_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_option!]!
}

"""
on_conflict condition type for table "restaurant_option"
"""
input restaurant_option_on_conflict {
  constraint: restaurant_option_constraint!
  update_columns: [restaurant_option_update_column!]! = []
  where: restaurant_option_bool_exp
}

"""Ordering options when selecting data from "restaurant_option"."""
input restaurant_option_order_by {
  choices_aggregate: restaurant_option_choice_map_aggregate_order_by
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  items_aggregate: restaurant_item_option_map_aggregate_order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name: translation_order_by
  name_id: order_by
  option_type: order_by
  position: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
}

"""primary key columns input for table: restaurant_option"""
input restaurant_option_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_option"
"""
enum restaurant_option_select_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position

  """column name"""
  restaurant_id
}

"""
input type for updating data in table "restaurant_option"
"""
input restaurant_option_set_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""aggregate stddev on columns"""
type restaurant_option_stddev_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_option_stddev_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_option_stddev_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_option"
"""
input restaurant_option_stddev_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
Streaming cursor of the table "restaurant_option"
"""
input restaurant_option_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_option_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_option_stream_cursor_value_input {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  option_type: String
  position: Int
  restaurant_id: Int
}

"""aggregate sum on columns"""
type restaurant_option_sum_fields {
  cost_per_extra: money
  free_choice: Int
  id: Int
  maximum_choice: Int
  minimum_choice: Int
  name_id: Int
  position: Int
  restaurant_id: Int
}

"""
order by sum() on columns of table "restaurant_option"
"""
input restaurant_option_sum_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
update columns of table "restaurant_option"
"""
enum restaurant_option_update_column {
  """column name"""
  cost_per_extra

  """column name"""
  free_choice

  """column name"""
  id

  """column name"""
  maximum_choice

  """column name"""
  minimum_choice

  """column name"""
  name_id

  """column name"""
  option_type

  """column name"""
  position

  """column name"""
  restaurant_id
}

input restaurant_option_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_option_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_option_set_input
  where: restaurant_option_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_option_var_pop_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_pop() on columns of table "restaurant_option"
"""
input restaurant_option_var_pop_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_option_var_samp_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by var_samp() on columns of table "restaurant_option"
"""
input restaurant_option_var_samp_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""aggregate variance on columns"""
type restaurant_option_variance_fields {
  cost_per_extra: Float
  free_choice: Float
  id: Float
  maximum_choice: Float
  minimum_choice: Float
  name_id: Float
  position: Float
  restaurant_id: Float
}

"""
order by variance() on columns of table "restaurant_option"
"""
input restaurant_option_variance_order_by {
  cost_per_extra: order_by
  free_choice: order_by
  id: order_by
  maximum_choice: order_by
  minimum_choice: order_by
  name_id: order_by
  position: order_by
  restaurant_id: order_by
}

"""
columns and relationships of "restaurant_order"
"""
type restaurant_order {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz

  """An object relationship"""
  chat: chat!
  chat_id: Int!

  """An object relationship"""
  customer: customer!
  customer_app_type: String!
  customer_id: Int!

  """An object relationship"""
  delivery: delivery_order
  delivery_cost: money!
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int!

  """
  A computed field, executes function "in_process"
  """
  in_process: Boolean

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """An aggregate relationship"""
  items_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  A computed field, executes function "itemscost"
  """
  items_cost: money
  notes: String
  order_time: timestamptz!
  order_type: String!
  payment_type: String!
  refund_amount: money!

  """An object relationship"""
  restaurant: restaurant!
  restaurant_id: Int!

  """An object relationship"""
  review: review
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String!
  stripe_fees: money!
  stripe_info(
    """JSON select path"""
    path: String
  ): jsonb
  tax: money!
  to_location_address: String
  to_location_gps: geography

  """
  A computed field, executes function "totalcost"
  """
  total_cost: money
}

"""
aggregated selection of "restaurant_order"
"""
type restaurant_order_aggregate {
  aggregate: restaurant_order_aggregate_fields
  nodes: [restaurant_order!]!
}

input restaurant_order_aggregate_bool_exp {
  count: restaurant_order_aggregate_bool_exp_count
}

input restaurant_order_aggregate_bool_exp_count {
  arguments: [restaurant_order_select_column!]
  distinct: Boolean
  filter: restaurant_order_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_order"
"""
type restaurant_order_aggregate_fields {
  avg: restaurant_order_avg_fields
  count(columns: [restaurant_order_select_column!], distinct: Boolean): Int!
  max: restaurant_order_max_fields
  min: restaurant_order_min_fields
  stddev: restaurant_order_stddev_fields
  stddev_pop: restaurant_order_stddev_pop_fields
  stddev_samp: restaurant_order_stddev_samp_fields
  sum: restaurant_order_sum_fields
  var_pop: restaurant_order_var_pop_fields
  var_samp: restaurant_order_var_samp_fields
  variance: restaurant_order_variance_fields
}

"""
order by aggregate values of table "restaurant_order"
"""
input restaurant_order_aggregate_order_by {
  avg: restaurant_order_avg_order_by
  count: order_by
  max: restaurant_order_max_order_by
  min: restaurant_order_min_order_by
  stddev: restaurant_order_stddev_order_by
  stddev_pop: restaurant_order_stddev_pop_order_by
  stddev_samp: restaurant_order_stddev_samp_order_by
  sum: restaurant_order_sum_order_by
  var_pop: restaurant_order_var_pop_order_by
  var_samp: restaurant_order_var_samp_order_by
  variance: restaurant_order_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input restaurant_order_append_input {
  stripe_info: jsonb
}

"""
input type for inserting array relation for remote table "restaurant_order"
"""
input restaurant_order_arr_rel_insert_input {
  data: [restaurant_order_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_avg_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by avg() on columns of table "restaurant_order"
"""
input restaurant_order_avg_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_order". All fields are combined with a logical 'AND'.
"""
input restaurant_order_bool_exp {
  _and: [restaurant_order_bool_exp!]
  _not: restaurant_order_bool_exp
  _or: [restaurant_order_bool_exp!]
  actual_food_ready_time: timestamptz_comparison_exp
  cancellation_time: timestamptz_comparison_exp
  chat: chat_bool_exp
  chat_id: Int_comparison_exp
  customer: customer_bool_exp
  customer_app_type: String_comparison_exp
  customer_id: Int_comparison_exp
  delivery: delivery_order_bool_exp
  delivery_cost: money_comparison_exp
  delivery_id: Int_comparison_exp
  estimated_food_ready_time: timestamptz_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  in_process: Boolean_comparison_exp
  items: restaurant_order_item_bool_exp
  items_aggregate: restaurant_order_item_aggregate_bool_exp
  items_cost: money_comparison_exp
  notes: String_comparison_exp
  order_time: timestamptz_comparison_exp
  order_type: String_comparison_exp
  payment_type: String_comparison_exp
  refund_amount: money_comparison_exp
  restaurant: restaurant_bool_exp
  restaurant_id: Int_comparison_exp
  review: review_bool_exp
  review_id: Int_comparison_exp
  scheduled_time: timestamptz_comparison_exp
  status: String_comparison_exp
  stripe_fees: money_comparison_exp
  stripe_info: jsonb_comparison_exp
  tax: money_comparison_exp
  to_location_address: String_comparison_exp
  to_location_gps: geography_comparison_exp
  total_cost: money_comparison_exp
}

"""Ordering options when selecting data from "restaurant"."""
input restaurant_order_by {
  accepted_payments: order_by
  approved: order_by
  categories_aggregate: restaurant_category_aggregate_order_by
  delivery_drivers_aggregate: delivery_driver_aggregate_order_by
  description: translation_order_by
  description_id: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  location_gps: order_by
  location_text: order_by
  name: order_by
  open_status: order_by
  orders_aggregate: restaurant_order_aggregate_order_by
  payment_info: service_provider_payment_info_order_by
  payment_info_id: order_by
  restaurant_operators_aggregate: restaurant_operator_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  schedule: order_by
  self_delivery: order_by
  service_provider_type: order_by
  specials_aggregate: restaurant_item_aggregate_order_by
  stripe_info: order_by
}

"""
unique or primary key constraints on table "restaurant_order"
"""
enum restaurant_order_constraint {
  """
  unique or primary key constraint on columns "delivery_id"
  """
  restaurant_order_delivery_id_key

  """
  unique or primary key constraint on columns "firebase_id"
  """
  restaurant_order_firebase_id_key

  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input restaurant_order_delete_at_path_input {
  stripe_info: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input restaurant_order_delete_elem_input {
  stripe_info: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input restaurant_order_delete_key_input {
  stripe_info: String
}

"""
input type for incrementing numeric columns in table "restaurant_order"
"""
input restaurant_order_inc_input {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  stripe_fees: money
  tax: money
}

"""
input type for inserting data into table "restaurant_order"
"""
input restaurant_order_insert_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat: chat_obj_rel_insert_input
  chat_id: Int
  customer: customer_obj_rel_insert_input
  customer_app_type: String
  customer_id: Int
  delivery: delivery_order_obj_rel_insert_input
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  items: restaurant_order_item_arr_rel_insert_input
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: money
  restaurant: restaurant_obj_rel_insert_input
  restaurant_id: Int
  review: review_obj_rel_insert_input
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""in_json:[name(en,es), selected_options]"""
type restaurant_order_item {
  cost_per_one: money!
  id: Int!
  in_json(
    """JSON select path"""
    path: String
  ): json!
  notes: String

  """An object relationship"""
  order: restaurant_order!
  quantity: Int!

  """An object relationship"""
  restaurant_item: restaurant_item!
  restaurant_item_id: Int!
  restaurant_order_id: Int!
  review_id: Int
  unavailable: Boolean!
}

"""
aggregated selection of "restaurant_order_item"
"""
type restaurant_order_item_aggregate {
  aggregate: restaurant_order_item_aggregate_fields
  nodes: [restaurant_order_item!]!
}

input restaurant_order_item_aggregate_bool_exp {
  bool_and: restaurant_order_item_aggregate_bool_exp_bool_and
  bool_or: restaurant_order_item_aggregate_bool_exp_bool_or
  count: restaurant_order_item_aggregate_bool_exp_count
}

input restaurant_order_item_aggregate_bool_exp_bool_and {
  arguments: restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_order_item_aggregate_bool_exp_bool_or {
  arguments: restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input restaurant_order_item_aggregate_bool_exp_count {
  arguments: [restaurant_order_item_select_column!]
  distinct: Boolean
  filter: restaurant_order_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "restaurant_order_item"
"""
type restaurant_order_item_aggregate_fields {
  avg: restaurant_order_item_avg_fields
  count(columns: [restaurant_order_item_select_column!], distinct: Boolean): Int!
  max: restaurant_order_item_max_fields
  min: restaurant_order_item_min_fields
  stddev: restaurant_order_item_stddev_fields
  stddev_pop: restaurant_order_item_stddev_pop_fields
  stddev_samp: restaurant_order_item_stddev_samp_fields
  sum: restaurant_order_item_sum_fields
  var_pop: restaurant_order_item_var_pop_fields
  var_samp: restaurant_order_item_var_samp_fields
  variance: restaurant_order_item_variance_fields
}

"""
order by aggregate values of table "restaurant_order_item"
"""
input restaurant_order_item_aggregate_order_by {
  avg: restaurant_order_item_avg_order_by
  count: order_by
  max: restaurant_order_item_max_order_by
  min: restaurant_order_item_min_order_by
  stddev: restaurant_order_item_stddev_order_by
  stddev_pop: restaurant_order_item_stddev_pop_order_by
  stddev_samp: restaurant_order_item_stddev_samp_order_by
  sum: restaurant_order_item_sum_order_by
  var_pop: restaurant_order_item_var_pop_order_by
  var_samp: restaurant_order_item_var_samp_order_by
  variance: restaurant_order_item_variance_order_by
}

"""
input type for inserting array relation for remote table "restaurant_order_item"
"""
input restaurant_order_item_arr_rel_insert_input {
  data: [restaurant_order_item_insert_input!]!

  """upsert condition"""
  on_conflict: restaurant_order_item_on_conflict
}

"""aggregate avg on columns"""
type restaurant_order_item_avg_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by avg() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_avg_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Boolean expression to filter rows from the table "restaurant_order_item". All fields are combined with a logical 'AND'.
"""
input restaurant_order_item_bool_exp {
  _and: [restaurant_order_item_bool_exp!]
  _not: restaurant_order_item_bool_exp
  _or: [restaurant_order_item_bool_exp!]
  cost_per_one: money_comparison_exp
  id: Int_comparison_exp
  in_json: json_comparison_exp
  notes: String_comparison_exp
  order: restaurant_order_bool_exp
  quantity: Int_comparison_exp
  restaurant_item: restaurant_item_bool_exp
  restaurant_item_id: Int_comparison_exp
  restaurant_order_id: Int_comparison_exp
  review_id: Int_comparison_exp
  unavailable: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "restaurant_order_item"
"""
enum restaurant_order_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  restaurant_order_item_pkey
}

"""
input type for incrementing numeric columns in table "restaurant_order_item"
"""
input restaurant_order_item_inc_input {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
input type for inserting data into table "restaurant_order_item"
"""
input restaurant_order_item_insert_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  order: restaurant_order_obj_rel_insert_input
  quantity: Int
  restaurant_item: restaurant_item_obj_rel_insert_input
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate max on columns"""
type restaurant_order_item_max_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by max() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_max_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate min on columns"""
type restaurant_order_item_min_fields {
  cost_per_one: money
  id: Int
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by min() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_min_order_by {
  cost_per_one: order_by
  id: order_by
  notes: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
response of any mutation on the table "restaurant_order_item"
"""
type restaurant_order_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order_item!]!
}

"""
on_conflict condition type for table "restaurant_order_item"
"""
input restaurant_order_item_on_conflict {
  constraint: restaurant_order_item_constraint!
  update_columns: [restaurant_order_item_update_column!]! = []
  where: restaurant_order_item_bool_exp
}

"""Ordering options when selecting data from "restaurant_order_item"."""
input restaurant_order_item_order_by {
  cost_per_one: order_by
  id: order_by
  in_json: order_by
  notes: order_by
  order: restaurant_order_order_by
  quantity: order_by
  restaurant_item: restaurant_item_order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
  unavailable: order_by
}

"""primary key columns input for table: restaurant_order_item"""
input restaurant_order_item_pk_columns_input {
  id: Int!
}

"""
select columns of table "restaurant_order_item"
"""
enum restaurant_order_item_select_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

"""
select "restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "restaurant_order_item"
"""
enum restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  unavailable
}

"""
select "restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "restaurant_order_item"
"""
enum restaurant_order_item_select_column_restaurant_order_item_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  unavailable
}

"""
input type for updating data in table "restaurant_order_item"
"""
input restaurant_order_item_set_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate stddev on columns"""
type restaurant_order_item_stddev_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_item_stddev_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_pop() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_item_stddev_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by stddev_samp() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_stddev_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
Streaming cursor of the table "restaurant_order_item"
"""
input restaurant_order_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_item_stream_cursor_value_input {
  cost_per_one: money
  id: Int
  in_json: json
  notes: String
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
  unavailable: Boolean
}

"""aggregate sum on columns"""
type restaurant_order_item_sum_fields {
  cost_per_one: money
  id: Int
  quantity: Int
  restaurant_item_id: Int
  restaurant_order_id: Int
  review_id: Int
}

"""
order by sum() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_sum_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""
update columns of table "restaurant_order_item"
"""
enum restaurant_order_item_update_column {
  """column name"""
  cost_per_one

  """column name"""
  id

  """column name"""
  in_json

  """column name"""
  notes

  """column name"""
  quantity

  """column name"""
  restaurant_item_id

  """column name"""
  restaurant_order_id

  """column name"""
  review_id

  """column name"""
  unavailable
}

input restaurant_order_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_item_set_input
  where: restaurant_order_item_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_item_var_pop_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_pop() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_var_pop_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_item_var_samp_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by var_samp() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_var_samp_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate variance on columns"""
type restaurant_order_item_variance_fields {
  cost_per_one: Float
  id: Float
  quantity: Float
  restaurant_item_id: Float
  restaurant_order_id: Float
  review_id: Float
}

"""
order by variance() on columns of table "restaurant_order_item"
"""
input restaurant_order_item_variance_order_by {
  cost_per_one: order_by
  id: order_by
  quantity: order_by
  restaurant_item_id: order_by
  restaurant_order_id: order_by
  review_id: order_by
}

"""aggregate max on columns"""
type restaurant_order_max_fields {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  tax: money
  to_location_address: String
}

"""
order by max() on columns of table "restaurant_order"
"""
input restaurant_order_max_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  scheduled_time: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_fees: order_by
  tax: order_by
  to_location_address: order_by
}

"""aggregate min on columns"""
type restaurant_order_min_fields {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  tax: money
  to_location_address: String
}

"""
order by min() on columns of table "restaurant_order"
"""
input restaurant_order_min_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat_id: order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  scheduled_time: order_by

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: order_by
  stripe_fees: order_by
  tax: order_by
  to_location_address: order_by
}

"""
response of any mutation on the table "restaurant_order"
"""
type restaurant_order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order!]!
}

"""
input type for inserting object relation for remote table "restaurant_order"
"""
input restaurant_order_obj_rel_insert_input {
  data: restaurant_order_insert_input!

  """upsert condition"""
  on_conflict: restaurant_order_on_conflict
}

"""
on_conflict condition type for table "restaurant_order"
"""
input restaurant_order_on_conflict {
  constraint: restaurant_order_constraint!
  update_columns: [restaurant_order_update_column!]! = []
  where: restaurant_order_bool_exp
}

"""Ordering options when selecting data from "restaurant_order"."""
input restaurant_order_order_by {
  actual_food_ready_time: order_by
  cancellation_time: order_by
  chat: chat_order_by
  chat_id: order_by
  customer: customer_order_by
  customer_app_type: order_by
  customer_id: order_by
  delivery: delivery_order_order_by
  delivery_cost: order_by
  delivery_id: order_by
  estimated_food_ready_time: order_by
  firebase_id: order_by
  id: order_by
  in_process: order_by
  items_aggregate: restaurant_order_item_aggregate_order_by
  items_cost: order_by
  notes: order_by
  order_time: order_by
  order_type: order_by
  payment_type: order_by
  refund_amount: order_by
  restaurant: restaurant_order_by
  restaurant_id: order_by
  review: review_order_by
  review_id: order_by
  scheduled_time: order_by
  status: order_by
  stripe_fees: order_by
  stripe_info: order_by
  tax: order_by
  to_location_address: order_by
  to_location_gps: order_by
  total_cost: order_by
}

"""primary key columns input for table: restaurant_order"""
input restaurant_order_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input restaurant_order_prepend_input {
  stripe_info: jsonb
}

"""
columns and relationships of "restaurant_order_public"
"""
type restaurant_order_public {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int

  """An array relationship"""
  restaurant_operators(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """An aggregate relationship"""
  restaurant_operators_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!
  review_id: Int
  status: String
}

"""
aggregated selection of "restaurant_order_public"
"""
type restaurant_order_public_aggregate {
  aggregate: restaurant_order_public_aggregate_fields
  nodes: [restaurant_order_public!]!
}

"""
aggregate fields of "restaurant_order_public"
"""
type restaurant_order_public_aggregate_fields {
  avg: restaurant_order_public_avg_fields
  count(columns: [restaurant_order_public_select_column!], distinct: Boolean): Int!
  max: restaurant_order_public_max_fields
  min: restaurant_order_public_min_fields
  stddev: restaurant_order_public_stddev_fields
  stddev_pop: restaurant_order_public_stddev_pop_fields
  stddev_samp: restaurant_order_public_stddev_samp_fields
  sum: restaurant_order_public_sum_fields
  var_pop: restaurant_order_public_var_pop_fields
  var_samp: restaurant_order_public_var_samp_fields
  variance: restaurant_order_public_variance_fields
}

"""aggregate avg on columns"""
type restaurant_order_public_avg_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
Boolean expression to filter rows from the table "restaurant_order_public". All fields are combined with a logical 'AND'.
"""
input restaurant_order_public_bool_exp {
  _and: [restaurant_order_public_bool_exp!]
  _not: restaurant_order_public_bool_exp
  _or: [restaurant_order_public_bool_exp!]
  actual_food_ready_time: timestamptz_comparison_exp
  customer_id: Int_comparison_exp
  estimated_food_ready_time: timestamptz_comparison_exp
  order_time: timestamptz_comparison_exp
  restaurant_id: Int_comparison_exp
  restaurant_operators: restaurant_operator_bool_exp
  restaurant_operators_aggregate: restaurant_operator_aggregate_bool_exp
  review_id: Int_comparison_exp
  status: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "restaurant_order_public"
"""
input restaurant_order_public_inc_input {
  customer_id: Int
  restaurant_id: Int
  review_id: Int
}

"""
input type for inserting data into table "restaurant_order_public"
"""
input restaurant_order_public_insert_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  restaurant_operators: restaurant_operator_arr_rel_insert_input
  review_id: Int
  status: String
}

"""aggregate max on columns"""
type restaurant_order_public_max_fields {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate min on columns"""
type restaurant_order_public_min_fields {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""
response of any mutation on the table "restaurant_order_public"
"""
type restaurant_order_public_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [restaurant_order_public!]!
}

"""Ordering options when selecting data from "restaurant_order_public"."""
input restaurant_order_public_order_by {
  actual_food_ready_time: order_by
  customer_id: order_by
  estimated_food_ready_time: order_by
  order_time: order_by
  restaurant_id: order_by
  restaurant_operators_aggregate: restaurant_operator_aggregate_order_by
  review_id: order_by
  status: order_by
}

"""
select columns of table "restaurant_order_public"
"""
enum restaurant_order_public_select_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  customer_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  order_time

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  status
}

"""
input type for updating data in table "restaurant_order_public"
"""
input restaurant_order_public_set_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate stddev on columns"""
type restaurant_order_public_stddev_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_order_public_stddev_pop_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_order_public_stddev_samp_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
Streaming cursor of the table "restaurant_order_public"
"""
input restaurant_order_public_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_public_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_public_stream_cursor_value_input {
  actual_food_ready_time: timestamptz
  customer_id: Int
  estimated_food_ready_time: timestamptz
  order_time: timestamptz
  restaurant_id: Int
  review_id: Int
  status: String
}

"""aggregate sum on columns"""
type restaurant_order_public_sum_fields {
  customer_id: Int
  restaurant_id: Int
  review_id: Int
}

input restaurant_order_public_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_public_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_public_set_input
  where: restaurant_order_public_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_public_var_pop_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_order_public_var_samp_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""aggregate variance on columns"""
type restaurant_order_public_variance_fields {
  customer_id: Float
  restaurant_id: Float
  review_id: Float
}

"""
select columns of table "restaurant_order"
"""
enum restaurant_order_select_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

"""
input type for updating data in table "restaurant_order"
"""
input restaurant_order_set_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""aggregate stddev on columns"""
type restaurant_order_stddev_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate stddev_pop on columns"""
type restaurant_order_stddev_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev_pop() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate stddev_samp on columns"""
type restaurant_order_stddev_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by stddev_samp() on columns of table "restaurant_order"
"""
input restaurant_order_stddev_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
Streaming cursor of the table "restaurant_order"
"""
input restaurant_order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_order_stream_cursor_value_input {
  actual_food_ready_time: timestamptz
  cancellation_time: timestamptz
  chat_id: Int
  customer_app_type: String
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  estimated_food_ready_time: timestamptz
  firebase_id: String
  id: Int
  notes: String
  order_time: timestamptz
  order_type: String
  payment_type: String
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  scheduled_time: timestamptz

  """
  orderReceived, preparing, ready, onTheWay, delivered, cancelledByCustomer, cancelledByRestaurant
  """
  status: String
  stripe_fees: money
  stripe_info: jsonb
  tax: money
  to_location_address: String
  to_location_gps: geography
}

"""aggregate sum on columns"""
type restaurant_order_sum_fields {
  chat_id: Int
  customer_id: Int
  delivery_cost: money
  delivery_id: Int
  id: Int
  refund_amount: money
  restaurant_id: Int
  review_id: Int
  stripe_fees: money
  tax: money
}

"""
order by sum() on columns of table "restaurant_order"
"""
input restaurant_order_sum_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""
update columns of table "restaurant_order"
"""
enum restaurant_order_update_column {
  """column name"""
  actual_food_ready_time

  """column name"""
  cancellation_time

  """column name"""
  chat_id

  """column name"""
  customer_app_type

  """column name"""
  customer_id

  """column name"""
  delivery_cost

  """column name"""
  delivery_id

  """column name"""
  estimated_food_ready_time

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  order_time

  """column name"""
  order_type

  """column name"""
  payment_type

  """column name"""
  refund_amount

  """column name"""
  restaurant_id

  """column name"""
  review_id

  """column name"""
  scheduled_time

  """column name"""
  status

  """column name"""
  stripe_fees

  """column name"""
  stripe_info

  """column name"""
  tax

  """column name"""
  to_location_address

  """column name"""
  to_location_gps
}

input restaurant_order_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: restaurant_order_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: restaurant_order_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: restaurant_order_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: restaurant_order_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_order_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: restaurant_order_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_order_set_input
  where: restaurant_order_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_order_var_pop_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by var_pop() on columns of table "restaurant_order"
"""
input restaurant_order_var_pop_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate var_samp on columns"""
type restaurant_order_var_samp_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by var_samp() on columns of table "restaurant_order"
"""
input restaurant_order_var_samp_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""aggregate variance on columns"""
type restaurant_order_variance_fields {
  chat_id: Float
  customer_id: Float
  delivery_cost: Float
  delivery_id: Float
  id: Float
  refund_amount: Float
  restaurant_id: Float
  review_id: Float
  stripe_fees: Float
  tax: Float
}

"""
order by variance() on columns of table "restaurant_order"
"""
input restaurant_order_variance_order_by {
  chat_id: order_by
  customer_id: order_by
  delivery_cost: order_by
  delivery_id: order_by
  id: order_by
  refund_amount: order_by
  restaurant_id: order_by
  review_id: order_by
  stripe_fees: order_by
  tax: order_by
}

"""primary key columns input for table: restaurant"""
input restaurant_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input restaurant_prepend_input {
  accepted_payments: jsonb
  schedule: jsonb
  stripe_info: jsonb
}

"""
select columns of table "restaurant"
"""
enum restaurant_select_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  payment_info_id

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

"""
input type for updating data in table "restaurant"
"""
input restaurant_set_input {
  accepted_payments: jsonb
  approved: Boolean
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""aggregate stddev on columns"""
type restaurant_stddev_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""aggregate stddev_pop on columns"""
type restaurant_stddev_pop_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""aggregate stddev_samp on columns"""
type restaurant_stddev_samp_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""
Streaming cursor of the table "restaurant"
"""
input restaurant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: restaurant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input restaurant_stream_cursor_value_input {
  accepted_payments: jsonb
  approved: Boolean
  description_id: Int
  firebase_id: String
  id: Int
  image: String
  language_id: String
  location_gps: geography
  location_text: String
  name: String

  """open, closed_temporarily, closed_indefinitely"""
  open_status: String
  payment_info_id: Int
  schedule: jsonb
  self_delivery: Boolean
  service_provider_type: String
  stripe_info: jsonb
}

"""aggregate sum on columns"""
type restaurant_sum_fields {
  description_id: Int
  id: Int
  payment_info_id: Int
}

"""
update columns of table "restaurant"
"""
enum restaurant_update_column {
  """column name"""
  accepted_payments

  """column name"""
  approved

  """column name"""
  description_id

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name

  """column name"""
  open_status

  """column name"""
  payment_info_id

  """column name"""
  schedule

  """column name"""
  self_delivery

  """column name"""
  service_provider_type

  """column name"""
  stripe_info
}

input restaurant_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: restaurant_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: restaurant_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: restaurant_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: restaurant_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: restaurant_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: restaurant_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: restaurant_set_input
  where: restaurant_bool_exp!
}

"""aggregate var_pop on columns"""
type restaurant_var_pop_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""aggregate var_samp on columns"""
type restaurant_var_samp_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""aggregate variance on columns"""
type restaurant_variance_fields {
  description_id: Float
  id: Float
  payment_info_id: Float
}

"""
columns and relationships of "review"
"""
type review {
  created_at: timestamptz!

  """An object relationship"""
  customer: customer
  from_entity_id: Int!
  from_entity_type: String!
  id: Int!
  note: String
  rating: Int!
  to_entity_id: Int!
  to_entity_type: String!
}

"""
aggregated selection of "review"
"""
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

input review_aggregate_bool_exp {
  count: review_aggregate_bool_exp_count
}

input review_aggregate_bool_exp_count {
  arguments: [review_select_column!]
  distinct: Boolean
  filter: review_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "review"
"""
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int!
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

"""
order by aggregate values of table "review"
"""
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

"""
input type for inserting array relation for remote table "review"
"""
input review_arr_rel_insert_input {
  data: [review_insert_input!]!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""aggregate avg on columns"""
type review_avg_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by avg() on columns of table "review"
"""
input review_avg_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
"""
input review_bool_exp {
  _and: [review_bool_exp!]
  _not: review_bool_exp
  _or: [review_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer: customer_bool_exp
  from_entity_id: Int_comparison_exp
  from_entity_type: String_comparison_exp
  id: Int_comparison_exp
  note: String_comparison_exp
  rating: Int_comparison_exp
  to_entity_id: Int_comparison_exp
  to_entity_type: String_comparison_exp
}

"""
unique or primary key constraints on table "review"
"""
enum review_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  review_pkey
}

"""
input type for incrementing numeric columns in table "review"
"""
input review_inc_input {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
input type for inserting data into table "review"
"""
input review_insert_input {
  created_at: timestamptz
  customer: customer_obj_rel_insert_input
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate max on columns"""
type review_max_fields {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""
order by max() on columns of table "review"
"""
input review_max_order_by {
  created_at: order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""aggregate min on columns"""
type review_min_fields {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""
order by min() on columns of table "review"
"""
input review_min_order_by {
  created_at: order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""
response of any mutation on the table "review"
"""
type review_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [review!]!
}

"""
input type for inserting object relation for remote table "review"
"""
input review_obj_rel_insert_input {
  data: review_insert_input!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""
on_conflict condition type for table "review"
"""
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]! = []
  where: review_bool_exp
}

"""Ordering options when selecting data from "review"."""
input review_order_by {
  created_at: order_by
  customer: customer_order_by
  from_entity_id: order_by
  from_entity_type: order_by
  id: order_by
  note: order_by
  rating: order_by
  to_entity_id: order_by
  to_entity_type: order_by
}

"""primary key columns input for table: review"""
input review_pk_columns_input {
  id: Int!
}

"""
select columns of table "review"
"""
enum review_select_column {
  """column name"""
  created_at

  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

"""
input type for updating data in table "review"
"""
input review_set_input {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate stddev on columns"""
type review_stddev_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev() on columns of table "review"
"""
input review_stddev_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate stddev_pop on columns"""
type review_stddev_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev_pop() on columns of table "review"
"""
input review_stddev_pop_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate stddev_samp on columns"""
type review_stddev_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by stddev_samp() on columns of table "review"
"""
input review_stddev_samp_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
Streaming cursor of the table "review"
"""
input review_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: review_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input review_stream_cursor_value_input {
  created_at: timestamptz
  from_entity_id: Int
  from_entity_type: String
  id: Int
  note: String
  rating: Int
  to_entity_id: Int
  to_entity_type: String
}

"""aggregate sum on columns"""
type review_sum_fields {
  from_entity_id: Int
  id: Int
  rating: Int
  to_entity_id: Int
}

"""
order by sum() on columns of table "review"
"""
input review_sum_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""
update columns of table "review"
"""
enum review_update_column {
  """column name"""
  created_at

  """column name"""
  from_entity_id

  """column name"""
  from_entity_type

  """column name"""
  id

  """column name"""
  note

  """column name"""
  rating

  """column name"""
  to_entity_id

  """column name"""
  to_entity_type
}

input review_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: review_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: review_set_input
  where: review_bool_exp!
}

"""aggregate var_pop on columns"""
type review_var_pop_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by var_pop() on columns of table "review"
"""
input review_var_pop_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate var_samp on columns"""
type review_var_samp_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by var_samp() on columns of table "review"
"""
input review_var_samp_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""aggregate variance on columns"""
type review_variance_fields {
  from_entity_id: Float
  id: Float
  rating: Float
  to_entity_id: Float
}

"""
order by variance() on columns of table "review"
"""
input review_variance_order_by {
  from_entity_id: order_by
  id: order_by
  rating: order_by
  to_entity_id: order_by
}

"""Customer's saved locations"""
type saved_location {
  customer_id: Int!
  default: Boolean!
  id: Int!
  location_gps: geography!
  location_text: String!
  name: String!
}

"""
aggregated selection of "saved_location"
"""
type saved_location_aggregate {
  aggregate: saved_location_aggregate_fields
  nodes: [saved_location!]!
}

input saved_location_aggregate_bool_exp {
  bool_and: saved_location_aggregate_bool_exp_bool_and
  bool_or: saved_location_aggregate_bool_exp_bool_or
  count: saved_location_aggregate_bool_exp_count
}

input saved_location_aggregate_bool_exp_bool_and {
  arguments: saved_location_select_column_saved_location_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: saved_location_bool_exp
  predicate: Boolean_comparison_exp!
}

input saved_location_aggregate_bool_exp_bool_or {
  arguments: saved_location_select_column_saved_location_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: saved_location_bool_exp
  predicate: Boolean_comparison_exp!
}

input saved_location_aggregate_bool_exp_count {
  arguments: [saved_location_select_column!]
  distinct: Boolean
  filter: saved_location_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "saved_location"
"""
type saved_location_aggregate_fields {
  avg: saved_location_avg_fields
  count(columns: [saved_location_select_column!], distinct: Boolean): Int!
  max: saved_location_max_fields
  min: saved_location_min_fields
  stddev: saved_location_stddev_fields
  stddev_pop: saved_location_stddev_pop_fields
  stddev_samp: saved_location_stddev_samp_fields
  sum: saved_location_sum_fields
  var_pop: saved_location_var_pop_fields
  var_samp: saved_location_var_samp_fields
  variance: saved_location_variance_fields
}

"""
order by aggregate values of table "saved_location"
"""
input saved_location_aggregate_order_by {
  avg: saved_location_avg_order_by
  count: order_by
  max: saved_location_max_order_by
  min: saved_location_min_order_by
  stddev: saved_location_stddev_order_by
  stddev_pop: saved_location_stddev_pop_order_by
  stddev_samp: saved_location_stddev_samp_order_by
  sum: saved_location_sum_order_by
  var_pop: saved_location_var_pop_order_by
  var_samp: saved_location_var_samp_order_by
  variance: saved_location_variance_order_by
}

"""
input type for inserting array relation for remote table "saved_location"
"""
input saved_location_arr_rel_insert_input {
  data: [saved_location_insert_input!]!

  """upsert condition"""
  on_conflict: saved_location_on_conflict
}

"""aggregate avg on columns"""
type saved_location_avg_fields {
  customer_id: Float
  id: Float
}

"""
order by avg() on columns of table "saved_location"
"""
input saved_location_avg_order_by {
  customer_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "saved_location". All fields are combined with a logical 'AND'.
"""
input saved_location_bool_exp {
  _and: [saved_location_bool_exp!]
  _not: saved_location_bool_exp
  _or: [saved_location_bool_exp!]
  customer_id: Int_comparison_exp
  default: Boolean_comparison_exp
  id: Int_comparison_exp
  location_gps: geography_comparison_exp
  location_text: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "saved_location"
"""
enum saved_location_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  saved_location_pkey
}

"""
input type for incrementing numeric columns in table "saved_location"
"""
input saved_location_inc_input {
  customer_id: Int
  id: Int
}

"""
input type for inserting data into table "saved_location"
"""
input saved_location_insert_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate max on columns"""
type saved_location_max_fields {
  customer_id: Int
  id: Int
  location_text: String
  name: String
}

"""
order by max() on columns of table "saved_location"
"""
input saved_location_max_order_by {
  customer_id: order_by
  id: order_by
  location_text: order_by
  name: order_by
}

"""aggregate min on columns"""
type saved_location_min_fields {
  customer_id: Int
  id: Int
  location_text: String
  name: String
}

"""
order by min() on columns of table "saved_location"
"""
input saved_location_min_order_by {
  customer_id: order_by
  id: order_by
  location_text: order_by
  name: order_by
}

"""
response of any mutation on the table "saved_location"
"""
type saved_location_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [saved_location!]!
}

"""
on_conflict condition type for table "saved_location"
"""
input saved_location_on_conflict {
  constraint: saved_location_constraint!
  update_columns: [saved_location_update_column!]! = []
  where: saved_location_bool_exp
}

"""Ordering options when selecting data from "saved_location"."""
input saved_location_order_by {
  customer_id: order_by
  default: order_by
  id: order_by
  location_gps: order_by
  location_text: order_by
  name: order_by
}

"""primary key columns input for table: saved_location"""
input saved_location_pk_columns_input {
  id: Int!
}

"""
select columns of table "saved_location"
"""
enum saved_location_select_column {
  """column name"""
  customer_id

  """column name"""
  default

  """column name"""
  id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name
}

"""
select "saved_location_aggregate_bool_exp_bool_and_arguments_columns" columns of table "saved_location"
"""
enum saved_location_select_column_saved_location_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  default
}

"""
select "saved_location_aggregate_bool_exp_bool_or_arguments_columns" columns of table "saved_location"
"""
enum saved_location_select_column_saved_location_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  default
}

"""
input type for updating data in table "saved_location"
"""
input saved_location_set_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate stddev on columns"""
type saved_location_stddev_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev() on columns of table "saved_location"
"""
input saved_location_stddev_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type saved_location_stddev_pop_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "saved_location"
"""
input saved_location_stddev_pop_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type saved_location_stddev_samp_fields {
  customer_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "saved_location"
"""
input saved_location_stddev_samp_order_by {
  customer_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "saved_location"
"""
input saved_location_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: saved_location_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input saved_location_stream_cursor_value_input {
  customer_id: Int
  default: Boolean
  id: Int
  location_gps: geography
  location_text: String
  name: String
}

"""aggregate sum on columns"""
type saved_location_sum_fields {
  customer_id: Int
  id: Int
}

"""
order by sum() on columns of table "saved_location"
"""
input saved_location_sum_order_by {
  customer_id: order_by
  id: order_by
}

"""
update columns of table "saved_location"
"""
enum saved_location_update_column {
  """column name"""
  customer_id

  """column name"""
  default

  """column name"""
  id

  """column name"""
  location_gps

  """column name"""
  location_text

  """column name"""
  name
}

input saved_location_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: saved_location_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: saved_location_set_input
  where: saved_location_bool_exp!
}

"""aggregate var_pop on columns"""
type saved_location_var_pop_fields {
  customer_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "saved_location"
"""
input saved_location_var_pop_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type saved_location_var_samp_fields {
  customer_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "saved_location"
"""
input saved_location_var_samp_order_by {
  customer_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type saved_location_variance_fields {
  customer_id: Float
  id: Float
}

"""
order by variance() on columns of table "saved_location"
"""
input saved_location_variance_order_by {
  customer_id: order_by
  id: order_by
}

"""
columns and relationships of "service_link"
"""
type service_link {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int!
  operator_deep_link: String
  operator_qr_image_link: String

  """An object relationship"""
  restaurant: restaurant
  service_provider_id: Int!
  service_provider_type: String!
}

"""
aggregated selection of "service_link"
"""
type service_link_aggregate {
  aggregate: service_link_aggregate_fields
  nodes: [service_link!]!
}

"""
aggregate fields of "service_link"
"""
type service_link_aggregate_fields {
  avg: service_link_avg_fields
  count(columns: [service_link_select_column!], distinct: Boolean): Int!
  max: service_link_max_fields
  min: service_link_min_fields
  stddev: service_link_stddev_fields
  stddev_pop: service_link_stddev_pop_fields
  stddev_samp: service_link_stddev_samp_fields
  sum: service_link_sum_fields
  var_pop: service_link_var_pop_fields
  var_samp: service_link_var_samp_fields
  variance: service_link_variance_fields
}

"""aggregate avg on columns"""
type service_link_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "service_link". All fields are combined with a logical 'AND'.
"""
input service_link_bool_exp {
  _and: [service_link_bool_exp!]
  _not: service_link_bool_exp
  _or: [service_link_bool_exp!]
  customer_deep_link: String_comparison_exp
  customer_qr_image_link: String_comparison_exp
  driver_deep_link: String_comparison_exp
  driver_qr_image_link: String_comparison_exp
  id: Int_comparison_exp
  operator_deep_link: String_comparison_exp
  operator_qr_image_link: String_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
}

"""
unique or primary key constraints on table "service_link"
"""
enum service_link_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_links_pkey

  """
  unique or primary key constraint on columns "service_provider_id"
  """
  service_links_provider_id_key
}

"""
input type for incrementing numeric columns in table "service_link"
"""
input service_link_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "service_link"
"""
input service_link_insert_input {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  restaurant: restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate max on columns"""
type service_link_max_fields {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type service_link_min_fields {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "service_link"
"""
type service_link_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_link!]!
}

"""
on_conflict condition type for table "service_link"
"""
input service_link_on_conflict {
  constraint: service_link_constraint!
  update_columns: [service_link_update_column!]! = []
  where: service_link_bool_exp
}

"""Ordering options when selecting data from "service_link"."""
input service_link_order_by {
  customer_deep_link: order_by
  customer_qr_image_link: order_by
  driver_deep_link: order_by
  driver_qr_image_link: order_by
  id: order_by
  operator_deep_link: order_by
  operator_qr_image_link: order_by
  restaurant: restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
}

"""primary key columns input for table: service_link"""
input service_link_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_link"
"""
enum service_link_select_column {
  """column name"""
  customer_deep_link

  """column name"""
  customer_qr_image_link

  """column name"""
  driver_deep_link

  """column name"""
  driver_qr_image_link

  """column name"""
  id

  """column name"""
  operator_deep_link

  """column name"""
  operator_qr_image_link

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "service_link"
"""
input service_link_set_input {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type service_link_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type service_link_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type service_link_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "service_link"
"""
input service_link_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_link_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_link_stream_cursor_value_input {
  customer_deep_link: String
  customer_qr_image_link: String
  driver_deep_link: String
  driver_qr_image_link: String
  id: Int
  operator_deep_link: String
  operator_qr_image_link: String
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type service_link_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "service_link"
"""
enum service_link_update_column {
  """column name"""
  customer_deep_link

  """column name"""
  customer_qr_image_link

  """column name"""
  driver_deep_link

  """column name"""
  driver_qr_image_link

  """column name"""
  id

  """column name"""
  operator_deep_link

  """column name"""
  operator_qr_image_link

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input service_link_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_link_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_link_set_input
  where: service_link_bool_exp!
}

"""aggregate var_pop on columns"""
type service_link_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type service_link_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type service_link_variance_fields {
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "service_provider_payment_info"
"""
type service_provider_payment_info {
  bank_transfer: Boolean!
  card: Boolean!
  cash: Boolean!
  id: Int!

  """An object relationship"""
  restaurant: restaurant
  service_provider_type: String!

  """An object relationship"""
  stripe_info: stripe_info
  stripe_info_id: Int
}

"""
aggregated selection of "service_provider_payment_info"
"""
type service_provider_payment_info_aggregate {
  aggregate: service_provider_payment_info_aggregate_fields
  nodes: [service_provider_payment_info!]!
}

"""
aggregate fields of "service_provider_payment_info"
"""
type service_provider_payment_info_aggregate_fields {
  avg: service_provider_payment_info_avg_fields
  count(columns: [service_provider_payment_info_select_column!], distinct: Boolean): Int!
  max: service_provider_payment_info_max_fields
  min: service_provider_payment_info_min_fields
  stddev: service_provider_payment_info_stddev_fields
  stddev_pop: service_provider_payment_info_stddev_pop_fields
  stddev_samp: service_provider_payment_info_stddev_samp_fields
  sum: service_provider_payment_info_sum_fields
  var_pop: service_provider_payment_info_var_pop_fields
  var_samp: service_provider_payment_info_var_samp_fields
  variance: service_provider_payment_info_variance_fields
}

"""aggregate avg on columns"""
type service_provider_payment_info_avg_fields {
  id: Float
  stripe_info_id: Float
}

"""
Boolean expression to filter rows from the table
"service_provider_payment_info". All fields are combined with a logical 'AND'.
"""
input service_provider_payment_info_bool_exp {
  _and: [service_provider_payment_info_bool_exp!]
  _not: service_provider_payment_info_bool_exp
  _or: [service_provider_payment_info_bool_exp!]
  bank_transfer: Boolean_comparison_exp
  card: Boolean_comparison_exp
  cash: Boolean_comparison_exp
  id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_type: String_comparison_exp
  stripe_info: stripe_info_bool_exp
  stripe_info_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "service_provider_payment_info"
"""
enum service_provider_payment_info_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_provider_payment_info_pkey

  """
  unique or primary key constraint on columns "stripe_info_id"
  """
  service_provider_payment_info_stripe_info_id_key
}

"""
input type for incrementing numeric columns in table "service_provider_payment_info"
"""
input service_provider_payment_info_inc_input {
  id: Int
  stripe_info_id: Int
}

"""
input type for inserting data into table "service_provider_payment_info"
"""
input service_provider_payment_info_insert_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  restaurant: restaurant_obj_rel_insert_input
  service_provider_type: String
  stripe_info: stripe_info_obj_rel_insert_input
  stripe_info_id: Int
}

"""aggregate max on columns"""
type service_provider_payment_info_max_fields {
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate min on columns"""
type service_provider_payment_info_min_fields {
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""
response of any mutation on the table "service_provider_payment_info"
"""
type service_provider_payment_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_provider_payment_info!]!
}

"""
input type for inserting object relation for remote table "service_provider_payment_info"
"""
input service_provider_payment_info_obj_rel_insert_input {
  data: service_provider_payment_info_insert_input!

  """upsert condition"""
  on_conflict: service_provider_payment_info_on_conflict
}

"""
on_conflict condition type for table "service_provider_payment_info"
"""
input service_provider_payment_info_on_conflict {
  constraint: service_provider_payment_info_constraint!
  update_columns: [service_provider_payment_info_update_column!]! = []
  where: service_provider_payment_info_bool_exp
}

"""
Ordering options when selecting data from "service_provider_payment_info".
"""
input service_provider_payment_info_order_by {
  bank_transfer: order_by
  card: order_by
  cash: order_by
  id: order_by
  restaurant: restaurant_order_by
  service_provider_type: order_by
  stripe_info: stripe_info_order_by
  stripe_info_id: order_by
}

"""primary key columns input for table: service_provider_payment_info"""
input service_provider_payment_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_provider_payment_info"
"""
enum service_provider_payment_info_select_column {
  """column name"""
  bank_transfer

  """column name"""
  card

  """column name"""
  cash

  """column name"""
  id

  """column name"""
  service_provider_type

  """column name"""
  stripe_info_id
}

"""
input type for updating data in table "service_provider_payment_info"
"""
input service_provider_payment_info_set_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate stddev on columns"""
type service_provider_payment_info_stddev_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate stddev_pop on columns"""
type service_provider_payment_info_stddev_pop_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate stddev_samp on columns"""
type service_provider_payment_info_stddev_samp_fields {
  id: Float
  stripe_info_id: Float
}

"""
Streaming cursor of the table "service_provider_payment_info"
"""
input service_provider_payment_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_provider_payment_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_provider_payment_info_stream_cursor_value_input {
  bank_transfer: Boolean
  card: Boolean
  cash: Boolean
  id: Int
  service_provider_type: String
  stripe_info_id: Int
}

"""aggregate sum on columns"""
type service_provider_payment_info_sum_fields {
  id: Int
  stripe_info_id: Int
}

"""
update columns of table "service_provider_payment_info"
"""
enum service_provider_payment_info_update_column {
  """column name"""
  bank_transfer

  """column name"""
  card

  """column name"""
  cash

  """column name"""
  id

  """column name"""
  service_provider_type

  """column name"""
  stripe_info_id
}

input service_provider_payment_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_provider_payment_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_provider_payment_info_set_input
  where: service_provider_payment_info_bool_exp!
}

"""aggregate var_pop on columns"""
type service_provider_payment_info_var_pop_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate var_samp on columns"""
type service_provider_payment_info_var_samp_fields {
  id: Float
  stripe_info_id: Float
}

"""aggregate variance on columns"""
type service_provider_payment_info_variance_fields {
  id: Float
  stripe_info_id: Float
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "stripe_info"
"""
type stripe_info {
  charges_enabled: Boolean!
  details_submitted: Boolean!
  id: Int!
  pass_fees_to_customer: Boolean!
  payouts_enabled: Boolean!
  requirements(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  service_provider_payment_info: service_provider_payment_info
  stripe_id: String!
  stripe_status: String!
}

"""
aggregated selection of "stripe_info"
"""
type stripe_info_aggregate {
  aggregate: stripe_info_aggregate_fields
  nodes: [stripe_info!]!
}

"""
aggregate fields of "stripe_info"
"""
type stripe_info_aggregate_fields {
  avg: stripe_info_avg_fields
  count(columns: [stripe_info_select_column!], distinct: Boolean): Int!
  max: stripe_info_max_fields
  min: stripe_info_min_fields
  stddev: stripe_info_stddev_fields
  stddev_pop: stripe_info_stddev_pop_fields
  stddev_samp: stripe_info_stddev_samp_fields
  sum: stripe_info_sum_fields
  var_pop: stripe_info_var_pop_fields
  var_samp: stripe_info_var_samp_fields
  variance: stripe_info_variance_fields
}

"""aggregate avg on columns"""
type stripe_info_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "stripe_info". All fields are combined with a logical 'AND'.
"""
input stripe_info_bool_exp {
  _and: [stripe_info_bool_exp!]
  _not: stripe_info_bool_exp
  _or: [stripe_info_bool_exp!]
  charges_enabled: Boolean_comparison_exp
  details_submitted: Boolean_comparison_exp
  id: Int_comparison_exp
  pass_fees_to_customer: Boolean_comparison_exp
  payouts_enabled: Boolean_comparison_exp
  requirements: json_comparison_exp
  service_provider_payment_info: service_provider_payment_info_bool_exp
  stripe_id: String_comparison_exp
  stripe_status: String_comparison_exp
}

"""
unique or primary key constraints on table "stripe_info"
"""
enum stripe_info_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  stripe_info_pkey

  """
  unique or primary key constraint on columns "stripe_id"
  """
  stripe_info_stripe_id_key
}

"""
input type for incrementing numeric columns in table "stripe_info"
"""
input stripe_info_inc_input {
  id: Int
}

"""
input type for inserting data into table "stripe_info"
"""
input stripe_info_insert_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  service_provider_payment_info: service_provider_payment_info_obj_rel_insert_input
  stripe_id: String
  stripe_status: String
}

"""aggregate max on columns"""
type stripe_info_max_fields {
  id: Int
  stripe_id: String
  stripe_status: String
}

"""aggregate min on columns"""
type stripe_info_min_fields {
  id: Int
  stripe_id: String
  stripe_status: String
}

"""
response of any mutation on the table "stripe_info"
"""
type stripe_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [stripe_info!]!
}

"""
input type for inserting object relation for remote table "stripe_info"
"""
input stripe_info_obj_rel_insert_input {
  data: stripe_info_insert_input!

  """upsert condition"""
  on_conflict: stripe_info_on_conflict
}

"""
on_conflict condition type for table "stripe_info"
"""
input stripe_info_on_conflict {
  constraint: stripe_info_constraint!
  update_columns: [stripe_info_update_column!]! = []
  where: stripe_info_bool_exp
}

"""Ordering options when selecting data from "stripe_info"."""
input stripe_info_order_by {
  charges_enabled: order_by
  details_submitted: order_by
  id: order_by
  pass_fees_to_customer: order_by
  payouts_enabled: order_by
  requirements: order_by
  service_provider_payment_info: service_provider_payment_info_order_by
  stripe_id: order_by
  stripe_status: order_by
}

"""primary key columns input for table: stripe_info"""
input stripe_info_pk_columns_input {
  id: Int!
}

"""
select columns of table "stripe_info"
"""
enum stripe_info_select_column {
  """column name"""
  charges_enabled

  """column name"""
  details_submitted

  """column name"""
  id

  """column name"""
  pass_fees_to_customer

  """column name"""
  payouts_enabled

  """column name"""
  requirements

  """column name"""
  stripe_id

  """column name"""
  stripe_status
}

"""
input type for updating data in table "stripe_info"
"""
input stripe_info_set_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  stripe_id: String
  stripe_status: String
}

"""aggregate stddev on columns"""
type stripe_info_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type stripe_info_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type stripe_info_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "stripe_info"
"""
input stripe_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: stripe_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input stripe_info_stream_cursor_value_input {
  charges_enabled: Boolean
  details_submitted: Boolean
  id: Int
  pass_fees_to_customer: Boolean
  payouts_enabled: Boolean
  requirements: json
  stripe_id: String
  stripe_status: String
}

"""aggregate sum on columns"""
type stripe_info_sum_fields {
  id: Int
}

"""
update columns of table "stripe_info"
"""
enum stripe_info_update_column {
  """column name"""
  charges_enabled

  """column name"""
  details_submitted

  """column name"""
  id

  """column name"""
  pass_fees_to_customer

  """column name"""
  payouts_enabled

  """column name"""
  requirements

  """column name"""
  stripe_id

  """column name"""
  stripe_status
}

input stripe_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: stripe_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: stripe_info_set_input
  where: stripe_info_bool_exp!
}

"""aggregate var_pop on columns"""
type stripe_info_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type stripe_info_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type stripe_info_variance_fields {
  id: Float
}

"""
columns and relationships of "subscriber"
"""
type subscriber {
  """An object relationship"""
  customer: customer
  customer_id: Int!
  id: Int!

  """An object relationship"""
  restaurant: restaurant
  service_provider_id: Int!
  service_provider_type: String!

  """An object relationship"""
  user: user
}

"""
aggregated selection of "subscriber"
"""
type subscriber_aggregate {
  aggregate: subscriber_aggregate_fields
  nodes: [subscriber!]!
}

"""
aggregate fields of "subscriber"
"""
type subscriber_aggregate_fields {
  avg: subscriber_avg_fields
  count(columns: [subscriber_select_column!], distinct: Boolean): Int!
  max: subscriber_max_fields
  min: subscriber_min_fields
  stddev: subscriber_stddev_fields
  stddev_pop: subscriber_stddev_pop_fields
  stddev_samp: subscriber_stddev_samp_fields
  sum: subscriber_sum_fields
  var_pop: subscriber_var_pop_fields
  var_samp: subscriber_var_samp_fields
  variance: subscriber_variance_fields
}

"""aggregate avg on columns"""
type subscriber_avg_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "subscriber". All fields are combined with a logical 'AND'.
"""
input subscriber_bool_exp {
  _and: [subscriber_bool_exp!]
  _not: subscriber_bool_exp
  _or: [subscriber_bool_exp!]
  customer: customer_bool_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "subscriber"
"""
enum subscriber_constraint {
  """
  unique or primary key constraint on columns "service_provider_type", "service_provider_id", "customer_id"
  """
  subscriber_customer_id_service_provider_type_service_provid_key

  """
  unique or primary key constraint on columns "id"
  """
  subscriber_pkey
}

"""
input type for incrementing numeric columns in table "subscriber"
"""
input subscriber_inc_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "subscriber"
"""
input subscriber_insert_input {
  customer: customer_obj_rel_insert_input
  customer_id: Int
  id: Int
  restaurant: restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type subscriber_max_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type subscriber_min_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "subscriber"
"""
type subscriber_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subscriber!]!
}

"""
on_conflict condition type for table "subscriber"
"""
input subscriber_on_conflict {
  constraint: subscriber_constraint!
  update_columns: [subscriber_update_column!]! = []
  where: subscriber_bool_exp
}

"""Ordering options when selecting data from "subscriber"."""
input subscriber_order_by {
  customer: customer_order_by
  customer_id: order_by
  id: order_by
  restaurant: restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
  user: user_order_by
}

"""primary key columns input for table: subscriber"""
input subscriber_pk_columns_input {
  id: Int!
}

"""
select columns of table "subscriber"
"""
enum subscriber_select_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "subscriber"
"""
input subscriber_set_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type subscriber_stddev_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type subscriber_stddev_pop_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type subscriber_stddev_samp_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "subscriber"
"""
input subscriber_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: subscriber_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input subscriber_stream_cursor_value_input {
  customer_id: Int
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type subscriber_sum_fields {
  customer_id: Int
  id: Int
  service_provider_id: Int
}

"""
update columns of table "subscriber"
"""
enum subscriber_update_column {
  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input subscriber_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: subscriber_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: subscriber_set_input
  where: subscriber_bool_exp!
}

"""aggregate var_pop on columns"""
type subscriber_var_pop_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type subscriber_var_samp_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type subscriber_variance_fields {
  customer_id: Float
  id: Float
  service_provider_id: Float
}

type subscription_root {
  """
  fetch data from the table: "chat"
  """
  chat(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch aggregated fields from the table: "chat"
  """
  chat_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_order_by!]

    """filter the rows returned"""
    where: chat_bool_exp
  ): chat_aggregate!

  """fetch data from the table: "chat" using primary key columns"""
  chat_by_pk(id: Int!): chat

  """
  fetch data from the table: "chat_participant"
  """
  chat_participant(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch aggregated fields from the table: "chat_participant"
  """
  chat_participant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_participant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_participant_order_by!]

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): chat_participant_aggregate!

  """
  fetch data from the table: "chat_participant" using primary key columns
  """
  chat_participant_by_pk(id: Int!): chat_participant

  """
  fetch data from the table in a streaming manner: "chat_participant"
  """
  chat_participant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_participant_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_participant_bool_exp
  ): [chat_participant!]!

  """
  fetch data from the table in a streaming manner: "chat"
  """
  chat_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_bool_exp
  ): [chat!]!

  """
  fetch data from the table: "customer"
  """
  customer(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch aggregated fields from the table: "customer"
  """
  customer_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_order_by!]

    """filter the rows returned"""
    where: customer_bool_exp
  ): customer_aggregate!

  """fetch data from the table: "customer" using primary key columns"""
  customer_by_pk(user_id: Int!): customer

  """
  fetch data from the table in a streaming manner: "customer"
  """
  customer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customer_stream_cursor_input]!

    """filter the rows returned"""
    where: customer_bool_exp
  ): [customer!]!

  """
  fetch data from the table: "delivery_company"
  """
  delivery_company(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  fetch aggregated fields from the table: "delivery_company"
  """
  delivery_company_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_company_order_by!]

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): delivery_company_aggregate!

  """
  fetch data from the table: "delivery_company" using primary key columns
  """
  delivery_company_by_pk(id: Int!): delivery_company

  """
  fetch data from the table in a streaming manner: "delivery_company"
  """
  delivery_company_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_company_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_company_bool_exp
  ): [delivery_company!]!

  """
  fetch data from the table: "delivery_cost"
  """
  delivery_cost(
    """distinct select on columns"""
    distinct_on: [delivery_cost_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_cost_order_by!]

    """filter the rows returned"""
    where: delivery_cost_bool_exp
  ): [delivery_cost!]!

  """
  fetch aggregated fields from the table: "delivery_cost"
  """
  delivery_cost_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_cost_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_cost_order_by!]

    """filter the rows returned"""
    where: delivery_cost_bool_exp
  ): delivery_cost_aggregate!

  """fetch data from the table: "delivery_cost" using primary key columns"""
  delivery_cost_by_pk(id: Int!): delivery_cost

  """
  fetch data from the table in a streaming manner: "delivery_cost"
  """
  delivery_cost_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_cost_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_cost_bool_exp
  ): [delivery_cost!]!

  """
  fetch data from the table: "delivery_driver"
  """
  delivery_driver(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  fetch aggregated fields from the table: "delivery_driver"
  """
  delivery_driver_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_driver_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_driver_order_by!]

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): delivery_driver_aggregate!

  """fetch data from the table: "delivery_driver" using primary key columns"""
  delivery_driver_by_pk(id: Int!): delivery_driver

  """
  fetch data from the table in a streaming manner: "delivery_driver"
  """
  delivery_driver_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_driver_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_driver_bool_exp
  ): [delivery_driver!]!

  """
  fetch data from the table: "delivery_operator"
  """
  delivery_operator(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch aggregated fields from the table: "delivery_operator"
  """
  delivery_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_operator_order_by!]

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): delivery_operator_aggregate!

  """
  fetch data from the table: "delivery_operator" using primary key columns
  """
  delivery_operator_by_pk(id: Int!): delivery_operator

  """
  fetch data from the table in a streaming manner: "delivery_operator"
  """
  delivery_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_operator_bool_exp
  ): [delivery_operator!]!

  """
  fetch data from the table: "delivery_order"
  """
  delivery_order(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch aggregated fields from the table: "delivery_order"
  """
  delivery_order_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_order_by!]

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): delivery_order_aggregate!

  """fetch data from the table: "delivery_order" using primary key columns"""
  delivery_order_by_pk(id: Int!): delivery_order

  """
  fetch data from the table: "delivery_order_public"
  """
  delivery_order_public(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch aggregated fields from the table: "delivery_order_public"
  """
  delivery_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_order_public_order_by!]

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): delivery_order_public_aggregate!

  """
  fetch data from the table in a streaming manner: "delivery_order_public"
  """
  delivery_order_public_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_order_public_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_order_public_bool_exp
  ): [delivery_order_public!]!

  """
  fetch data from the table in a streaming manner: "delivery_order"
  """
  delivery_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_order_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_order_bool_exp
  ): [delivery_order!]!

  """
  fetch data from the table: "mez_admin"
  """
  mez_admin(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch aggregated fields from the table: "mez_admin"
  """
  mez_admin_aggregate(
    """distinct select on columns"""
    distinct_on: [mez_admin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mez_admin_order_by!]

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): mez_admin_aggregate!

  """fetch data from the table: "mez_admin" using primary key columns"""
  mez_admin_by_pk(user_id: Int!): mez_admin

  """
  fetch data from the table in a streaming manner: "mez_admin"
  """
  mez_admin_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mez_admin_stream_cursor_input]!

    """filter the rows returned"""
    where: mez_admin_bool_exp
  ): [mez_admin!]!

  """
  fetch data from the table: "notification_info"
  """
  notification_info(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch aggregated fields from the table: "notification_info"
  """
  notification_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_info_order_by!]

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): notification_info_aggregate!

  """
  fetch data from the table: "notification_info" using primary key columns
  """
  notification_info_by_pk(id: Int!): notification_info

  """
  fetch data from the table in a streaming manner: "notification_info"
  """
  notification_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notification_info_stream_cursor_input]!

    """filter the rows returned"""
    where: notification_info_bool_exp
  ): [notification_info!]!

  """
  fetch data from the table: "post"
  """
  post(
    """distinct select on columns"""
    distinct_on: [post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_order_by!]

    """filter the rows returned"""
    where: post_bool_exp
  ): [post!]!

  """
  fetch aggregated fields from the table: "post"
  """
  post_aggregate(
    """distinct select on columns"""
    distinct_on: [post_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_order_by!]

    """filter the rows returned"""
    where: post_bool_exp
  ): post_aggregate!

  """fetch data from the table: "post" using primary key columns"""
  post_by_pk(id: Int!): post

  """
  fetch data from the table in a streaming manner: "post"
  """
  post_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_stream_cursor_input]!

    """filter the rows returned"""
    where: post_bool_exp
  ): [post!]!

  """
  fetch data from the table: "restaurant"
  """
  restaurant(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch aggregated fields from the table: "restaurant"
  """
  restaurant_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_by!]

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): restaurant_aggregate!

  """fetch data from the table: "restaurant" using primary key columns"""
  restaurant_by_pk(id: Int!): restaurant

  """
  fetch data from the table: "restaurant_cart"
  """
  restaurant_cart(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch aggregated fields from the table: "restaurant_cart"
  """
  restaurant_cart_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): restaurant_cart_aggregate!

  """fetch data from the table: "restaurant_cart" using primary key columns"""
  restaurant_cart_by_pk(customer_id: Int!): restaurant_cart

  """
  fetch data from the table: "restaurant_cart_item"
  """
  restaurant_cart_item(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch aggregated fields from the table: "restaurant_cart_item"
  """
  restaurant_cart_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_cart_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_cart_item_order_by!]

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): restaurant_cart_item_aggregate!

  """
  fetch data from the table: "restaurant_cart_item" using primary key columns
  """
  restaurant_cart_item_by_pk(id: Int!): restaurant_cart_item

  """
  fetch data from the table in a streaming manner: "restaurant_cart_item"
  """
  restaurant_cart_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_item_bool_exp
  ): [restaurant_cart_item!]!

  """
  fetch data from the table in a streaming manner: "restaurant_cart"
  """
  restaurant_cart_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_cart_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_cart_bool_exp
  ): [restaurant_cart!]!

  """
  fetch data from the table: "restaurant_category"
  """
  restaurant_category(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch aggregated fields from the table: "restaurant_category"
  """
  restaurant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_category_order_by!]

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): restaurant_category_aggregate!

  """
  fetch data from the table: "restaurant_category" using primary key columns
  """
  restaurant_category_by_pk(id: Int!): restaurant_category

  """
  fetch data from the table in a streaming manner: "restaurant_category"
  """
  restaurant_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_category_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_category_bool_exp
  ): [restaurant_category!]!

  """
  fetch data from the table: "restaurant_choice"
  """
  restaurant_choice(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch aggregated fields from the table: "restaurant_choice"
  """
  restaurant_choice_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_choice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_choice_order_by!]

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): restaurant_choice_aggregate!

  """
  fetch data from the table: "restaurant_choice" using primary key columns
  """
  restaurant_choice_by_pk(id: Int!): restaurant_choice

  """
  fetch data from the table in a streaming manner: "restaurant_choice"
  """
  restaurant_choice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_choice_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_choice_bool_exp
  ): [restaurant_choice!]!

  """
  fetch data from the table: "restaurant_item"
  """
  restaurant_item(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch aggregated fields from the table: "restaurant_item"
  """
  restaurant_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_order_by!]

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): restaurant_item_aggregate!

  """fetch data from the table: "restaurant_item" using primary key columns"""
  restaurant_item_by_pk(id: Int!): restaurant_item

  """
  fetch data from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch aggregated fields from the table: "restaurant_item_option_map"
  """
  restaurant_item_option_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_item_option_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_item_option_map_order_by!]

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): restaurant_item_option_map_aggregate!

  """
  fetch data from the table: "restaurant_item_option_map" using primary key columns
  """
  restaurant_item_option_map_by_pk(id: Int!): restaurant_item_option_map

  """
  fetch data from the table in a streaming manner: "restaurant_item_option_map"
  """
  restaurant_item_option_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_option_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_option_map_bool_exp
  ): [restaurant_item_option_map!]!

  """
  fetch data from the table in a streaming manner: "restaurant_item"
  """
  restaurant_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_item_bool_exp
  ): [restaurant_item!]!

  """
  fetch data from the table: "restaurant_operator"
  """
  restaurant_operator(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch aggregated fields from the table: "restaurant_operator"
  """
  restaurant_operator_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_operator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_operator_order_by!]

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): restaurant_operator_aggregate!

  """
  fetch data from the table: "restaurant_operator" using primary key columns
  """
  restaurant_operator_by_pk(id: Int!): restaurant_operator

  """
  fetch data from the table in a streaming manner: "restaurant_operator"
  """
  restaurant_operator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_operator_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_operator_bool_exp
  ): [restaurant_operator!]!

  """
  fetch data from the table: "restaurant_option"
  """
  restaurant_option(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch aggregated fields from the table: "restaurant_option"
  """
  restaurant_option_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_order_by!]

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): restaurant_option_aggregate!

  """
  fetch data from the table: "restaurant_option" using primary key columns
  """
  restaurant_option_by_pk(id: Int!): restaurant_option

  """
  fetch data from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch aggregated fields from the table: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_option_choice_map_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_option_choice_map_order_by!]

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): restaurant_option_choice_map_aggregate!

  """
  fetch data from the table: "restaurant_option_choice_map" using primary key columns
  """
  restaurant_option_choice_map_by_pk(id: Int!): restaurant_option_choice_map

  """
  fetch data from the table in a streaming manner: "restaurant_option_choice_map"
  """
  restaurant_option_choice_map_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_choice_map_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_choice_map_bool_exp
  ): [restaurant_option_choice_map!]!

  """
  fetch data from the table in a streaming manner: "restaurant_option"
  """
  restaurant_option_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_option_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_option_bool_exp
  ): [restaurant_option!]!

  """
  fetch data from the table: "restaurant_order"
  """
  restaurant_order(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch aggregated fields from the table: "restaurant_order"
  """
  restaurant_order_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_order_by!]

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): restaurant_order_aggregate!

  """
  fetch data from the table: "restaurant_order" using primary key columns
  """
  restaurant_order_by_pk(id: Int!): restaurant_order

  """
  fetch data from the table: "restaurant_order_item"
  """
  restaurant_order_item(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch aggregated fields from the table: "restaurant_order_item"
  """
  restaurant_order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_item_order_by!]

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): restaurant_order_item_aggregate!

  """
  fetch data from the table: "restaurant_order_item" using primary key columns
  """
  restaurant_order_item_by_pk(id: Int!): restaurant_order_item

  """
  fetch data from the table in a streaming manner: "restaurant_order_item"
  """
  restaurant_order_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_item_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_item_bool_exp
  ): [restaurant_order_item!]!

  """
  fetch data from the table: "restaurant_order_public"
  """
  restaurant_order_public(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch aggregated fields from the table: "restaurant_order_public"
  """
  restaurant_order_public_aggregate(
    """distinct select on columns"""
    distinct_on: [restaurant_order_public_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [restaurant_order_public_order_by!]

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): restaurant_order_public_aggregate!

  """
  fetch data from the table in a streaming manner: "restaurant_order_public"
  """
  restaurant_order_public_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_public_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_public_bool_exp
  ): [restaurant_order_public!]!

  """
  fetch data from the table in a streaming manner: "restaurant_order"
  """
  restaurant_order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_order_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_order_bool_exp
  ): [restaurant_order!]!

  """
  fetch data from the table in a streaming manner: "restaurant"
  """
  restaurant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [restaurant_stream_cursor_input]!

    """filter the rows returned"""
    where: restaurant_bool_exp
  ): [restaurant!]!

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table in a streaming manner: "review"
  """
  review_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [review_stream_cursor_input]!

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch data from the table: "saved_location"
  """
  saved_location(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): [saved_location!]!

  """
  fetch aggregated fields from the table: "saved_location"
  """
  saved_location_aggregate(
    """distinct select on columns"""
    distinct_on: [saved_location_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [saved_location_order_by!]

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): saved_location_aggregate!

  """fetch data from the table: "saved_location" using primary key columns"""
  saved_location_by_pk(id: Int!): saved_location

  """
  fetch data from the table in a streaming manner: "saved_location"
  """
  saved_location_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [saved_location_stream_cursor_input]!

    """filter the rows returned"""
    where: saved_location_bool_exp
  ): [saved_location!]!

  """
  fetch data from the table: "service_link"
  """
  service_link(
    """distinct select on columns"""
    distinct_on: [service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_link_order_by!]

    """filter the rows returned"""
    where: service_link_bool_exp
  ): [service_link!]!

  """
  fetch aggregated fields from the table: "service_link"
  """
  service_link_aggregate(
    """distinct select on columns"""
    distinct_on: [service_link_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_link_order_by!]

    """filter the rows returned"""
    where: service_link_bool_exp
  ): service_link_aggregate!

  """fetch data from the table: "service_link" using primary key columns"""
  service_link_by_pk(id: Int!): service_link

  """
  fetch data from the table in a streaming manner: "service_link"
  """
  service_link_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_link_stream_cursor_input]!

    """filter the rows returned"""
    where: service_link_bool_exp
  ): [service_link!]!

  """
  fetch data from the table: "service_provider_payment_info"
  """
  service_provider_payment_info(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch aggregated fields from the table: "service_provider_payment_info"
  """
  service_provider_payment_info_aggregate(
    """distinct select on columns"""
    distinct_on: [service_provider_payment_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_provider_payment_info_order_by!]

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): service_provider_payment_info_aggregate!

  """
  fetch data from the table: "service_provider_payment_info" using primary key columns
  """
  service_provider_payment_info_by_pk(id: Int!): service_provider_payment_info

  """
  fetch data from the table in a streaming manner: "service_provider_payment_info"
  """
  service_provider_payment_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_provider_payment_info_stream_cursor_input]!

    """filter the rows returned"""
    where: service_provider_payment_info_bool_exp
  ): [service_provider_payment_info!]!

  """
  fetch data from the table: "stripe_info"
  """
  stripe_info(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch aggregated fields from the table: "stripe_info"
  """
  stripe_info_aggregate(
    """distinct select on columns"""
    distinct_on: [stripe_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stripe_info_order_by!]

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): stripe_info_aggregate!

  """fetch data from the table: "stripe_info" using primary key columns"""
  stripe_info_by_pk(id: Int!): stripe_info

  """
  fetch data from the table in a streaming manner: "stripe_info"
  """
  stripe_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [stripe_info_stream_cursor_input]!

    """filter the rows returned"""
    where: stripe_info_bool_exp
  ): [stripe_info!]!

  """
  fetch data from the table: "subscriber"
  """
  subscriber(
    """distinct select on columns"""
    distinct_on: [subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriber_order_by!]

    """filter the rows returned"""
    where: subscriber_bool_exp
  ): [subscriber!]!

  """
  fetch aggregated fields from the table: "subscriber"
  """
  subscriber_aggregate(
    """distinct select on columns"""
    distinct_on: [subscriber_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subscriber_order_by!]

    """filter the rows returned"""
    where: subscriber_bool_exp
  ): subscriber_aggregate!

  """fetch data from the table: "subscriber" using primary key columns"""
  subscriber_by_pk(id: Int!): subscriber

  """
  fetch data from the table in a streaming manner: "subscriber"
  """
  subscriber_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [subscriber_stream_cursor_input]!

    """filter the rows returned"""
    where: subscriber_bool_exp
  ): [subscriber!]!

  """
  fetch data from the table: "topology.app_type"
  """
  topology_app_type(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch aggregated fields from the table: "topology.app_type"
  """
  topology_app_type_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_app_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_app_type_order_by!]

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): topology_app_type_aggregate!

  """
  fetch data from the table: "topology.app_type" using primary key columns
  """
  topology_app_type_by_pk(
    """customer, delivery, restaurant, admin"""
    id: String!
  ): topology_app_type

  """
  fetch data from the table in a streaming manner: "topology.app_type"
  """
  topology_app_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_app_type_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_app_type_bool_exp
  ): [topology_app_type!]!

  """
  fetch data from the table: "topology.language"
  """
  topology_language(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch aggregated fields from the table: "topology.language"
  """
  topology_language_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_language_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_language_order_by!]

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): topology_language_aggregate!

  """
  fetch data from the table: "topology.language" using primary key columns
  """
  topology_language_by_pk(id: String!): topology_language

  """
  fetch data from the table in a streaming manner: "topology.language"
  """
  topology_language_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_language_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_language_bool_exp
  ): [topology_language!]!

  """
  fetch data from the table: "translation"
  """
  translation(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch aggregated fields from the table: "translation"
  """
  translation_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_order_by!]

    """filter the rows returned"""
    where: translation_bool_exp
  ): translation_aggregate!

  """fetch data from the table: "translation" using primary key columns"""
  translation_by_pk(id: Int!): translation

  """
  fetch data from the table in a streaming manner: "translation"
  """
  translation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_bool_exp
  ): [translation!]!

  """
  fetch data from the table: "translation_value"
  """
  translation_value(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch aggregated fields from the table: "translation_value"
  """
  translation_value_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!

  """
  fetch data from the table: "translation_value" using primary key columns
  """
  translation_value_by_pk(language_id: String!, translation_id: Int!): translation_value

  """
  fetch data from the table in a streaming manner: "translation_value"
  """
  translation_value_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translation_value_stream_cursor_input]!

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: Int!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topology.app_type"
"""
type topology_app_type {
  """customer, delivery, restaurant, admin"""
  id: String!
}

"""
aggregated selection of "topology.app_type"
"""
type topology_app_type_aggregate {
  aggregate: topology_app_type_aggregate_fields
  nodes: [topology_app_type!]!
}

"""
aggregate fields of "topology.app_type"
"""
type topology_app_type_aggregate_fields {
  count(columns: [topology_app_type_select_column!], distinct: Boolean): Int!
  max: topology_app_type_max_fields
  min: topology_app_type_min_fields
}

"""
Boolean expression to filter rows from the table "topology.app_type". All fields are combined with a logical 'AND'.
"""
input topology_app_type_bool_exp {
  _and: [topology_app_type_bool_exp!]
  _not: topology_app_type_bool_exp
  _or: [topology_app_type_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "topology.app_type"
"""
enum topology_app_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_type_pkey
}

"""
input type for inserting data into table "topology.app_type"
"""
input topology_app_type_insert_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""aggregate max on columns"""
type topology_app_type_max_fields {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""aggregate min on columns"""
type topology_app_type_min_fields {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
response of any mutation on the table "topology.app_type"
"""
type topology_app_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_app_type!]!
}

"""
on_conflict condition type for table "topology.app_type"
"""
input topology_app_type_on_conflict {
  constraint: topology_app_type_constraint!
  update_columns: [topology_app_type_update_column!]! = []
  where: topology_app_type_bool_exp
}

"""Ordering options when selecting data from "topology.app_type"."""
input topology_app_type_order_by {
  id: order_by
}

"""primary key columns input for table: topology.app_type"""
input topology_app_type_pk_columns_input {
  """customer, delivery, restaurant, admin"""
  id: String!
}

"""
select columns of table "topology.app_type"
"""
enum topology_app_type_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "topology.app_type"
"""
input topology_app_type_set_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
Streaming cursor of the table "topology_app_type"
"""
input topology_app_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_app_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_app_type_stream_cursor_value_input {
  """customer, delivery, restaurant, admin"""
  id: String
}

"""
update columns of table "topology.app_type"
"""
enum topology_app_type_update_column {
  """column name"""
  id
}

input topology_app_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: topology_app_type_set_input
  where: topology_app_type_bool_exp!
}

"""
columns and relationships of "topology.language"
"""
type topology_language {
  id: String!
}

"""
aggregated selection of "topology.language"
"""
type topology_language_aggregate {
  aggregate: topology_language_aggregate_fields
  nodes: [topology_language!]!
}

"""
aggregate fields of "topology.language"
"""
type topology_language_aggregate_fields {
  count(columns: [topology_language_select_column!], distinct: Boolean): Int!
  max: topology_language_max_fields
  min: topology_language_min_fields
}

"""
Boolean expression to filter rows from the table "topology.language". All fields are combined with a logical 'AND'.
"""
input topology_language_bool_exp {
  _and: [topology_language_bool_exp!]
  _not: topology_language_bool_exp
  _or: [topology_language_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "topology.language"
"""
enum topology_language_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  language_pkey
}

"""
input type for inserting data into table "topology.language"
"""
input topology_language_insert_input {
  id: String
}

"""aggregate max on columns"""
type topology_language_max_fields {
  id: String
}

"""aggregate min on columns"""
type topology_language_min_fields {
  id: String
}

"""
response of any mutation on the table "topology.language"
"""
type topology_language_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_language!]!
}

"""
input type for inserting object relation for remote table "topology.language"
"""
input topology_language_obj_rel_insert_input {
  data: topology_language_insert_input!

  """upsert condition"""
  on_conflict: topology_language_on_conflict
}

"""
on_conflict condition type for table "topology.language"
"""
input topology_language_on_conflict {
  constraint: topology_language_constraint!
  update_columns: [topology_language_update_column!]! = []
  where: topology_language_bool_exp
}

"""Ordering options when selecting data from "topology.language"."""
input topology_language_order_by {
  id: order_by
}

"""primary key columns input for table: topology.language"""
input topology_language_pk_columns_input {
  id: String!
}

"""
select columns of table "topology.language"
"""
enum topology_language_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "topology.language"
"""
input topology_language_set_input {
  id: String
}

"""
Streaming cursor of the table "topology_language"
"""
input topology_language_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_language_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_language_stream_cursor_value_input {
  id: String
}

"""
update columns of table "topology.language"
"""
enum topology_language_update_column {
  """column name"""
  id
}

input topology_language_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: topology_language_set_input
  where: topology_language_bool_exp!
}

"""
columns and relationships of "translation"
"""
type translation {
  id: Int!

  """An object relationship"""
  restaurant: restaurant
  service_provider_id: Int!
  service_provider_type: String!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): [translation_value!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translation_value_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translation_value_order_by!]

    """filter the rows returned"""
    where: translation_value_bool_exp
  ): translation_value_aggregate!
}

"""
aggregated selection of "translation"
"""
type translation_aggregate {
  aggregate: translation_aggregate_fields
  nodes: [translation!]!
}

"""
aggregate fields of "translation"
"""
type translation_aggregate_fields {
  avg: translation_avg_fields
  count(columns: [translation_select_column!], distinct: Boolean): Int!
  max: translation_max_fields
  min: translation_min_fields
  stddev: translation_stddev_fields
  stddev_pop: translation_stddev_pop_fields
  stddev_samp: translation_stddev_samp_fields
  sum: translation_sum_fields
  var_pop: translation_var_pop_fields
  var_samp: translation_var_samp_fields
  variance: translation_variance_fields
}

"""aggregate avg on columns"""
type translation_avg_fields {
  id: Float
  service_provider_id: Float
}

"""
Boolean expression to filter rows from the table "translation". All fields are combined with a logical 'AND'.
"""
input translation_bool_exp {
  _and: [translation_bool_exp!]
  _not: translation_bool_exp
  _or: [translation_bool_exp!]
  id: Int_comparison_exp
  restaurant: restaurant_bool_exp
  service_provider_id: Int_comparison_exp
  service_provider_type: String_comparison_exp
  translations: translation_value_bool_exp
  translations_aggregate: translation_value_aggregate_bool_exp
}

"""
unique or primary key constraints on table "translation"
"""
enum translation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translation_pkey
}

"""
input type for incrementing numeric columns in table "translation"
"""
input translation_inc_input {
  id: Int
  service_provider_id: Int
}

"""
input type for inserting data into table "translation"
"""
input translation_insert_input {
  id: Int
  restaurant: restaurant_obj_rel_insert_input
  service_provider_id: Int
  service_provider_type: String
  translations: translation_value_arr_rel_insert_input
}

"""aggregate max on columns"""
type translation_max_fields {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate min on columns"""
type translation_min_fields {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""
response of any mutation on the table "translation"
"""
type translation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation!]!
}

"""
input type for inserting object relation for remote table "translation"
"""
input translation_obj_rel_insert_input {
  data: translation_insert_input!

  """upsert condition"""
  on_conflict: translation_on_conflict
}

"""
on_conflict condition type for table "translation"
"""
input translation_on_conflict {
  constraint: translation_constraint!
  update_columns: [translation_update_column!]! = []
  where: translation_bool_exp
}

"""Ordering options when selecting data from "translation"."""
input translation_order_by {
  id: order_by
  restaurant: restaurant_order_by
  service_provider_id: order_by
  service_provider_type: order_by
  translations_aggregate: translation_value_aggregate_order_by
}

"""primary key columns input for table: translation"""
input translation_pk_columns_input {
  id: Int!
}

"""
select columns of table "translation"
"""
enum translation_select_column {
  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

"""
input type for updating data in table "translation"
"""
input translation_set_input {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate stddev on columns"""
type translation_stddev_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_pop on columns"""
type translation_stddev_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate stddev_samp on columns"""
type translation_stddev_samp_fields {
  id: Float
  service_provider_id: Float
}

"""
Streaming cursor of the table "translation"
"""
input translation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_stream_cursor_value_input {
  id: Int
  service_provider_id: Int
  service_provider_type: String
}

"""aggregate sum on columns"""
type translation_sum_fields {
  id: Int
  service_provider_id: Int
}

"""
update columns of table "translation"
"""
enum translation_update_column {
  """column name"""
  id

  """column name"""
  service_provider_id

  """column name"""
  service_provider_type
}

input translation_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_set_input
  where: translation_bool_exp!
}

"""
columns and relationships of "translation_value"
"""
type translation_value {
  """An object relationship"""
  language: topology_language!
  language_id: String!

  """An object relationship"""
  translation_group: translation!
  translation_id: Int!
  value: String!
}

"""
aggregated selection of "translation_value"
"""
type translation_value_aggregate {
  aggregate: translation_value_aggregate_fields
  nodes: [translation_value!]!
}

input translation_value_aggregate_bool_exp {
  count: translation_value_aggregate_bool_exp_count
}

input translation_value_aggregate_bool_exp_count {
  arguments: [translation_value_select_column!]
  distinct: Boolean
  filter: translation_value_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "translation_value"
"""
type translation_value_aggregate_fields {
  avg: translation_value_avg_fields
  count(columns: [translation_value_select_column!], distinct: Boolean): Int!
  max: translation_value_max_fields
  min: translation_value_min_fields
  stddev: translation_value_stddev_fields
  stddev_pop: translation_value_stddev_pop_fields
  stddev_samp: translation_value_stddev_samp_fields
  sum: translation_value_sum_fields
  var_pop: translation_value_var_pop_fields
  var_samp: translation_value_var_samp_fields
  variance: translation_value_variance_fields
}

"""
order by aggregate values of table "translation_value"
"""
input translation_value_aggregate_order_by {
  avg: translation_value_avg_order_by
  count: order_by
  max: translation_value_max_order_by
  min: translation_value_min_order_by
  stddev: translation_value_stddev_order_by
  stddev_pop: translation_value_stddev_pop_order_by
  stddev_samp: translation_value_stddev_samp_order_by
  sum: translation_value_sum_order_by
  var_pop: translation_value_var_pop_order_by
  var_samp: translation_value_var_samp_order_by
  variance: translation_value_variance_order_by
}

"""
input type for inserting array relation for remote table "translation_value"
"""
input translation_value_arr_rel_insert_input {
  data: [translation_value_insert_input!]!

  """upsert condition"""
  on_conflict: translation_value_on_conflict
}

"""aggregate avg on columns"""
type translation_value_avg_fields {
  translation_id: Float
}

"""
order by avg() on columns of table "translation_value"
"""
input translation_value_avg_order_by {
  translation_id: order_by
}

"""
Boolean expression to filter rows from the table "translation_value". All fields are combined with a logical 'AND'.
"""
input translation_value_bool_exp {
  _and: [translation_value_bool_exp!]
  _not: translation_value_bool_exp
  _or: [translation_value_bool_exp!]
  language: topology_language_bool_exp
  language_id: String_comparison_exp
  translation_group: translation_bool_exp
  translation_id: Int_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "translation_value"
"""
enum translation_value_constraint {
  """
  unique or primary key constraint on columns "translation_id", "language_id"
  """
  translation_value_pkey
}

"""
input type for incrementing numeric columns in table "translation_value"
"""
input translation_value_inc_input {
  translation_id: Int
}

"""
input type for inserting data into table "translation_value"
"""
input translation_value_insert_input {
  language: topology_language_obj_rel_insert_input
  language_id: String
  translation_group: translation_obj_rel_insert_input
  translation_id: Int
  value: String
}

"""aggregate max on columns"""
type translation_value_max_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by max() on columns of table "translation_value"
"""
input translation_value_max_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type translation_value_min_fields {
  language_id: String
  translation_id: Int
  value: String
}

"""
order by min() on columns of table "translation_value"
"""
input translation_value_min_order_by {
  language_id: order_by
  translation_id: order_by
  value: order_by
}

"""
response of any mutation on the table "translation_value"
"""
type translation_value_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translation_value!]!
}

"""
on_conflict condition type for table "translation_value"
"""
input translation_value_on_conflict {
  constraint: translation_value_constraint!
  update_columns: [translation_value_update_column!]! = []
  where: translation_value_bool_exp
}

"""Ordering options when selecting data from "translation_value"."""
input translation_value_order_by {
  language: topology_language_order_by
  language_id: order_by
  translation_group: translation_order_by
  translation_id: order_by
  value: order_by
}

"""primary key columns input for table: translation_value"""
input translation_value_pk_columns_input {
  language_id: String!
  translation_id: Int!
}

"""
select columns of table "translation_value"
"""
enum translation_value_select_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

"""
input type for updating data in table "translation_value"
"""
input translation_value_set_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate stddev on columns"""
type translation_value_stddev_fields {
  translation_id: Float
}

"""
order by stddev() on columns of table "translation_value"
"""
input translation_value_stddev_order_by {
  translation_id: order_by
}

"""aggregate stddev_pop on columns"""
type translation_value_stddev_pop_fields {
  translation_id: Float
}

"""
order by stddev_pop() on columns of table "translation_value"
"""
input translation_value_stddev_pop_order_by {
  translation_id: order_by
}

"""aggregate stddev_samp on columns"""
type translation_value_stddev_samp_fields {
  translation_id: Float
}

"""
order by stddev_samp() on columns of table "translation_value"
"""
input translation_value_stddev_samp_order_by {
  translation_id: order_by
}

"""
Streaming cursor of the table "translation_value"
"""
input translation_value_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translation_value_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translation_value_stream_cursor_value_input {
  language_id: String
  translation_id: Int
  value: String
}

"""aggregate sum on columns"""
type translation_value_sum_fields {
  translation_id: Int
}

"""
order by sum() on columns of table "translation_value"
"""
input translation_value_sum_order_by {
  translation_id: order_by
}

"""
update columns of table "translation_value"
"""
enum translation_value_update_column {
  """column name"""
  language_id

  """column name"""
  translation_id

  """column name"""
  value
}

input translation_value_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: translation_value_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: translation_value_set_input
  where: translation_value_bool_exp!
}

"""aggregate var_pop on columns"""
type translation_value_var_pop_fields {
  translation_id: Float
}

"""
order by var_pop() on columns of table "translation_value"
"""
input translation_value_var_pop_order_by {
  translation_id: order_by
}

"""aggregate var_samp on columns"""
type translation_value_var_samp_fields {
  translation_id: Float
}

"""
order by var_samp() on columns of table "translation_value"
"""
input translation_value_var_samp_order_by {
  translation_id: order_by
}

"""aggregate variance on columns"""
type translation_value_variance_fields {
  translation_id: Float
}

"""
order by variance() on columns of table "translation_value"
"""
input translation_value_variance_order_by {
  translation_id: order_by
}

"""aggregate var_pop on columns"""
type translation_var_pop_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate var_samp on columns"""
type translation_var_samp_fields {
  id: Float
  service_provider_id: Float
}

"""aggregate variance on columns"""
type translation_variance_fields {
  id: Float
  service_provider_id: Float
}

"""
columns and relationships of "user"
"""
type user {
  big_image: String

  """An object relationship"""
  customer: customer
  deleted: Boolean!
  email: String
  firebase_id: String!
  id: Int!
  image: String
  language_id: String!
  name: String
  phone: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""aggregate avg on columns"""
type user_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  big_image: String_comparison_exp
  customer: customer_bool_exp
  deleted: Boolean_comparison_exp
  email: String_comparison_exp
  firebase_id: String_comparison_exp
  id: Int_comparison_exp
  image: String_comparison_exp
  language_id: String_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for incrementing numeric columns in table "user"
"""
input user_inc_input {
  id: Int
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  big_image: String
  customer: customer_obj_rel_insert_input
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate max on columns"""
type user_max_fields {
  big_image: String
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate min on columns"""
type user_min_fields {
  big_image: String
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  big_image: order_by
  customer: customer_order_by
  deleted: order_by
  email: order_by
  firebase_id: order_by
  id: order_by
  image: order_by
  language_id: order_by
  name: order_by
  phone: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: Int!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  big_image

  """column name"""
  deleted

  """column name"""
  email

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name

  """column name"""
  phone
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  big_image: String
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate stddev on columns"""
type user_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type user_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type user_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  big_image: String
  deleted: Boolean
  email: String
  firebase_id: String
  id: Int
  image: String
  language_id: String
  name: String
  phone: String
}

"""aggregate sum on columns"""
type user_sum_fields {
  id: Int
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  big_image

  """column name"""
  deleted

  """column name"""
  email

  """column name"""
  firebase_id

  """column name"""
  id

  """column name"""
  image

  """column name"""
  language_id

  """column name"""
  name

  """column name"""
  phone
}

input user_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input
  where: user_bool_exp!
}

"""aggregate var_pop on columns"""
type user_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type user_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type user_variance_fields {
  id: Float
}
